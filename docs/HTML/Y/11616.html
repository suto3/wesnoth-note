<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>i1</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/4380.html#L362'>i1</a>                362 data/ai/lua/battle_calcs.lua         local i1 = count.hit_miss_counts[1]</span>
<span class='curline'><a href='../S/4380.html#L366'>i1</a>                366 data/ai/lua/battle_calcs.lua         if not counts[i1] then counts[i1] = {} end</span>
<span class='curline'><a href='../S/4380.html#L367'>i1</a>                367 data/ai/lua/battle_calcs.lua         if not counts[i1][i2] then counts[i1][i2] = {} end</span>
<span class='curline'><a href='../S/4380.html#L368'>i1</a>                368 data/ai/lua/battle_calcs.lua         if not counts[i1][i2][i3] then counts[i1][i2][i3] = {} end</span>
<span class='curline'><a href='../S/4380.html#L369'>i1</a>                369 data/ai/lua/battle_calcs.lua         counts[i1][i2][i3][i4] = (counts[i1][i2][i3][i4] or 0) + 1</span>
<span class='curline'><a href='../S/4380.html#L423'>i1</a>                423 data/ai/lua/battle_calcs.lua     local i1 = count.hit_miss_counts[3] -- note that the order here is different from above</span>
<span class='curline'><a href='../S/4380.html#L427'>i1</a>                427 data/ai/lua/battle_calcs.lua         if not counts[i1] then counts[i1] = {} end</span>
<span class='curline'><a href='../S/4380.html#L428'>i1</a>                428 data/ai/lua/battle_calcs.lua         if not counts[i1][i2] then counts[i1][i2] = {} end</span>
<span class='curline'><a href='../S/4380.html#L429'>i1</a>                429 data/ai/lua/battle_calcs.lua         if not counts[i1][i2][i3] then counts[i1][i2][i3] = {} end</span>
<span class='curline'><a href='../S/4380.html#L430'>i1</a>                430 data/ai/lua/battle_calcs.lua         counts[i1][i2][i3][i4] = (counts[i1][i2][i3][i4] or 0) + 1</span>
<span class='curline'><a href='../S/5552.html#L101'>i1</a>                101 data/lua/cave_map_generator.lua 		for i1, item in ipairs(v.items or {}) do</span>
<span class='curline'><a href='../S/1156.html#L48'>i1</a>                 48 src/font/marked-up_text.cpp std::string::const_iterator parse_markup(std::string::const_iterator i1,</span>
<span class='curline'><a href='../S/1156.html#L53'>i1</a>                 53 src/font/marked-up_text.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/1156.html#L54'>i1</a>                 54 src/font/marked-up_text.cpp 		switch(*i1) {</span>
<span class='curline'><a href='../S/1156.html#L84'>i1</a>                 84 src/font/marked-up_text.cpp 			return i1+1;</span>
<span class='curline'><a href='../S/1156.html#L87'>i1</a>                 87 src/font/marked-up_text.cpp 				std::string::const_iterator start = i1;</span>
<span class='curline'><a href='../S/1156.html#L90'>i1</a>                 90 src/font/marked-up_text.cpp 				++i1;</span>
<span class='curline'><a href='../S/1156.html#L92'>i1</a>                 92 src/font/marked-up_text.cpp 				while (i1 != i2 &amp;&amp; *i1 &gt;= '0' &amp;&amp; *i1&lt;='9') {</span>
<span class='curline'><a href='../S/1156.html#L94'>i1</a>                 94 src/font/marked-up_text.cpp 					temp += lexical_cast&lt;int, char&gt;(*i1);</span>
<span class='curline'><a href='../S/1156.html#L95'>i1</a>                 95 src/font/marked-up_text.cpp 					++i1;</span>
<span class='curline'><a href='../S/1156.html#L99'>i1</a>                 99 src/font/marked-up_text.cpp 				if (i1 != i2 &amp;&amp; ',' == (*i1)) {</span>
<span class='curline'><a href='../S/1156.html#L100'>i1</a>                100 src/font/marked-up_text.cpp 					++i1;</span>
<span class='curline'><a href='../S/1156.html#L101'>i1</a>                101 src/font/marked-up_text.cpp 					while(i1 != i2 &amp;&amp; *i1 &gt;= '0' &amp;&amp; *i1&lt;='9'){</span>
<span class='curline'><a href='../S/1156.html#L103'>i1</a>                103 src/font/marked-up_text.cpp 						temp += lexical_cast&lt;int, char&gt;(*i1);</span>
<span class='curline'><a href='../S/1156.html#L104'>i1</a>                104 src/font/marked-up_text.cpp 						++i1;</span>
<span class='curline'><a href='../S/1156.html#L109'>i1</a>                109 src/font/marked-up_text.cpp 				if (i1 != i2 &amp;&amp; ',' == (*i1)) {</span>
<span class='curline'><a href='../S/1156.html#L110'>i1</a>                110 src/font/marked-up_text.cpp 					++i1;</span>
<span class='curline'><a href='../S/1156.html#L111'>i1</a>                111 src/font/marked-up_text.cpp 					while(i1 != i2 &amp;&amp; *i1 &gt;= '0' &amp;&amp; *i1&lt;='9'){</span>
<span class='curline'><a href='../S/1156.html#L113'>i1</a>                113 src/font/marked-up_text.cpp 						temp += lexical_cast&lt;int, char&gt;(*i1);</span>
<span class='curline'><a href='../S/1156.html#L114'>i1</a>                114 src/font/marked-up_text.cpp 						++i1;</span>
<span class='curline'><a href='../S/1156.html#L118'>i1</a>                118 src/font/marked-up_text.cpp 				if (i1 != i2 &amp;&amp; '&gt;' == (*i1)) {</span>
<span class='curline'><a href='../S/1156.html#L125'>i1</a>                125 src/font/marked-up_text.cpp 				if (i1 == i2) return i1;</span>
<span class='curline'><a href='../S/1156.html#L129'>i1</a>                129 src/font/marked-up_text.cpp 			return i1;</span>
<span class='curline'><a href='../S/1156.html#L131'>i1</a>                131 src/font/marked-up_text.cpp 		++i1;</span>
<span class='curline'><a href='../S/1156.html#L133'>i1</a>                133 src/font/marked-up_text.cpp 	return i1;</span>
<span class='curline'><a href='../S/1156.html#L140'>i1</a>                140 src/font/marked-up_text.cpp 		std::string::const_iterator i1 = line-&gt;begin(),</span>
<span class='curline'><a href='../S/1156.html#L142'>i1</a>                142 src/font/marked-up_text.cpp 		*line = std::string(parse_markup(i1,i2,nullptr,nullptr,nullptr),i2);</span>
<span class='curline'><a href='../S/1156.html#L168'>i1</a>                168 src/font/marked-up_text.cpp 	std::string::const_iterator i1 = text.begin();</span>
<span class='curline'><a href='../S/1156.html#L169'>i1</a>                169 src/font/marked-up_text.cpp 	std::string::const_iterator i2 = std::find(i1,text.end(),'\n');</span>
<span class='curline'><a href='../S/1156.html#L175'>i1</a>                175 src/font/marked-up_text.cpp 		i1 = parse_markup(i1,i2,&amp;sz,&amp;col,&amp;text_style);</span>
<span class='curline'><a href='../S/1156.html#L177'>i1</a>                177 src/font/marked-up_text.cpp 		if(i1 != i2) {</span>
<span class='curline'><a href='../S/1156.html#L178'>i1</a>                178 src/font/marked-up_text.cpp 			std::string new_string = utils::unescape(std::string(i1, i2));</span>
<span class='curline'><a href='../S/1156.html#L193'>i1</a>                193 src/font/marked-up_text.cpp 		i1 = i2+1;</span>
<span class='curline'><a href='../S/1156.html#L194'>i1</a>                194 src/font/marked-up_text.cpp 		i2 = std::find(i1,text.end(),'\n');</span>
<span class='curline'><a href='../S/1137.html#L36'>i1</a>                 36 src/font/marked-up_text.hpp std::string::const_iterator parse_markup(std::string::const_iterator i1,</span>
<span class='curline'><a href='../S/772.html#L34'>i1</a>                 34 src/formula/formula.cpp static std::string tokens_to_string(const tk::token* i1, const tk::token* i2)</span>
<span class='curline'><a href='../S/772.html#L37'>i1</a>                 37 src/formula/formula.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L38'>i1</a>                 38 src/formula/formula.cpp 		expr &lt;&lt; std::string(i1-&gt;begin, i1-&gt;end) &lt;&lt; " ";</span>
<span class='curline'><a href='../S/772.html#L39'>i1</a>                 39 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L63'>i1</a>                 63 src/formula/formula.cpp expression_ptr parse_expression(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols);</span>
<span class='curline'><a href='../S/772.html#L75'>i1</a>                 75 src/formula/formula.cpp 	std::string::const_iterator i1 = text.begin(), i2 = text.end();</span>
<span class='curline'><a href='../S/772.html#L94'>i1</a>                 94 src/formula/formula.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L96'>i1</a>                 96 src/formula/formula.cpp 			tokens.push_back(tk::get_token(i1,i2));</span>
<span class='curline'><a href='../S/772.html#L209'>i1</a>                209 src/formula/formula.cpp formula::formula(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L215'>i1</a>                215 src/formula/formula.cpp 	if(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L216'>i1</a>                216 src/formula/formula.cpp 		expr_ = parse_expression(i1, i2, symbols);</span>
<span class='curline'><a href='../S/772.html#L1081'>i1</a>               1081 src/formula/formula.cpp static void parse_function_args(const tk::token* &amp;i1, const tk::token* i2, std::vector&lt;std::string&gt;* res)</span>
<span class='curline'><a href='../S/772.html#L1083'>i1</a>               1083 src/formula/formula.cpp  	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1085'>i1</a>               1085 src/formula/formula.cpp 	if(i1-&gt;type == tk::TOKEN_LPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1086'>i1</a>               1086 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L1088'>i1</a>               1088 src/formula/formula.cpp 		throw formula_error("Invalid function definition", tokens_to_string(begin,end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1091'>i1</a>               1091 src/formula/formula.cpp 	while((i1-&gt; type != tk::TOKEN_RPARENS) &amp;&amp; (i1 != i2)) {</span>
<span class='curline'><a href='../S/772.html#L1092'>i1</a>               1092 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1093'>i1</a>               1093 src/formula/formula.cpp 			if(std::string((i1+1)-&gt;begin, (i1+1)-&gt;end) == "*") {</span>
<span class='curline'><a href='../S/772.html#L1094'>i1</a>               1094 src/formula/formula.cpp 				res-&gt;push_back(std::string(i1-&gt;begin, i1-&gt;end) + std::string("*"));</span>
<span class='curline'><a href='../S/772.html#L1095'>i1</a>               1095 src/formula/formula.cpp 				++i1;</span>
<span class='curline'><a href='../S/772.html#L1097'>i1</a>               1097 src/formula/formula.cpp 				res-&gt;push_back(std::string(i1-&gt;begin, i1-&gt;end));</span>
<span class='curline'><a href='../S/772.html#L1099'>i1</a>               1099 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA) {</span>
<span class='curline'><a href='../S/772.html#L1102'>i1</a>               1102 src/formula/formula.cpp 			throw formula_error("Invalid function definition", tokens_to_string(begin,end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1105'>i1</a>               1105 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L1108'>i1</a>               1108 src/formula/formula.cpp 	if(i1-&gt;type != tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1109'>i1</a>               1109 src/formula/formula.cpp 		throw formula_error("Invalid function definition", tokens_to_string(begin,end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1112'>i1</a>               1112 src/formula/formula.cpp 	++i1;</span>
<span class='curline'><a href='../S/772.html#L1115'>i1</a>               1115 src/formula/formula.cpp static void parse_args(const tk::token* i1, const tk::token* i2,</span>
<span class='curline'><a href='../S/772.html#L1120'>i1</a>               1120 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1121'>i1</a>               1121 src/formula/formula.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L1122'>i1</a>               1122 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS || i1-&gt;type == tk::TOKEN_LSQUARE ) {</span>
<span class='curline'><a href='../S/772.html#L1124'>i1</a>               1124 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS || i1-&gt;type == tk::TOKEN_RSQUARE ) {</span>
<span class='curline'><a href='../S/772.html#L1126'>i1</a>               1126 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA &amp;&amp; !parens) {</span>
<span class='curline'><a href='../S/772.html#L1127'>i1</a>               1127 src/formula/formula.cpp 			res-&gt;push_back(parse_expression(beg, i1, symbols));</span>
<span class='curline'><a href='../S/772.html#L1128'>i1</a>               1128 src/formula/formula.cpp 			beg = i1+1;</span>
<span class='curline'><a href='../S/772.html#L1131'>i1</a>               1131 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L1134'>i1</a>               1134 src/formula/formula.cpp 	if(beg != i1) {</span>
<span class='curline'><a href='../S/772.html#L1135'>i1</a>               1135 src/formula/formula.cpp 		res-&gt;push_back(parse_expression(beg, i1, symbols));</span>
<span class='curline'><a href='../S/772.html#L1139'>i1</a>               1139 src/formula/formula.cpp static void parse_set_args(const tk::token* i1, const tk::token* i2,</span>
<span class='curline'><a href='../S/772.html#L1145'>i1</a>               1145 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1146'>i1</a>               1146 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1147'>i1</a>               1147 src/formula/formula.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L1148'>i1</a>               1148 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS || i1-&gt;type == tk::TOKEN_LSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1150'>i1</a>               1150 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS || i1-&gt;type == tk::TOKEN_RSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1152'>i1</a>               1152 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_POINTER &amp;&amp; !parens ) {</span>
<span class='curline'><a href='../S/772.html#L1155'>i1</a>               1155 src/formula/formula.cpp 				res-&gt;push_back(parse_expression(beg, i1, symbols));</span>
<span class='curline'><a href='../S/772.html#L1156'>i1</a>               1156 src/formula/formula.cpp 				beg = i1+1;</span>
<span class='curline'><a href='../S/772.html#L1158'>i1</a>               1158 src/formula/formula.cpp 				throw formula_error("Too many '-&gt;' operators found", tokens_to_string(begin,end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1160'>i1</a>               1160 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA &amp;&amp; !parens ) {</span>
<span class='curline'><a href='../S/772.html#L1164'>i1</a>               1164 src/formula/formula.cpp 				throw formula_error("Expected comma, but '-&gt;' found", tokens_to_string(begin,end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1166'>i1</a>               1166 src/formula/formula.cpp 			res-&gt;push_back(parse_expression(beg, i1, symbols));</span>
<span class='curline'><a href='../S/772.html#L1167'>i1</a>               1167 src/formula/formula.cpp 			beg = i1+1;</span>
<span class='curline'><a href='../S/772.html#L1170'>i1</a>               1170 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L1173'>i1</a>               1173 src/formula/formula.cpp 	if(beg != i1) {</span>
<span class='curline'><a href='../S/772.html#L1174'>i1</a>               1174 src/formula/formula.cpp 		res-&gt;push_back(parse_expression(beg, i1, symbols));</span>
<span class='curline'><a href='../S/772.html#L1178'>i1</a>               1178 src/formula/formula.cpp static void parse_where_clauses(const tk::token* i1, const tk::token* i2, expr_table_ptr res, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L1181'>i1</a>               1181 src/formula/formula.cpp 	const tk::token* original_i1_cached = i1;</span>
<span class='curline'><a href='../S/772.html#L1182'>i1</a>               1182 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1183'>i1</a>               1183 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1186'>i1</a>               1186 src/formula/formula.cpp 	while(i1 != i2) {</span>
<span class='curline'><a href='../S/772.html#L1187'>i1</a>               1187 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1189'>i1</a>               1189 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1192'>i1</a>               1192 src/formula/formula.cpp 			if(i1-&gt;type == tk::TOKEN_COMMA) {</span>
<span class='curline'><a href='../S/772.html#L1195'>i1</a>               1195 src/formula/formula.cpp 						tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1198'>i1</a>               1198 src/formula/formula.cpp 				(*res)[var_name] = parse_expression(beg, i1, symbols);</span>
<span class='curline'><a href='../S/772.html#L1199'>i1</a>               1199 src/formula/formula.cpp 				beg = i1+1;</span>
<span class='curline'><a href='../S/772.html#L1201'>i1</a>               1201 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_OPERATOR) {</span>
<span class='curline'><a href='../S/772.html#L1202'>i1</a>               1202 src/formula/formula.cpp 				std::string op_name(i1-&gt;begin, i1-&gt;end);</span>
<span class='curline'><a href='../S/772.html#L1206'>i1</a>               1206 src/formula/formula.cpp 						if(i1 == original_i1_cached) {</span>
<span class='curline'><a href='../S/772.html#L1208'>i1</a>               1208 src/formula/formula.cpp 								tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1211'>i1</a>               1211 src/formula/formula.cpp 								tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1213'>i1</a>               1213 src/formula/formula.cpp 					} else if(beg+1 != i1) {</span>
<span class='curline'><a href='../S/772.html#L1215'>i1</a>               1215 src/formula/formula.cpp 							tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1218'>i1</a>               1218 src/formula/formula.cpp 							tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1222'>i1</a>               1222 src/formula/formula.cpp 					beg = i1+1;</span>
<span class='curline'><a href='../S/772.html#L1226'>i1</a>               1226 src/formula/formula.cpp 		++i1;</span>
<span class='curline'><a href='../S/772.html#L1229'>i1</a>               1229 src/formula/formula.cpp 	if(beg != i1) {</span>
<span class='curline'><a href='../S/772.html#L1232'>i1</a>               1232 src/formula/formula.cpp 				tokens_to_string(begin, end - 1), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1235'>i1</a>               1235 src/formula/formula.cpp 		(*res)[var_name] = parse_expression(beg, i1, symbols);</span>
<span class='curline'><a href='../S/772.html#L1239'>i1</a>               1239 src/formula/formula.cpp expression_ptr parse_expression(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L1241'>i1</a>               1241 src/formula/formula.cpp 	if(i1 == i2) {</span>
<span class='curline'><a href='../S/772.html#L1242'>i1</a>               1242 src/formula/formula.cpp 		throw formula_error("Empty expression", "", *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1251'>i1</a>               1251 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1253'>i1</a>               1253 src/formula/formula.cpp 	if(i1-&gt;type == tk::TOKEN_KEYWORD &amp;&amp; (i1 + 1)-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1254'>i1</a>               1254 src/formula/formula.cpp 		if(std::string(i1-&gt;begin, i1-&gt;end) == "def") {</span>
<span class='curline'><a href='../S/772.html#L1255'>i1</a>               1255 src/formula/formula.cpp 			++i1;</span>
<span class='curline'><a href='../S/772.html#L1256'>i1</a>               1256 src/formula/formula.cpp 			const std::string formula_name = std::string(i1-&gt;begin, i1-&gt;end);</span>
<span class='curline'><a href='../S/772.html#L1259'>i1</a>               1259 src/formula/formula.cpp 			parse_function_args(++i1, i2, &amp;args);</span>
<span class='curline'><a href='../S/772.html#L1261'>i1</a>               1261 src/formula/formula.cpp 			const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1262'>i1</a>               1262 src/formula/formula.cpp 			while((i1 != i2) &amp;&amp; (i1-&gt;type != tk::TOKEN_SEMICOLON)) {</span>
<span class='curline'><a href='../S/772.html#L1263'>i1</a>               1263 src/formula/formula.cpp 				++i1;</span>
<span class='curline'><a href='../S/772.html#L1268'>i1</a>               1268 src/formula/formula.cpp 				throw formula_error("Function symbol table required but not present", "",*i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1274'>i1</a>               1274 src/formula/formula.cpp 						formula_name, const_formula_ptr(new formula(beg, i1, symbols)),</span>
<span class='curline'><a href='../S/772.html#L1280'>i1</a>               1280 src/formula/formula.cpp 			if((i1 == i2) || (i1 == (i2-1))) {</span>
<span class='curline'><a href='../S/772.html#L1283'>i1</a>               1283 src/formula/formula.cpp 				return parse_expression((i1+1), i2, symbols);</span>
<span class='curline'><a href='../S/772.html#L1292'>i1</a>               1292 src/formula/formula.cpp 	for(const tk::token* i = i1; i != i2; ++i) {</span>
<span class='curline'><a href='../S/772.html#L1311'>i1</a>               1311 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS &amp;&amp; (i2-1)-&gt;type == tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1312'>i1</a>               1312 src/formula/formula.cpp 			return parse_expression(i1+1,i2-1,symbols);</span>
<span class='curline'><a href='../S/772.html#L1315'>i1</a>               1315 src/formula/formula.cpp 			if(i2 - i1 == 3 &amp;&amp; i1-&gt;type == tk::TOKEN_LSQUARE &amp;&amp; (i1+1)-&gt;type == tk::TOKEN_POINTER) {</span>
<span class='curline'><a href='../S/772.html#L1322'>i1</a>               1322 src/formula/formula.cpp 			while ((tok-&gt;type != tk::TOKEN_LSQUARE || square_parens) &amp;&amp; tok != i1) {</span>
<span class='curline'><a href='../S/772.html#L1334'>i1</a>               1334 src/formula/formula.cpp 				if(tok == i1) {</span>
<span class='curline'><a href='../S/772.html#L1339'>i1</a>               1339 src/formula/formula.cpp 						parse_set_args(i1+1, i2-1, &amp;args, symbols);</span>
<span class='curline'><a href='../S/772.html#L1342'>i1</a>               1342 src/formula/formula.cpp 						parse_args(i1+1,i2-1,&amp;args,symbols);</span>
<span class='curline'><a href='../S/772.html#L1350'>i1</a>               1350 src/formula/formula.cpp 								parse_expression(i1,      tok,    symbols),</span>
<span class='curline'><a href='../S/772.html#L1355'>i1</a>               1355 src/formula/formula.cpp 						throw formula_error( e.type, tokens_to_string(i1, i2-1), *i1-&gt;filename, i1-&gt;line_number );</span>
<span class='curline'><a href='../S/772.html#L1359'>i1</a>               1359 src/formula/formula.cpp 		} else if(i2 - i1 == 1) {</span>
<span class='curline'><a href='../S/772.html#L1360'>i1</a>               1360 src/formula/formula.cpp 			if(i1-&gt;type == tk::TOKEN_KEYWORD) {</span>
<span class='curline'><a href='../S/772.html#L1361'>i1</a>               1361 src/formula/formula.cpp 				if(std::string(i1-&gt;begin, i1-&gt;end) == "functions") {</span>
<span class='curline'><a href='../S/772.html#L1364'>i1</a>               1364 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1365'>i1</a>               1365 src/formula/formula.cpp 				return expression_ptr(new identifier_expression(std::string(i1-&gt;begin, i1-&gt;end)));</span>
<span class='curline'><a href='../S/772.html#L1366'>i1</a>               1366 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_INTEGER) {</span>
<span class='curline'><a href='../S/772.html#L1367'>i1</a>               1367 src/formula/formula.cpp 				int n = std::stoi(std::string(i1-&gt;begin, i1-&gt;end));</span>
<span class='curline'><a href='../S/772.html#L1369'>i1</a>               1369 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_DECIMAL) {</span>
<span class='curline'><a href='../S/772.html#L1370'>i1</a>               1370 src/formula/formula.cpp 				tk::iterator dot = i1-&gt;begin;</span>
<span class='curline'><a href='../S/772.html#L1375'>i1</a>               1375 src/formula/formula.cpp 				int n = std::stoi(std::string(i1-&gt;begin,dot));</span>
<span class='curline'><a href='../S/772.html#L1377'>i1</a>               1377 src/formula/formula.cpp 				tk::iterator literal_end = i1-&gt;end;</span>
<span class='curline'><a href='../S/772.html#L1395'>i1</a>               1395 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_STRING_LITERAL) {</span>
<span class='curline'><a href='../S/772.html#L1396'>i1</a>               1396 src/formula/formula.cpp 				return expression_ptr(new string_expression(std::string(i1-&gt;begin + 1, i1-&gt;end - 1)));</span>
<span class='curline'><a href='../S/772.html#L1398'>i1</a>               1398 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_IDENTIFIER &amp;&amp;</span>
<span class='curline'><a href='../S/772.html#L1399'>i1</a>               1399 src/formula/formula.cpp 		          (i1+1)-&gt;type == tk::TOKEN_LPARENS &amp;&amp;</span>
<span class='curline'><a href='../S/772.html#L1402'>i1</a>               1402 src/formula/formula.cpp 			const tk::token* function_call_begin = i1, *function_call_end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1404'>i1</a>               1404 src/formula/formula.cpp 			for(const tk::token* i = i1; i != i2; ++i) {</span>
<span class='curline'><a href='../S/772.html#L1414'>i1</a>               1414 src/formula/formula.cpp 				parse_args(i1+2,i2-1,&amp;args,symbols);</span>
<span class='curline'><a href='../S/772.html#L1416'>i1</a>               1416 src/formula/formula.cpp 					return symbols-&gt;create_function(std::string(i1-&gt;begin, i1-&gt;end),args);</span>
<span class='curline'><a href='../S/772.html#L1419'>i1</a>               1419 src/formula/formula.cpp 					throw formula_error(e.type, tokens_to_string(function_call_begin, function_call_end), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1424'>i1</a>               1424 src/formula/formula.cpp 		throw formula_error("Could not parse expression", tokens_to_string(i1, i2), *i1-&gt;filename, i1-&gt;line_number);</span>
<span class='curline'><a href='../S/772.html#L1431'>i1</a>               1431 src/formula/formula.cpp 	if(op == i1) {</span>
<span class='curline'><a href='../S/772.html#L1445'>i1</a>               1445 src/formula/formula.cpp 				parse_expression(i1,    op, symbols),</span>
<span class='curline'><a href='../S/772.html#L1455'>i1</a>               1455 src/formula/formula.cpp 		return expression_ptr(new where_expression(parse_expression(i1, op, symbols), table));</span>
<span class='curline'><a href='../S/772.html#L1460'>i1</a>               1460 src/formula/formula.cpp 			parse_expression(i1,     op, symbols),</span>
<span class='curline'><a href='../S/784.html#L37'>i1</a>                 37 src/formula/formula.hpp 	formula(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols = nullptr);</span>
<span class='curline'><a href='../S/787.html#L26'>i1</a>                 26 src/formula/tokenizer.cpp void raise_exception(iterator&amp; i1, iterator i2, std::string str) {</span>
<span class='curline'><a href='../S/787.html#L28'>i1</a>                 28 src/formula/tokenizer.cpp 	while( (i1 != i2) &amp;&amp; (*i1 != '\n') ) {</span>
<span class='curline'><a href='../S/787.html#L29'>i1</a>                 29 src/formula/tokenizer.cpp 		if( (*i1 != '\t') )</span>
<span class='curline'><a href='../S/787.html#L30'>i1</a>                 30 src/formula/tokenizer.cpp 			expr &lt;&lt; *i1;</span>
<span class='curline'><a href='../S/787.html#L31'>i1</a>                 31 src/formula/tokenizer.cpp 		++i1;</span>
<span class='curline'><a href='../S/787.html#L42'>i1</a>                 42 src/formula/tokenizer.cpp token get_token(iterator&amp; i1, const iterator i2) {</span>
<span class='curline'><a href='../S/787.html#L44'>i1</a>                 44 src/formula/tokenizer.cpp 	iterator it = i1;</span>
<span class='curline'><a href='../S/787.html#L45'>i1</a>                 45 src/formula/tokenizer.cpp 	if( *i1 &gt;= 'A' ) {</span>
<span class='curline'><a href='../S/787.html#L49'>i1</a>                 49 src/formula/tokenizer.cpp 		if( *i1 &lt;= 'Z' || ( *i1 &gt;= 'a' &amp;&amp; *it &lt;= 'z' ) || *i1 == '_' ) {</span>
<span class='curline'><a href='../S/787.html#L51'>i1</a>                 51 src/formula/tokenizer.cpp 			while( i1 != i2 &amp;&amp; ( ( *i1 &gt;= 'a' &amp;&amp; *i1 &lt;= 'z' ) || *i1 == '_' || ( *i1 &gt;= 'A' &amp;&amp; *i1 &lt;= 'Z' ) ) )</span>
<span class='curline'><a href='../S/787.html#L52'>i1</a>                 52 src/formula/tokenizer.cpp 				++i1;</span>
<span class='curline'><a href='../S/787.html#L54'>i1</a>                 54 src/formula/tokenizer.cpp 			int diff = i1 - it;</span>
<span class='curline'><a href='../S/787.html#L86'>i1</a>                 86 src/formula/tokenizer.cpp 				std::string s(it, i1);</span>
<span class='curline'><a href='../S/787.html#L90'>i1</a>                 90 src/formula/tokenizer.cpp 				std::string s(it, i1);</span>
<span class='curline'><a href='../S/787.html#L96'>i1</a>                 96 src/formula/tokenizer.cpp 				std::string s(it, i1);</span>
<span class='curline'><a href='../S/787.html#L101'>i1</a>                101 src/formula/tokenizer.cpp 			return token( it, i1, t);</span>
<span class='curline'><a href='../S/787.html#L104'>i1</a>                104 src/formula/tokenizer.cpp 			if( *i1 == '[' )</span>
<span class='curline'><a href='../S/787.html#L105'>i1</a>                105 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_LSQUARE );</span>
<span class='curline'><a href='../S/787.html#L107'>i1</a>                107 src/formula/tokenizer.cpp 			if( *i1 == ']' )</span>
<span class='curline'><a href='../S/787.html#L108'>i1</a>                108 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_RSQUARE );</span>
<span class='curline'><a href='../S/787.html#L110'>i1</a>                110 src/formula/tokenizer.cpp 			if( *i1 == '^' )</span>
<span class='curline'><a href='../S/787.html#L111'>i1</a>                111 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_OPERATOR );</span>
<span class='curline'><a href='../S/787.html#L113'>i1</a>                113 src/formula/tokenizer.cpp 			if( *i1 == '~' )</span>
<span class='curline'><a href='../S/787.html#L114'>i1</a>                114 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_OPERATOR );</span>
<span class='curline'><a href='../S/787.html#L123'>i1</a>                123 src/formula/tokenizer.cpp 		if( *i1 &lt;= ' ' ) {</span>
<span class='curline'><a href='../S/787.html#L124'>i1</a>                124 src/formula/tokenizer.cpp 			if( *i1 == '\n' ) {</span>
<span class='curline'><a href='../S/787.html#L125'>i1</a>                125 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_EOL);</span>
<span class='curline'><a href='../S/787.html#L128'>i1</a>                128 src/formula/tokenizer.cpp 				while( i1 != i2 &amp;&amp; *i1 &lt;= ' ' &amp;&amp; *i1 != '\n' )</span>
<span class='curline'><a href='../S/787.html#L129'>i1</a>                129 src/formula/tokenizer.cpp 					++i1;</span>
<span class='curline'><a href='../S/787.html#L131'>i1</a>                131 src/formula/tokenizer.cpp 				return token( it, i1, TOKEN_WHITESPACE );</span>
<span class='curline'><a href='../S/787.html#L134'>i1</a>                134 src/formula/tokenizer.cpp 		} else if ( *i1 &gt;= '0' ){</span>
<span class='curline'><a href='../S/787.html#L136'>i1</a>                136 src/formula/tokenizer.cpp 			if( *i1 &lt;= '9' ) {</span>
<span class='curline'><a href='../S/787.html#L138'>i1</a>                138 src/formula/tokenizer.cpp 				++i1;</span>
<span class='curline'><a href='../S/787.html#L141'>i1</a>                141 src/formula/tokenizer.cpp 				while( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L142'>i1</a>                142 src/formula/tokenizer.cpp 					if( *i1 &gt;= '0' &amp;&amp; *i1 &lt;= '9' ) {</span>
<span class='curline'><a href='../S/787.html#L146'>i1</a>                146 src/formula/tokenizer.cpp 						if( *i1 == '.' ) {</span>
<span class='curline'><a href='../S/787.html#L155'>i1</a>                155 src/formula/tokenizer.cpp 					++i1;</span>
<span class='curline'><a href='../S/787.html#L159'>i1</a>                159 src/formula/tokenizer.cpp 					return token( it, i1, TOKEN_DECIMAL );</span>
<span class='curline'><a href='../S/787.html#L161'>i1</a>                161 src/formula/tokenizer.cpp 					return token( it, i1, TOKEN_INTEGER );</span>
<span class='curline'><a href='../S/787.html#L170'>i1</a>                170 src/formula/tokenizer.cpp 				if( *i1 == ';' ) {</span>
<span class='curline'><a href='../S/787.html#L171'>i1</a>                171 src/formula/tokenizer.cpp 					return token( it, ++i1, TOKEN_SEMICOLON);</span>
<span class='curline'><a href='../S/787.html#L172'>i1</a>                172 src/formula/tokenizer.cpp 				} else if( *i1 == '=' ) {</span>
<span class='curline'><a href='../S/787.html#L173'>i1</a>                173 src/formula/tokenizer.cpp 					return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L174'>i1</a>                174 src/formula/tokenizer.cpp 				} else if( *i1 == '&lt;' ) {</span>
<span class='curline'><a href='../S/787.html#L175'>i1</a>                175 src/formula/tokenizer.cpp 					++i1;</span>
<span class='curline'><a href='../S/787.html#L176'>i1</a>                176 src/formula/tokenizer.cpp 					if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L177'>i1</a>                177 src/formula/tokenizer.cpp 						if( *i1 == '=' )</span>
<span class='curline'><a href='../S/787.html#L178'>i1</a>                178 src/formula/tokenizer.cpp 							return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L180'>i1</a>                180 src/formula/tokenizer.cpp 							return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L182'>i1</a>                182 src/formula/tokenizer.cpp 						return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L183'>i1</a>                183 src/formula/tokenizer.cpp 				} else if( *i1 == '&gt;' ) {</span>
<span class='curline'><a href='../S/787.html#L184'>i1</a>                184 src/formula/tokenizer.cpp 					++i1;</span>
<span class='curline'><a href='../S/787.html#L185'>i1</a>                185 src/formula/tokenizer.cpp 					if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L186'>i1</a>                186 src/formula/tokenizer.cpp 						if( *i1 == '=' )</span>
<span class='curline'><a href='../S/787.html#L187'>i1</a>                187 src/formula/tokenizer.cpp 							return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L189'>i1</a>                189 src/formula/tokenizer.cpp 							return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L191'>i1</a>                191 src/formula/tokenizer.cpp 						return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L201'>i1</a>                201 src/formula/tokenizer.cpp 		} else if ( *i1 == ',' ) {</span>
<span class='curline'><a href='../S/787.html#L202'>i1</a>                202 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_COMMA);</span>
<span class='curline'><a href='../S/787.html#L204'>i1</a>                204 src/formula/tokenizer.cpp 		} else if ( *i1 == '.' ) {</span>
<span class='curline'><a href='../S/787.html#L205'>i1</a>                205 src/formula/tokenizer.cpp 			++i1;</span>
<span class='curline'><a href='../S/787.html#L207'>i1</a>                207 src/formula/tokenizer.cpp 			if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L208'>i1</a>                208 src/formula/tokenizer.cpp 				if( *i1 == '+' || *i1 == '-' || *i1 == '*' || *i1 == '/' || *i1 == '.')</span>
<span class='curline'><a href='../S/787.html#L209'>i1</a>                209 src/formula/tokenizer.cpp 					return token( it, ++i1, TOKEN_OPERATOR );</span>
<span class='curline'><a href='../S/787.html#L211'>i1</a>                211 src/formula/tokenizer.cpp 					return token( it, i1, TOKEN_OPERATOR );</span>
<span class='curline'><a href='../S/787.html#L213'>i1</a>                213 src/formula/tokenizer.cpp 				return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L216'>i1</a>                216 src/formula/tokenizer.cpp 		} else if ( *i1 == '(' ) {</span>
<span class='curline'><a href='../S/787.html#L217'>i1</a>                217 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_LPARENS);</span>
<span class='curline'><a href='../S/787.html#L219'>i1</a>                219 src/formula/tokenizer.cpp 		} else if ( *i1 == ')' ) {</span>
<span class='curline'><a href='../S/787.html#L220'>i1</a>                220 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_RPARENS);</span>
<span class='curline'><a href='../S/787.html#L222'>i1</a>                222 src/formula/tokenizer.cpp 		} else if ( *i1 == '\'' ) {</span>
<span class='curline'><a href='../S/787.html#L224'>i1</a>                224 src/formula/tokenizer.cpp 			++i1;</span>
<span class='curline'><a href='../S/787.html#L225'>i1</a>                225 src/formula/tokenizer.cpp 			while (i1 != i2) {</span>
<span class='curline'><a href='../S/787.html#L226'>i1</a>                226 src/formula/tokenizer.cpp 				if (*i1 == '[') {</span>
<span class='curline'><a href='../S/787.html#L228'>i1</a>                228 src/formula/tokenizer.cpp 				} else if(bracket_depth &gt; 0 &amp;&amp; *i1 == ']') {</span>
<span class='curline'><a href='../S/787.html#L230'>i1</a>                230 src/formula/tokenizer.cpp 				} else if(bracket_depth == 0 &amp;&amp; *i1 == '\'') {</span>
<span class='curline'><a href='../S/787.html#L233'>i1</a>                233 src/formula/tokenizer.cpp 				++i1;</span>
<span class='curline'><a href='../S/787.html#L236'>i1</a>                236 src/formula/tokenizer.cpp 			if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L237'>i1</a>                237 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_STRING_LITERAL );</span>
<span class='curline'><a href='../S/787.html#L242'>i1</a>                242 src/formula/tokenizer.cpp 		} else if ( *i1 == '#' ) {</span>
<span class='curline'><a href='../S/787.html#L243'>i1</a>                243 src/formula/tokenizer.cpp 			++i1;</span>
<span class='curline'><a href='../S/787.html#L244'>i1</a>                244 src/formula/tokenizer.cpp 			while( i1 != i2 &amp;&amp; *i1 != '#' )</span>
<span class='curline'><a href='../S/787.html#L245'>i1</a>                245 src/formula/tokenizer.cpp 				++i1;</span>
<span class='curline'><a href='../S/787.html#L247'>i1</a>                247 src/formula/tokenizer.cpp 			if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L248'>i1</a>                248 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_COMMENT );</span>
<span class='curline'><a href='../S/787.html#L253'>i1</a>                253 src/formula/tokenizer.cpp 		} else if ( *i1 == '+' ) {</span>
<span class='curline'><a href='../S/787.html#L254'>i1</a>                254 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L256'>i1</a>                256 src/formula/tokenizer.cpp 		} else if ( *i1 == '-' ) {</span>
<span class='curline'><a href='../S/787.html#L257'>i1</a>                257 src/formula/tokenizer.cpp 			++i1;</span>
<span class='curline'><a href='../S/787.html#L259'>i1</a>                259 src/formula/tokenizer.cpp 			if( i1 != i2 ) {</span>
<span class='curline'><a href='../S/787.html#L260'>i1</a>                260 src/formula/tokenizer.cpp 				if( *i1 == '&gt;' )</span>
<span class='curline'><a href='../S/787.html#L261'>i1</a>                261 src/formula/tokenizer.cpp 					return token( it, ++i1, TOKEN_POINTER );</span>
<span class='curline'><a href='../S/787.html#L263'>i1</a>                263 src/formula/tokenizer.cpp 					return token( it, i1, TOKEN_OPERATOR );</span>
<span class='curline'><a href='../S/787.html#L265'>i1</a>                265 src/formula/tokenizer.cpp 				return token( it, i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L268'>i1</a>                268 src/formula/tokenizer.cpp 		} else if ( *i1 == '*' ) {</span>
<span class='curline'><a href='../S/787.html#L269'>i1</a>                269 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L271'>i1</a>                271 src/formula/tokenizer.cpp 		} else if ( *i1 == '/' ) {</span>
<span class='curline'><a href='../S/787.html#L272'>i1</a>                272 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L274'>i1</a>                274 src/formula/tokenizer.cpp 		} else if ( *i1 == '%' ) {</span>
<span class='curline'><a href='../S/787.html#L275'>i1</a>                275 src/formula/tokenizer.cpp 			return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/787.html#L277'>i1</a>                277 src/formula/tokenizer.cpp 		} else if ( *i1 == '!' ) {</span>
<span class='curline'><a href='../S/787.html#L278'>i1</a>                278 src/formula/tokenizer.cpp 			++i1;</span>
<span class='curline'><a href='../S/787.html#L279'>i1</a>                279 src/formula/tokenizer.cpp 			if( *i1 == '=' )</span>
<span class='curline'><a href='../S/787.html#L280'>i1</a>                280 src/formula/tokenizer.cpp 				return token( it, ++i1, TOKEN_OPERATOR);</span>
<span class='curline'><a href='../S/776.html#L46'>i1</a>                 46 src/formula/tokenizer.hpp 	token(iterator&amp; i1, iterator i2, TOKEN_TYPE type) :</span>
<span class='curline'><a href='../S/776.html#L48'>i1</a>                 48 src/formula/tokenizer.hpp 		begin(i1),</span>
<span class='curline'><a href='../S/776.html#L61'>i1</a>                 61 src/formula/tokenizer.hpp token get_token(iterator&amp; i1, iterator i2);</span>
<span class='curline'><a href='../S/623.html#L583'>i1</a>                583 src/gui/widgets/listbox.cpp 	bool default_sort(unsigned i1, unsigned i2)</span>
<span class='curline'><a href='../S/623.html#L585'>i1</a>                585 src/gui/widgets/listbox.cpp 		return i1 &lt; i2;</span>
<span class='curline'><a href='../S/1180.html#L129'>i1</a>                129 src/lua/lobject.cpp       lua_Integer i1; lua_Integer i2;</span>
<span class='curline'><a href='../S/1180.html#L130'>i1</a>                130 src/lua/lobject.cpp       if (tointeger(p1, &amp;i1) &amp;&amp; tointeger(p2, &amp;i2)) {</span>
<span class='curline'><a href='../S/1180.html#L131'>i1</a>                131 src/lua/lobject.cpp         setivalue(res, intarith(L, op, i1, i2));</span>
<span class='curline'><a href='../S/1173.html#L413'>i1</a>                413 src/lua/lvm.cpp       lua_Integer i1, i2;  /* compare them as integers */</span>
<span class='curline'><a href='../S/1173.html#L414'>i1</a>                414 src/lua/lvm.cpp       return (tointeger(t1, &amp;i1) &amp;&amp; tointeger(t2, &amp;i2) &amp;&amp; i1 == i2);</span>
<span class='curline'><a href='../S/116.html#L107'>i1</a>                107 src/serialization/string_utils.cpp 	std::string::const_iterator i1 = val.begin();</span>
<span class='curline'><a href='../S/116.html#L111'>i1</a>                111 src/serialization/string_utils.cpp 		while (i1 != val.end() &amp;&amp; portable_isspace(*i1))</span>
<span class='curline'><a href='../S/116.html#L112'>i1</a>                112 src/serialization/string_utils.cpp 			++i1;</span>
<span class='curline'><a href='../S/116.html#L114'>i1</a>                114 src/serialization/string_utils.cpp 	i2=i1;</span>
<span class='curline'><a href='../S/116.html#L115'>i1</a>                115 src/serialization/string_utils.cpp 	j1=i1;</span>
<span class='curline'><a href='../S/116.html#L117'>i1</a>                117 src/serialization/string_utils.cpp 	if (i1 == val.end()) return res;</span>
<span class='curline'><a href='../S/116.html#L185'>i1</a>                185 src/serialization/string_utils.cpp 					std::string tmp2(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L198'>i1</a>                198 src/serialization/string_utils.cpp 				j1 = i1;</span>
<span class='curline'><a href='../S/116.html#L224'>i1</a>                224 src/serialization/string_utils.cpp 			i1=i2;</span>
<span class='curline'><a href='../S/116.html#L304'>i1</a>                304 src/serialization/string_utils.cpp 	std::string::const_iterator i1 = val.begin();</span>
<span class='curline'><a href='../S/116.html#L307'>i1</a>                307 src/serialization/string_utils.cpp 		while (i1 != val.end() &amp;&amp; portable_isspace(*i1))</span>
<span class='curline'><a href='../S/116.html#L308'>i1</a>                308 src/serialization/string_utils.cpp 			++i1;</span>
<span class='curline'><a href='../S/116.html#L310'>i1</a>                310 src/serialization/string_utils.cpp 	i2=i1;</span>
<span class='curline'><a href='../S/116.html#L319'>i1</a>                319 src/serialization/string_utils.cpp 			std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L329'>i1</a>                329 src/serialization/string_utils.cpp 			i1=i2;</span>
<span class='curline'><a href='../S/116.html#L335'>i1</a>                335 src/serialization/string_utils.cpp 				std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L340'>i1</a>                340 src/serialization/string_utils.cpp 				i1=i2;</span>
<span class='curline'><a href='../S/116.html#L352'>i1</a>                352 src/serialization/string_utils.cpp 					std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L357'>i1</a>                357 src/serialization/string_utils.cpp 					i1=i2;</span>
<span class='curline'><a href='../S/116.html#L372'>i1</a>                372 src/serialization/string_utils.cpp 	std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L775'>i1</a>                775 src/serialization/string_utils.cpp 	std::string::const_iterator i1 = val.begin();</span>
<span class='curline'><a href='../S/116.html#L784'>i1</a>                784 src/serialization/string_utils.cpp 			std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/116.html#L795'>i1</a>                795 src/serialization/string_utils.cpp 			i1 = i2;</span>
<span class='curline'><a href='../S/116.html#L801'>i1</a>                801 src/serialization/string_utils.cpp 	std::string new_val(i1, i2);</span>
<span class='curline'><a href='../S/125.html#L71'>i1</a>                 71 src/serialization/unicode_cast.hpp 		input_itor i1 = source.begin();</span>
<span class='curline'><a href='../S/125.html#L74'>i1</a>                 74 src/serialization/unicode_cast.hpp 		while(i1 != i2) {</span>
<span class='curline'><a href='../S/125.html#L75'>i1</a>                 75 src/serialization/unicode_cast.hpp 			impl_writer::write (dst, impl_reader::read(i1, i2));</span>
<span class='curline'><a href='../S/146.html#L53'>i1</a>                 53 src/server/game.cpp 		simple_wml::string_span::const_iterator i1 = val.begin();</span>
<span class='curline'><a href='../S/146.html#L54'>i1</a>                 54 src/server/game.cpp 		simple_wml::string_span::const_iterator i2 = i1;</span>
<span class='curline'><a href='../S/146.html#L58'>i1</a>                 58 src/server/game.cpp 				conv(res, simple_wml::string_span(i1, i2));</span>
<span class='curline'><a href='../S/146.html#L60'>i1</a>                 60 src/server/game.cpp 				i1 = i2;</span>
<span class='curline'><a href='../S/146.html#L65'>i1</a>                 65 src/server/game.cpp 		conv(res, simple_wml::string_span(i1, i2));</span>
<span class='curline'><a href='../S/152.html#L50'>i1</a>                 50 src/server/simple_wml.hpp 		const char* i1 = str_;</span>
<span class='curline'><a href='../S/152.html#L52'>i1</a>                 52 src/server/simple_wml.hpp 		while(i1 != i2 &amp;&amp; *o &amp;&amp; *i1 == *o) {</span>
<span class='curline'><a href='../S/152.html#L53'>i1</a>                 53 src/server/simple_wml.hpp 			++i1;</span>
<span class='curline'><a href='../S/152.html#L57'>i1</a>                 57 src/server/simple_wml.hpp 		return i1 == i2 &amp;&amp; *o == 0;</span>
<span class='curline'><a href='../S/726.html#L179'>i1</a>                179 src/tests/test_formula_core.cpp 	std::string::const_iterator i1 = test.begin();</span>
<span class='curline'><a href='../S/726.html#L193'>i1</a>                193 src/tests/test_formula_core.cpp 		token t = get_token(i1, i2);</span>
<span class='curline'><a href='../S/1012.html#L429'>i1</a>                429 src/units/drawer.cpp 		const Uint32* const i1 = begin + image-&gt;w*y;</span>
<span class='curline'><a href='../S/1012.html#L430'>i1</a>                430 src/units/drawer.cpp 		const Uint32* const i2 = i1 + image-&gt;w;</span>
<span class='curline'><a href='../S/1012.html#L431'>i1</a>                431 src/units/drawer.cpp 		const Uint32* const itor = std::find_if(i1,i2,is_energy_color());</span>
<span class='curline'><a href='../S/1012.html#L439'>i1</a>                439 src/units/drawer.cpp 			first_col = itor - i1;</span>
</pre>
</body>
</html>
