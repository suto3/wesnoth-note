<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>rect2</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1097.html#L244'>rect2</a>             244 src/halo.cpp   		SDL_Rect rect2 = rect_;</span>
<span class='curline'><a href='../S/1097.html#L245'>rect2</a>             245 src/halo.cpp   		buffer_.assign(get_surface_portion(screen,rect2));</span>
<span class='curline'><a href='../S/1097.html#L247'>rect2</a>             247 src/halo.cpp   		SDL_Rect rect2 = rect_;</span>
<span class='curline'><a href='../S/1097.html#L248'>rect2</a>             248 src/halo.cpp   		sdl_copy_portion(screen,&amp;rect2,buffer_,nullptr);</span>
<span class='curline'><a href='../S/977.html#L31'>rect2</a>              31 src/sdl/rect.cpp bool rects_overlap(const SDL_Rect&amp; rect1, const SDL_Rect&amp; rect2)</span>
<span class='curline'><a href='../S/977.html#L33'>rect2</a>              33 src/sdl/rect.cpp 	return (rect1.x &lt; rect2.x+rect2.w &amp;&amp; rect2.x &lt; rect1.x+rect1.w &amp;&amp;</span>
<span class='curline'><a href='../S/977.html#L34'>rect2</a>              34 src/sdl/rect.cpp 			rect1.y &lt; rect2.y+rect2.h &amp;&amp; rect2.y &lt; rect1.y+rect1.h);</span>
<span class='curline'><a href='../S/977.html#L37'>rect2</a>              37 src/sdl/rect.cpp SDL_Rect intersect_rects(SDL_Rect const &amp;rect1, SDL_Rect const &amp;rect2)</span>
<span class='curline'><a href='../S/977.html#L40'>rect2</a>              40 src/sdl/rect.cpp 	res.x = std::max&lt;int&gt;(rect1.x, rect2.x);</span>
<span class='curline'><a href='../S/977.html#L41'>rect2</a>              41 src/sdl/rect.cpp 	res.y = std::max&lt;int&gt;(rect1.y, rect2.y);</span>
<span class='curline'><a href='../S/977.html#L42'>rect2</a>              42 src/sdl/rect.cpp 	int w = std::min&lt;int&gt;(rect1.x + rect1.w, rect2.x + rect2.w) - res.x;</span>
<span class='curline'><a href='../S/977.html#L43'>rect2</a>              43 src/sdl/rect.cpp 	int h = std::min&lt;int&gt;(rect1.y + rect1.h, rect2.y + rect2.h) - res.y;</span>
<span class='curline'><a href='../S/977.html#L50'>rect2</a>              50 src/sdl/rect.cpp SDL_Rect union_rects(SDL_Rect const &amp;rect1, SDL_Rect const &amp;rect2)</span>
<span class='curline'><a href='../S/977.html#L52'>rect2</a>              52 src/sdl/rect.cpp 	if (rect1.w == 0 || rect1.h == 0) return rect2;</span>
<span class='curline'><a href='../S/977.html#L53'>rect2</a>              53 src/sdl/rect.cpp 	if (rect2.w == 0 || rect2.h == 0) return rect1;</span>
<span class='curline'><a href='../S/977.html#L55'>rect2</a>              55 src/sdl/rect.cpp 	res.x = std::min&lt;int&gt;(rect1.x, rect2.x);</span>
<span class='curline'><a href='../S/977.html#L56'>rect2</a>              56 src/sdl/rect.cpp 	res.y = std::min&lt;int&gt;(rect1.y, rect2.y);</span>
<span class='curline'><a href='../S/977.html#L57'>rect2</a>              57 src/sdl/rect.cpp 	res.w = std::max&lt;int&gt;(rect1.x + rect1.w, rect2.x + rect2.w) - res.x;</span>
<span class='curline'><a href='../S/977.html#L58'>rect2</a>              58 src/sdl/rect.cpp 	res.h = std::max&lt;int&gt;(rect1.y + rect1.h, rect2.y + rect2.h) - res.y;</span>
<span class='curline'><a href='../S/981.html#L70'>rect2</a>              70 src/sdl/rect.hpp bool rects_overlap(const SDL_Rect&amp; rect1, const SDL_Rect&amp; rect2);</span>
<span class='curline'><a href='../S/981.html#L80'>rect2</a>              80 src/sdl/rect.hpp SDL_Rect intersect_rects(SDL_Rect const &amp;rect1, SDL_Rect const &amp;rect2);</span>
<span class='curline'><a href='../S/981.html#L92'>rect2</a>              92 src/sdl/rect.hpp SDL_Rect union_rects(const SDL_Rect &amp;rect1, const SDL_Rect &amp;rect2);</span>
</pre>
</body>
</html>
