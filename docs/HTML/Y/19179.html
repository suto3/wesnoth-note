<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>string_</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/772.html#L419'>string_</a>           419 src/formula/formula.cpp 	explicit string_callable(const variant&amp; string) : string_(string) {}</span>
<span class='curline'><a href='../S/772.html#L433'>string_</a>           433 src/formula/formula.cpp 			return variant(string_.as_string().length());</span>
<span class='curline'><a href='../S/772.html#L435'>string_</a>           435 src/formula/formula.cpp 			return variant(string_.as_string().empty());</span>
<span class='curline'><a href='../S/772.html#L438'>string_</a>           438 src/formula/formula.cpp 			for(char c : string_.as_string()) {</span>
<span class='curline'><a href='../S/772.html#L445'>string_</a>           445 src/formula/formula.cpp 			const std::string&amp; str = string_.as_string();</span>
<span class='curline'><a href='../S/772.html#L456'>string_</a>           456 src/formula/formula.cpp 			std::vector&lt;std::string&gt; split = utils::parenthetical_split(string_.as_string(), ',');</span>
<span class='curline'><a href='../S/772.html#L470'>string_</a>           470 src/formula/formula.cpp 	variant string_;</span>
<span class='curline'><a href='../S/780.html#L192'>string_</a>           192 src/formula/variant_value.cpp 	for(const auto&amp; c : string_) {</span>
<span class='curline'><a href='../S/781.html#L373'>string_</a>           373 src/formula/variant_value.hpp 	explicit variant_string(const std::string&amp; str) : string_(str) {}</span>
<span class='curline'><a href='../S/781.html#L377'>string_</a>           377 src/formula/variant_value.hpp 		return string_.empty();</span>
<span class='curline'><a href='../S/781.html#L387'>string_</a>           387 src/formula/variant_value.hpp 		return string_;</span>
<span class='curline'><a href='../S/781.html#L392'>string_</a>           392 src/formula/variant_value.hpp 		return string_;</span>
<span class='curline'><a href='../S/781.html#L399'>string_</a>           399 src/formula/variant_value.hpp 		return string_;</span>
<span class='curline'><a href='../S/781.html#L404'>string_</a>           404 src/formula/variant_value.hpp 		return string_ == value_ref_cast&lt;variant_string&gt;(other).string_;</span>
<span class='curline'><a href='../S/781.html#L409'>string_</a>           409 src/formula/variant_value.hpp 		return string_ &lt; value_ref_cast&lt;variant_string&gt;(other).string_;</span>
<span class='curline'><a href='../S/781.html#L419'>string_</a>           419 src/formula/variant_value.hpp 	std::string string_;</span>
<span class='curline'><a href='../S/1083.html#L60'>string_</a>            60 src/tstring.cpp 	string_(string.value_),</span>
<span class='curline'><a href='../S/1083.html#L62'>string_</a>            62 src/tstring.cpp 	end_(string_.size()),</span>
<span class='curline'><a href='../S/1083.html#L78'>string_</a>            78 src/tstring.cpp 	if(begin_ == string_.size())</span>
<span class='curline'><a href='../S/1083.html#L81'>string_</a>            81 src/tstring.cpp 	switch(string_[begin_]) {</span>
<span class='curline'><a href='../S/1083.html#L85'>string_</a>            85 src/tstring.cpp 			string_.find(TEXTDOMAIN_SEPARATOR, begin_ + 1);</span>
<span class='curline'><a href='../S/1083.html#L87'>string_</a>            87 src/tstring.cpp 		if(textdomain_end == std::string::npos || textdomain_end &gt;= string_.size() - 1) {</span>
<span class='curline'><a href='../S/1083.html#L88'>string_</a>            88 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L89'>string_</a>            89 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L93'>string_</a>            93 src/tstring.cpp 		end_ = string_.find_first_of(mark, textdomain_end + 1);</span>
<span class='curline'><a href='../S/1083.html#L95'>string_</a>            95 src/tstring.cpp 			end_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L97'>string_</a>            97 src/tstring.cpp 		textdomain_ = std::string(string_, begin_+1, textdomain_end - begin_ - 1);</span>
<span class='curline'><a href='../S/1083.html#L105'>string_</a>           105 src/tstring.cpp 		if(begin_ + 3 &gt;= string_.size()) {</span>
<span class='curline'><a href='../S/1083.html#L106'>string_</a>           106 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L107'>string_</a>           107 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L110'>string_</a>           110 src/tstring.cpp 		end_ = string_.find_first_of(mark, begin_ + 3);</span>
<span class='curline'><a href='../S/1083.html#L112'>string_</a>           112 src/tstring.cpp 			end_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L114'>string_</a>           114 src/tstring.cpp 		id = string_[begin_ + 1] + string_[begin_ + 2] * 256;</span>
<span class='curline'><a href='../S/1083.html#L116'>string_</a>           116 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L117'>string_</a>           117 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L127'>string_</a>           127 src/tstring.cpp 		end_ = string_.find_first_of(mark, begin_ + 1);</span>
<span class='curline'><a href='../S/1083.html#L129'>string_</a>           129 src/tstring.cpp 			end_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L132'>string_</a>           132 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L133'>string_</a>           133 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L143'>string_</a>           143 src/tstring.cpp 		begin_ = string_.find_first_of(mark, end_ + 5);</span>
<span class='curline'><a href='../S/1083.html#L145'>string_</a>           145 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L146'>string_</a>           146 src/tstring.cpp 		if(string_[begin_] == PLURAL_PART) {</span>
<span class='curline'><a href='../S/1083.html#L147'>string_</a>           147 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L148'>string_</a>           148 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L155'>string_</a>           155 src/tstring.cpp 		end_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L161'>string_</a>           161 src/tstring.cpp 	if(translatable_ &amp;&amp; string_[end_] == PLURAL_PART) {</span>
<span class='curline'><a href='../S/1083.html#L163'>string_</a>           163 src/tstring.cpp 		if(end_ + 5 &gt;= string_.size()) {</span>
<span class='curline'><a href='../S/1083.html#L164'>string_</a>           164 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L165'>string_</a>           165 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L168'>string_</a>           168 src/tstring.cpp 		std::string::size_type real_end = string_.find_first_of(mark, end_ + 6);</span>
<span class='curline'><a href='../S/1083.html#L169'>string_</a>           169 src/tstring.cpp 		if(real_end &lt; string_.size() &amp;&amp; string_[real_end] == PLURAL_PART) {</span>
<span class='curline'><a href='../S/1083.html#L170'>string_</a>           170 src/tstring.cpp 			ERR_CF &lt;&lt; "Error: invalid string: " &lt;&lt; string_ &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/1083.html#L171'>string_</a>           171 src/tstring.cpp 			begin_ = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L179'>string_</a>           179 src/tstring.cpp 		std::copy_n(string_.data() + end_ + 1, 4, cvt.data);</span>
<span class='curline'><a href='../S/1083.html#L202'>string_</a>           202 src/tstring.cpp 	std::string::size_type pl_end = string_.find_first_of(mark, end_ + 5);</span>
<span class='curline'><a href='../S/1083.html#L204'>string_</a>           204 src/tstring.cpp 		pl_end = string_.size();</span>
<span class='curline'><a href='../S/1083.html#L206'>string_</a>           206 src/tstring.cpp 	return string_.begin() + pl_end;</span>
<span class='curline'><a href='../S/320.html#L33'>string_</a>            33 src/tstring.hpp 		bool eos() const                          { return begin_ == string_.size(); }</span>
<span class='curline'><a href='../S/320.html#L34'>string_</a>            34 src/tstring.hpp 		bool last() const                         { return end_ == string_.size(); }</span>
<span class='curline'><a href='../S/320.html#L39'>string_</a>            39 src/tstring.hpp 		std::string::const_iterator begin() const { return string_.begin() + begin_; }</span>
<span class='curline'><a href='../S/320.html#L40'>string_</a>            40 src/tstring.hpp 		std::string::const_iterator end() const   { return string_.begin() + end_; }</span>
<span class='curline'><a href='../S/320.html#L46'>string_</a>            46 src/tstring.hpp 		const std::string&amp; string_;</span>
</pre>
</body>
</html>
