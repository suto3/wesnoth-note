<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>ptr_</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/858.html#L97'>ptr_</a>               97 src/utils/smart_list.hpp 		iterator_base() : ptr_(nullptr) {}</span>
<span class='curline'><a href='../S/858.html#L99'>ptr_</a>               99 src/utils/smart_list.hpp 		explicit iterator_base(node_t * ptr) : ptr_(ptr)</span>
<span class='curline'><a href='../S/858.html#L103'>ptr_</a>              103 src/utils/smart_list.hpp 		iterator_base(const iterator_base&lt;V,R&gt; &amp; that) : ptr_(that.ptr_)</span>
<span class='curline'><a href='../S/858.html#L106'>ptr_</a>              106 src/utils/smart_list.hpp 		iterator_base(const iterator_base &amp; that) : ptr_(that.ptr_)</span>
<span class='curline'><a href='../S/858.html#L111'>ptr_</a>              111 src/utils/smart_list.hpp 		~iterator_base()                   { unref(ptr_); }</span>
<span class='curline'><a href='../S/858.html#L119'>ptr_</a>              119 src/utils/smart_list.hpp 			node_t * old_ptr = ptr_;</span>
<span class='curline'><a href='../S/858.html#L120'>ptr_</a>              120 src/utils/smart_list.hpp 			ptr_ = that.ptr_;</span>
<span class='curline'><a href='../S/858.html#L130'>ptr_</a>              130 src/utils/smart_list.hpp 		bool operator==(const iterator_base &amp; that) const  { return ptr_ == that.ptr_; }</span>
<span class='curline'><a href='../S/858.html#L131'>ptr_</a>              131 src/utils/smart_list.hpp 		bool operator!=(const iterator_base &amp; that) const  { return ptr_ != that.ptr_; }</span>
<span class='curline'><a href='../S/858.html#L134'>ptr_</a>              134 src/utils/smart_list.hpp 		reference operator*() const        { return *ptr_-&gt;dat_ptr; }</span>
<span class='curline'><a href='../S/858.html#L135'>ptr_</a>              135 src/utils/smart_list.hpp 		pointer  operator-&gt;() const        { return ptr_-&gt;dat_ptr; }</span>
<span class='curline'><a href='../S/858.html#L158'>ptr_</a>              158 src/utils/smart_list.hpp 		bool derefable() const             { return derefable(ptr_); }</span>
<span class='curline'><a href='../S/858.html#L167'>ptr_</a>              167 src/utils/smart_list.hpp 		void inc(bool reverse)             { ptr_ = reverse ? ptr_-&gt;prev : ptr_-&gt;next; }</span>
<span class='curline'><a href='../S/858.html#L176'>ptr_</a>              176 src/utils/smart_list.hpp 		node_t * ptr_;</span>
<span class='curline'><a href='../S/858.html#L387'>ptr_</a>              387 src/utils/smart_list.hpp 	return iterator(insert(pos.ptr_, d));</span>
<span class='curline'><a href='../S/858.html#L396'>ptr_</a>              396 src/utils/smart_list.hpp 		insert(pos.ptr_, *it);</span>
<span class='curline'><a href='../S/858.html#L404'>ptr_</a>              404 src/utils/smart_list.hpp 		insert(pos.ptr_, d);</span>
<span class='curline'><a href='../S/858.html#L412'>ptr_</a>              412 src/utils/smart_list.hpp 	flag(*pos.ptr_); // We know *pos cannot get deleted yet because pos points to it.</span>
<span class='curline'><a href='../S/858.html#L413'>ptr_</a>              413 src/utils/smart_list.hpp 	return iterator(pos.ptr_-&gt;next);</span>
<span class='curline'><a href='../S/858.html#L422'>ptr_</a>              422 src/utils/smart_list.hpp 	node_t * node_ptr = start.ptr_;</span>
<span class='curline'><a href='../S/858.html#L423'>ptr_</a>              423 src/utils/smart_list.hpp 	while ( node_ptr != stop.ptr_  &amp;&amp;  iterator::derefable(node_ptr) ) {</span>
<span class='curline'><a href='../S/858.html#L463'>ptr_</a>              463 src/utils/smart_list.hpp 		splice(pos.ptr_, *L.root_.next, *L.root_.prev);</span>
<span class='curline'><a href='../S/858.html#L470'>ptr_</a>              470 src/utils/smart_list.hpp 	if ( i.ptr_.derefable() )</span>
<span class='curline'><a href='../S/858.html#L471'>ptr_</a>              471 src/utils/smart_list.hpp 		splice(pos.ptr_, *i.ptr_, *i.ptr_);</span>
<span class='curline'><a href='../S/858.html#L483'>ptr_</a>              483 src/utils/smart_list.hpp 	splice(pos.ptr_, *(f.ptr_), *(l.ptr_-&gt;prev));</span>
<span class='curline'><a href='../S/858.html#L783'>ptr_</a>              783 src/utils/smart_list.hpp 	node_t * old_ptr = ptr_;</span>
<span class='curline'><a href='../S/858.html#L801'>ptr_</a>              801 src/utils/smart_list.hpp 	while ( derefable()  &amp;&amp;  smart_list&lt;Data&gt;::flagged(*ptr_) )</span>
<span class='curline'><a href='../S/858.html#L811'>ptr_</a>              811 src/utils/smart_list.hpp 		ptr_-&gt;ref_count += 2;</span>
</pre>
</body>
</html>
