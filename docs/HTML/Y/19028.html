<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>str_</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1141.html#L43'>str_</a>               43 src/font/text_surface.cpp 	char		*c_str = const_cast&lt;char *&gt;(str_.c_str());	// fribidi forgot const...</span>
<span class='curline'><a href='../S/1141.html#L44'>str_</a>               44 src/font/text_surface.cpp 	FriBidiStrIndex	len = str_.length();</span>
<span class='curline'><a href='../S/1141.html#L65'>str_</a>               65 src/font/text_surface.cpp 	str_ = std::string(utf8str);</span>
<span class='curline'><a href='../S/1141.html#L80'>str_</a>               80 src/font/text_surface.cpp 	, str_(str)</span>
<span class='curline'><a href='../S/1141.html#L101'>str_</a>              101 src/font/text_surface.cpp 	str_(),</span>
<span class='curline'><a href='../S/1141.html#L116'>str_</a>              116 src/font/text_surface.cpp 	str_ = str;</span>
<span class='curline'><a href='../S/1141.html#L126'>str_</a>              126 src/font/text_surface.cpp 	for(const char c : str_) {</span>
<span class='curline'><a href='../S/1141.html#L155'>str_</a>              155 src/font/text_surface.cpp 			chunks_ = sdl_ttf::split_text(str_);</span>
<span class='curline'><a href='../S/1141.html#L165'>str_</a>              165 src/font/text_surface.cpp 			chunks_ = sdl_ttf::split_text(str_);</span>
<span class='curline'><a href='../S/1141.html#L197'>str_</a>              197 src/font/text_surface.cpp 		&amp;&amp; color_ == t.color_ &amp;&amp; style_ == t.style_ &amp;&amp; str_ == t.str_;</span>
<span class='curline'><a href='../S/1133.html#L55'>str_</a>               55 src/font/text_surface.hpp 	std::string str_;</span>
<span class='curline'><a href='../S/782.html#L40'>str_</a>               40 src/formula/debugger.cpp 	: arg_number_(arg_number), counter_(counter), level_(level), name_(name), str_(str), value_(value), evaluated_(evaluated)</span>
<span class='curline'><a href='../S/782.html#L93'>str_</a>               93 src/formula/debugger.cpp 	return str_;</span>
<span class='curline'><a href='../S/781.html#L52'>str_</a>               52 src/formula/debugger.hpp 	std::string str_;</span>
<span class='curline'><a href='../S/771.html#L70'>str_</a>               70 src/formula/formula.cpp 	, str_(text)</span>
<span class='curline'><a href='../S/771.html#L211'>str_</a>              211 src/formula/formula.cpp 	, str_()</span>
<span class='curline'><a href='../S/771.html#L926'>str_</a>              926 src/formula/formula.cpp 		: str_()</span>
<span class='curline'><a href='../S/771.html#L978'>str_</a>              978 src/formula/formula.cpp 		str_ = variant(str);</span>
<span class='curline'><a href='../S/771.html#L983'>str_</a>              983 src/formula/formula.cpp 		std::string res = str_.as_string();</span>
<span class='curline'><a href='../S/771.html#L1018'>str_</a>             1018 src/formula/formula.cpp 			return str_;</span>
<span class='curline'><a href='../S/771.html#L1021'>str_</a>             1021 src/formula/formula.cpp 		std::string res = str_.as_string();</span>
<span class='curline'><a href='../S/771.html#L1041'>str_</a>             1041 src/formula/formula.cpp 	variant str_;</span>
<span class='curline'><a href='../S/783.html#L72'>str_</a>               72 src/formula/formula.hpp 	const std::string&amp; str() const { return str_; }</span>
<span class='curline'><a href='../S/783.html#L81'>str_</a>               81 src/formula/formula.hpp 	std::string str_;</span>
<span class='curline'><a href='../S/843.html#L240'>str_</a>              240 src/log.cpp    	str_ = str;</span>
<span class='curline'><a href='../S/843.html#L242'>str_</a>              242 src/log.cpp    	(*output_) &lt;&lt; "{ BEGIN: " &lt;&lt; str_ &lt;&lt; "\n";</span>
<span class='curline'><a href='../S/843.html#L252'>str_</a>              252 src/log.cpp    	(*output_) &lt;&lt; "} END: " &lt;&lt; str_ &lt;&lt; " (took " &lt;&lt; ticks &lt;&lt; "ms)\n";</span>
<span class='curline'><a href='../S/659.html#L149'>str_</a>              149 src/log.hpp    	std::string str_;</span>
<span class='curline'><a href='../S/757.html#L35'>str_</a>               35 src/map_command_handler.hpp 		str_(""),</span>
<span class='curline'><a href='../S/757.html#L42'>str_</a>               42 src/map_command_handler.hpp 		str_(str),</span>
<span class='curline'><a href='../S/757.html#L50'>str_</a>               50 src/map_command_handler.hpp 		str_ = str;</span>
<span class='curline'><a href='../S/757.html#L58'>str_</a>               58 src/map_command_handler.hpp 		return str_;</span>
<span class='curline'><a href='../S/757.html#L64'>str_</a>               64 src/map_command_handler.hpp 			return std::string(str_, args[n], str_.find(' ', args[n]) - args[n]);</span>
<span class='curline'><a href='../S/757.html#L74'>str_</a>               74 src/map_command_handler.hpp 			std::string data(str_, args[n]);</span>
<span class='curline'><a href='../S/757.html#L92'>str_</a>               92 src/map_command_handler.hpp 			size_t first_space = str_.find_first_of(' ', args.back());</span>
<span class='curline'><a href='../S/757.html#L93'>str_</a>               93 src/map_command_handler.hpp 			size_t next_arg_begin = str_.find_first_not_of(' ', first_space);</span>
<span class='curline'><a href='../S/757.html#L102'>str_</a>              102 src/map_command_handler.hpp 	std::string str_;</span>
<span class='curline'><a href='../S/151.html#L36'>str_</a>               36 src/server/simple_wml.hpp 	string_span() : str_(nullptr), size_(0)</span>
<span class='curline'><a href='../S/151.html#L38'>str_</a>               38 src/server/simple_wml.hpp 	string_span(const char* str, int size) : str_(str), size_(size)</span>
<span class='curline'><a href='../S/151.html#L40'>str_</a>               40 src/server/simple_wml.hpp 	string_span(const char* str) : str_(str), size_(strlen(str))</span>
<span class='curline'><a href='../S/151.html#L42'>str_</a>               42 src/server/simple_wml.hpp 	string_span(const char* begin, const char* end) : str_(begin), size_(end - begin)</span>
<span class='curline'><a href='../S/151.html#L50'>str_</a>               50 src/server/simple_wml.hpp 		const char* i1 = str_;</span>
<span class='curline'><a href='../S/151.html#L51'>str_</a>               51 src/server/simple_wml.hpp 		const char* i2 = str_ + size_;</span>
<span class='curline'><a href='../S/151.html#L63'>str_</a>               63 src/server/simple_wml.hpp 		return size_ == o.size() &amp;&amp; memcmp(str_, o.data(), size_) == 0;</span>
<span class='curline'><a href='../S/151.html#L69'>str_</a>               69 src/server/simple_wml.hpp 		return size_ == o.size_ &amp;&amp; memcmp(str_, o.str_, size_) == 0;</span>
<span class='curline'><a href='../S/151.html#L77'>str_</a>               77 src/server/simple_wml.hpp 			if(str_[n] != o.str_[n]) {</span>
<span class='curline'><a href='../S/151.html#L78'>str_</a>               78 src/server/simple_wml.hpp 				if(str_[n] &lt; o.str_[n]) {</span>
<span class='curline'><a href='../S/151.html#L89'>str_</a>               89 src/server/simple_wml.hpp 	const char* begin() const { return str_; }</span>
<span class='curline'><a href='../S/151.html#L90'>str_</a>               90 src/server/simple_wml.hpp 	const char* end() const { return str_ + size_; }</span>
<span class='curline'><a href='../S/151.html#L94'>str_</a>               94 src/server/simple_wml.hpp 	bool is_null() const { return str_ == nullptr; }</span>
<span class='curline'><a href='../S/151.html#L104'>str_</a>              104 src/server/simple_wml.hpp         const char* str_;</span>
</pre>
</body>
</html>
