<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>up</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/250.html#L108'>up</a>                108 src/ai/default/attack.cpp 		unit_ptr up = units.extract(m-&gt;first);</span>
<span class='curline'><a href='../S/250.html#L109'>up</a>                109 src/ai/default/attack.cpp 		up-&gt;set_location(m-&gt;second);</span>
<span class='curline'><a href='../S/250.html#L110'>up</a>                110 src/ai/default/attack.cpp 		units.insert(up);</span>
<span class='curline'><a href='../S/250.html#L113'>up</a>                113 src/ai/default/attack.cpp 		if (up-&gt;can_recruit()) {</span>
<span class='curline'><a href='../S/250.html#L129'>up</a>                129 src/ai/default/attack.cpp 		const readonly_context::unit_stats_cache_t::key_type cache_key = std::make_pair(target, &amp;up-&gt;type());</span>
<span class='curline'><a href='../S/250.html#L134'>up</a>                134 src/ai/default/attack.cpp 				static_cast&lt;int&gt;(up-&gt;attacks().size())) {</span>
<span class='curline'><a href='../S/250.html#L166'>up</a>                166 src/ai/default/attack.cpp 		double cost = up-&gt;cost();</span>
<span class='curline'><a href='../S/250.html#L169'>up</a>                169 src/ai/default/attack.cpp 		cost += (double(up-&gt;experience()) / up-&gt;max_experience())*cost;</span>
<span class='curline'><a href='../S/250.html#L174'>up</a>                174 src/ai/default/attack.cpp 		avg_losses += cost * up-&gt;get_state(unit::STATE_POISONED) /2;</span>
<span class='curline'><a href='../S/250.html#L189'>up</a>                189 src/ai/default/attack.cpp 		if (!up-&gt;advances_to().empty()) {</span>
<span class='curline'><a href='../S/250.html#L190'>up</a>                190 src/ai/default/attack.cpp 			int xp_for_advance = up-&gt;experience_to_advance();</span>
<span class='curline'><a href='../S/250.html#L202'>up</a>                202 src/ai/default/attack.cpp 				avg_losses -= up-&gt;cost() * prob_fought;</span>
<span class='curline'><a href='../S/250.html#L205'>up</a>                205 src/ai/default/attack.cpp 				avg_losses -= up-&gt;cost() * prob_killed;</span>
<span class='curline'><a href='../S/250.html#L212'>up</a>                212 src/ai/default/attack.cpp 				avg_losses -= up-&gt;cost() * 0.25 *</span>
<span class='curline'><a href='../S/250.html#L216'>up</a>                216 src/ai/default/attack.cpp 				avg_losses -= up-&gt;cost() * 0.25 *</span>
<span class='curline'><a href='../S/250.html#L224'>up</a>                224 src/ai/default/attack.cpp 				avg_losses -= prob_killed * up-&gt;cost();</span>
<span class='curline'><a href='../S/250.html#L229'>up</a>                229 src/ai/default/attack.cpp 		avg_damage_taken += (up-&gt;hitpoints() - att.average_hp()) * (1.0 - advance_prob);</span>
<span class='curline'><a href='../S/250.html#L236'>up</a>                236 src/ai/default/attack.cpp 		int fight_xp = up-&gt;level();</span>
<span class='curline'><a href='../S/658.html#L285'>up</a>                285 src/gui/auxiliary/iterator/policy_order.hpp 			up();</span>
<span class='curline'><a href='../S/602.html#L306'>up</a>                306 src/gui/widgets/text_box.cpp 	const std::string str = history_.up(get_value());</span>
<span class='curline'><a href='../S/539.html#L71'>up</a>                 71 src/gui/widgets/text_box.hpp 	std::string up(const std::string&amp; text = "");</span>
<span class='curline'><a href='../S/1214.html#L160'>up</a>                160 src/lua/ldo.cpp   UpVal *up;</span>
<span class='curline'><a href='../S/1214.html#L162'>up</a>                162 src/lua/ldo.cpp   for (up = L-&gt;openupval; up != NULL; up = up-&gt;u.open.next)</span>
<span class='curline'><a href='../S/1214.html#L163'>up</a>                163 src/lua/ldo.cpp     up-&gt;v = (up-&gt;v - oldstack) + L-&gt;stack;</span>
<span class='curline'><a href='../S/1212.html#L47'>up</a>                 47 src/lua/lfunc.h #define upisopen(up)	((up)-&gt;v != &amp;(up)-&gt;u.value)</span>
<span class='curline'><a href='../S/1216.html#L248'>up</a>                248 src/lua/lmathlib.cpp   lua_Integer low, up;</span>
<span class='curline'><a href='../S/1216.html#L257'>up</a>                257 src/lua/lmathlib.cpp       up = luaL_checkinteger(L, 1);</span>
<span class='curline'><a href='../S/1216.html#L262'>up</a>                262 src/lua/lmathlib.cpp       up = luaL_checkinteger(L, 2);</span>
<span class='curline'><a href='../S/1216.html#L268'>up</a>                268 src/lua/lmathlib.cpp   luaL_argcheck(L, low &lt;= up, 1, "interval is empty");</span>
<span class='curline'><a href='../S/1216.html#L269'>up</a>                269 src/lua/lmathlib.cpp   luaL_argcheck(L, low &gt;= 0 || up &lt;= LUA_MAXINTEGER + low, 1,</span>
<span class='curline'><a href='../S/1216.html#L271'>up</a>                271 src/lua/lmathlib.cpp   r *= (double)(up - low) + 1.0;</span>
<span class='curline'><a href='../S/1226.html#L220'>up</a>                220 src/lua/lparser.cpp   Upvaldesc *up = fs-&gt;f-&gt;upvalues;</span>
<span class='curline'><a href='../S/1226.html#L222'>up</a>                222 src/lua/lparser.cpp     if (eqstr(up[i].name, name)) return i;</span>
<span class='curline'><a href='../S/1223.html#L310'>up</a>                310 src/lua/ltablib.cpp static IdxT partition (lua_State *L, IdxT lo, IdxT up) {</span>
<span class='curline'><a href='../S/1223.html#L312'>up</a>                312 src/lua/ltablib.cpp   IdxT j = up - 1;  /* will be decremented before first use */</span>
<span class='curline'><a href='../S/1223.html#L317'>up</a>                317 src/lua/ltablib.cpp       if (i == up - 1)  /* a[i] &lt; P  but a[up - 1] == P  ?? */</span>
<span class='curline'><a href='../S/1223.html#L333'>up</a>                333 src/lua/ltablib.cpp       set2(L, up - 1, i);</span>
<span class='curline'><a href='../S/1223.html#L346'>up</a>                346 src/lua/ltablib.cpp static IdxT choosePivot (IdxT lo, IdxT up, unsigned int rnd) {</span>
<span class='curline'><a href='../S/1223.html#L347'>up</a>                347 src/lua/ltablib.cpp   IdxT r4 = (up - lo) / 4;  /* range/4 */</span>
<span class='curline'><a href='../S/1223.html#L349'>up</a>                349 src/lua/ltablib.cpp   lua_assert(lo + r4 &lt;= p &amp;&amp; p &lt;= up - r4);</span>
<span class='curline'><a href='../S/1223.html#L357'>up</a>                357 src/lua/ltablib.cpp static void auxsort (lua_State *L, IdxT lo, IdxT up,</span>
<span class='curline'><a href='../S/1223.html#L359'>up</a>                359 src/lua/ltablib.cpp   while (lo &lt; up) {  /* loop for tail recursion */</span>
<span class='curline'><a href='../S/1223.html#L364'>up</a>                364 src/lua/ltablib.cpp     lua_geti(L, 1, up);</span>
<span class='curline'><a href='../S/1223.html#L366'>up</a>                366 src/lua/ltablib.cpp       set2(L, lo, up);  /* swap a[lo] - a[up] */</span>
<span class='curline'><a href='../S/1223.html#L369'>up</a>                369 src/lua/ltablib.cpp     if (up - lo == 1)  /* only 2 elements? */</span>
<span class='curline'><a href='../S/1223.html#L371'>up</a>                371 src/lua/ltablib.cpp     if (up - lo &lt; RANLIMIT || rnd == 0)  /* small interval or no randomize? */</span>
<span class='curline'><a href='../S/1223.html#L372'>up</a>                372 src/lua/ltablib.cpp       p = (lo + up)/2;  /* middle element is a good pivot */</span>
<span class='curline'><a href='../S/1223.html#L374'>up</a>                374 src/lua/ltablib.cpp       p = choosePivot(lo, up, rnd);</span>
<span class='curline'><a href='../S/1223.html#L381'>up</a>                381 src/lua/ltablib.cpp       lua_geti(L, 1, up);</span>
<span class='curline'><a href='../S/1223.html#L383'>up</a>                383 src/lua/ltablib.cpp         set2(L, p, up);  /* swap a[up] - a[p] */</span>
<span class='curline'><a href='../S/1223.html#L387'>up</a>                387 src/lua/ltablib.cpp     if (up - lo == 2)  /* only 3 elements? */</span>
<span class='curline'><a href='../S/1223.html#L391'>up</a>                391 src/lua/ltablib.cpp     lua_geti(L, 1, up - 1);  /* push a[up - 1] */</span>
<span class='curline'><a href='../S/1223.html#L392'>up</a>                392 src/lua/ltablib.cpp     set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */</span>
<span class='curline'><a href='../S/1223.html#L393'>up</a>                393 src/lua/ltablib.cpp     p = partition(L, lo, up);</span>
<span class='curline'><a href='../S/1223.html#L395'>up</a>                395 src/lua/ltablib.cpp     if (p - lo &lt; up - p) {  /* lower interval is smaller? */</span>
<span class='curline'><a href='../S/1223.html#L401'>up</a>                401 src/lua/ltablib.cpp       auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */</span>
<span class='curline'><a href='../S/1223.html#L402'>up</a>                402 src/lua/ltablib.cpp       n = up - p;  /* size of smaller interval */</span>
<span class='curline'><a href='../S/1223.html#L403'>up</a>                403 src/lua/ltablib.cpp       up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */</span>
<span class='curline'><a href='../S/1223.html#L405'>up</a>                405 src/lua/ltablib.cpp     if ((up - lo) / 128 &gt; n) /* partition too imbalanced? */</span>
</pre>
</body>
</html>
