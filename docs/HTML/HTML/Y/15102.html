<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>newsize</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1193.html#L462'>newsize</a>           462 src/lua/lauxlib.cpp static void *resizebox (lua_State *L, int idx, size_t newsize) {</span>
<span class='curline'><a href='../S/1193.html#L466'>newsize</a>           466 src/lua/lauxlib.cpp   void *temp = allocf(ud, box-&gt;box, box-&gt;bsize, newsize);</span>
<span class='curline'><a href='../S/1193.html#L467'>newsize</a>           467 src/lua/lauxlib.cpp   if (temp == NULL &amp;&amp; newsize &gt; 0) {  /* allocation error? */</span>
<span class='curline'><a href='../S/1193.html#L472'>newsize</a>           472 src/lua/lauxlib.cpp   box-&gt;bsize = newsize;</span>
<span class='curline'><a href='../S/1193.html#L483'>newsize</a>           483 src/lua/lauxlib.cpp static void *newbox (lua_State *L, size_t newsize) {</span>
<span class='curline'><a href='../S/1193.html#L492'>newsize</a>           492 src/lua/lauxlib.cpp   return resizebox(L, -1, newsize);</span>
<span class='curline'><a href='../S/1193.html#L510'>newsize</a>           510 src/lua/lauxlib.cpp     size_t newsize = B-&gt;size * 2;  /* double buffer size */</span>
<span class='curline'><a href='../S/1193.html#L511'>newsize</a>           511 src/lua/lauxlib.cpp     if (newsize - B-&gt;n &lt; sz)  /* not big enough? */</span>
<span class='curline'><a href='../S/1193.html#L512'>newsize</a>           512 src/lua/lauxlib.cpp       newsize = B-&gt;n + sz;</span>
<span class='curline'><a href='../S/1193.html#L513'>newsize</a>           513 src/lua/lauxlib.cpp     if (newsize &lt; B-&gt;n || newsize - B-&gt;n &lt; sz)</span>
<span class='curline'><a href='../S/1193.html#L517'>newsize</a>           517 src/lua/lauxlib.cpp       newbuff = (char *)resizebox(L, -1, newsize);</span>
<span class='curline'><a href='../S/1193.html#L519'>newsize</a>           519 src/lua/lauxlib.cpp       newbuff = (char *)newbox(L, newsize);</span>
<span class='curline'><a href='../S/1193.html#L523'>newsize</a>           523 src/lua/lauxlib.cpp     B-&gt;size = newsize;</span>
<span class='curline'><a href='../S/1214.html#L177'>newsize</a>           177 src/lua/ldo.cpp void luaD_reallocstack (lua_State *L, int newsize) {</span>
<span class='curline'><a href='../S/1214.html#L180'>newsize</a>           180 src/lua/ldo.cpp   lua_assert(newsize &lt;= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);</span>
<span class='curline'><a href='../S/1214.html#L182'>newsize</a>           182 src/lua/ldo.cpp   luaM_reallocvector(L, L-&gt;stack, L-&gt;stacksize, newsize, TValue);</span>
<span class='curline'><a href='../S/1214.html#L183'>newsize</a>           183 src/lua/ldo.cpp   for (; lim &lt; newsize; lim++)</span>
<span class='curline'><a href='../S/1214.html#L185'>newsize</a>           185 src/lua/ldo.cpp   L-&gt;stacksize = newsize;</span>
<span class='curline'><a href='../S/1214.html#L186'>newsize</a>           186 src/lua/ldo.cpp   L-&gt;stack_last = L-&gt;stack + newsize - EXTRA_STACK;</span>
<span class='curline'><a href='../S/1214.html#L197'>newsize</a>           197 src/lua/ldo.cpp     int newsize = 2 * size;</span>
<span class='curline'><a href='../S/1214.html#L198'>newsize</a>           198 src/lua/ldo.cpp     if (newsize &gt; LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;</span>
<span class='curline'><a href='../S/1214.html#L199'>newsize</a>           199 src/lua/ldo.cpp     if (newsize &lt; needed) newsize = needed;</span>
<span class='curline'><a href='../S/1214.html#L200'>newsize</a>           200 src/lua/ldo.cpp     if (newsize &gt; LUAI_MAXSTACK) {  /* stack overflow? */</span>
<span class='curline'><a href='../S/1214.html#L205'>newsize</a>           205 src/lua/ldo.cpp       luaD_reallocstack(L, newsize);</span>
<span class='curline'><a href='../S/1188.html#L49'>newsize</a>            49 src/lua/ldo.h  LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);</span>
<span class='curline'><a href='../S/1177.html#L60'>newsize</a>            60 src/lua/llex.cpp     size_t newsize;</span>
<span class='curline'><a href='../S/1177.html#L63'>newsize</a>            63 src/lua/llex.cpp     newsize = luaZ_sizebuffer(b) * 2;</span>
<span class='curline'><a href='../S/1177.html#L64'>newsize</a>            64 src/lua/llex.cpp     luaZ_resizebuffer(ls-&gt;L, b, newsize);</span>
<span class='curline'><a href='../S/1174.html#L51'>newsize</a>            51 src/lua/lmem.cpp   int newsize;</span>
<span class='curline'><a href='../S/1174.html#L55'>newsize</a>            55 src/lua/lmem.cpp     newsize = limit;  /* still have at least one free place */</span>
<span class='curline'><a href='../S/1174.html#L58'>newsize</a>            58 src/lua/lmem.cpp     newsize = (*size)*2;</span>
<span class='curline'><a href='../S/1174.html#L59'>newsize</a>            59 src/lua/lmem.cpp     if (newsize &lt; MINSIZEARRAY)</span>
<span class='curline'><a href='../S/1174.html#L60'>newsize</a>            60 src/lua/lmem.cpp       newsize = MINSIZEARRAY;  /* minimum size */</span>
<span class='curline'><a href='../S/1174.html#L62'>newsize</a>            62 src/lua/lmem.cpp   newblock = luaM_reallocv(L, block, *size, newsize, size_elems);</span>
<span class='curline'><a href='../S/1174.html#L63'>newsize</a>            63 src/lua/lmem.cpp   *size = newsize;  /* update only when everything else is OK */</span>
<span class='curline'><a href='../S/1186.html#L71'>newsize</a>            71 src/lua/lstring.cpp void luaS_resize (lua_State *L, int newsize) {</span>
<span class='curline'><a href='../S/1186.html#L74'>newsize</a>            74 src/lua/lstring.cpp   if (newsize &gt; tb-&gt;size) {  /* grow table if needed */</span>
<span class='curline'><a href='../S/1186.html#L75'>newsize</a>            75 src/lua/lstring.cpp     luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span>
<span class='curline'><a href='../S/1186.html#L76'>newsize</a>            76 src/lua/lstring.cpp     for (i = tb-&gt;size; i &lt; newsize; i++)</span>
<span class='curline'><a href='../S/1186.html#L84'>newsize</a>            84 src/lua/lstring.cpp       unsigned int h = lmod(p-&gt;hash, newsize);  /* new position */</span>
<span class='curline'><a href='../S/1186.html#L90'>newsize</a>            90 src/lua/lstring.cpp   if (newsize &lt; tb-&gt;size) {  /* shrink table if needed */</span>
<span class='curline'><a href='../S/1186.html#L92'>newsize</a>            92 src/lua/lstring.cpp     lua_assert(tb-&gt;hash[newsize] == NULL &amp;&amp; tb-&gt;hash[tb-&gt;size - 1] == NULL);</span>
<span class='curline'><a href='../S/1186.html#L93'>newsize</a>            93 src/lua/lstring.cpp     luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span>
<span class='curline'><a href='../S/1186.html#L95'>newsize</a>            95 src/lua/lstring.cpp   tb-&gt;size = newsize;</span>
<span class='curline'><a href='../S/1219.html#L39'>newsize</a>            39 src/lua/lstring.h LUAI_FUNC void luaS_resize (lua_State *L, int newsize);</span>
</pre>
</body>
</html>
