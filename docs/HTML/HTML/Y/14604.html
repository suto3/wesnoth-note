<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>ms</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/4086.html#L803'>ms</a>                803 data/tools/unit_tree/html_output.py         ms = None</span>
<span class='curline'><a href='../S/4086.html#L820'>ms</a>                820 data/tools/unit_tree/html_output.py                         ms = None</span>
<span class='curline'><a href='../S/4086.html#L826'>ms</a>                826 data/tools/unit_tree/html_output.py                                     ms = era.faction_lookup[fid]</span>
<span class='curline'><a href='../S/4086.html#L857'>ms</a>                857 data/tools/unit_tree/html_output.py                         if ms:</span>
<span class='curline'><a href='../S/4086.html#L858'>ms</a>                858 data/tools/unit_tree/html_output.py                             if un.id in ms.units:</span>
<span class='curline'><a href='../S/4086.html#L860'>ms</a>                860 data/tools/unit_tree/html_output.py                             if un.id in ms.is_leader:</span>
<span class='curline'><a href='../S/1225.html#L229'>ms</a>                229 src/lua/lstrlib.cpp static const char *match (MatchState *ms, const char *s, const char *p);</span>
<span class='curline'><a href='../S/1225.html#L242'>ms</a>                242 src/lua/lstrlib.cpp static int check_capture (MatchState *ms, int l) {</span>
<span class='curline'><a href='../S/1225.html#L244'>ms</a>                244 src/lua/lstrlib.cpp   if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)</span>
<span class='curline'><a href='../S/1225.html#L245'>ms</a>                245 src/lua/lstrlib.cpp     return luaL_error(ms-&gt;L, "invalid capture index %%%d", l + 1);</span>
<span class='curline'><a href='../S/1225.html#L250'>ms</a>                250 src/lua/lstrlib.cpp static int capture_to_close (MatchState *ms) {</span>
<span class='curline'><a href='../S/1225.html#L251'>ms</a>                251 src/lua/lstrlib.cpp   int level = ms-&gt;level;</span>
<span class='curline'><a href='../S/1225.html#L253'>ms</a>                253 src/lua/lstrlib.cpp     if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;</span>
<span class='curline'><a href='../S/1225.html#L254'>ms</a>                254 src/lua/lstrlib.cpp   return luaL_error(ms-&gt;L, "invalid pattern capture");</span>
<span class='curline'><a href='../S/1225.html#L258'>ms</a>                258 src/lua/lstrlib.cpp static const char *classend (MatchState *ms, const char *p) {</span>
<span class='curline'><a href='../S/1225.html#L261'>ms</a>                261 src/lua/lstrlib.cpp       if (p == ms-&gt;p_end)</span>
<span class='curline'><a href='../S/1225.html#L262'>ms</a>                262 src/lua/lstrlib.cpp         luaL_error(ms-&gt;L, "malformed pattern (ends with '%%')");</span>
<span class='curline'><a href='../S/1225.html#L268'>ms</a>                268 src/lua/lstrlib.cpp         if (p == ms-&gt;p_end)</span>
<span class='curline'><a href='../S/1225.html#L269'>ms</a>                269 src/lua/lstrlib.cpp           luaL_error(ms-&gt;L, "malformed pattern (missing ']')");</span>
<span class='curline'><a href='../S/1225.html#L270'>ms</a>                270 src/lua/lstrlib.cpp         if (*(p++) == L_ESC &amp;&amp; p &lt; ms-&gt;p_end)</span>
<span class='curline'><a href='../S/1225.html#L325'>ms</a>                325 src/lua/lstrlib.cpp static int singlematch (MatchState *ms, const char *s, const char *p,</span>
<span class='curline'><a href='../S/1225.html#L327'>ms</a>                327 src/lua/lstrlib.cpp   if (s &gt;= ms-&gt;src_end)</span>
<span class='curline'><a href='../S/1225.html#L341'>ms</a>                341 src/lua/lstrlib.cpp static const char *matchbalance (MatchState *ms, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L343'>ms</a>                343 src/lua/lstrlib.cpp   if (p &gt;= ms-&gt;p_end - 1)</span>
<span class='curline'><a href='../S/1225.html#L344'>ms</a>                344 src/lua/lstrlib.cpp     luaL_error(ms-&gt;L, "malformed pattern (missing arguments to '%%b')");</span>
<span class='curline'><a href='../S/1225.html#L350'>ms</a>                350 src/lua/lstrlib.cpp     while (++s &lt; ms-&gt;src_end) {</span>
<span class='curline'><a href='../S/1225.html#L361'>ms</a>                361 src/lua/lstrlib.cpp static const char *max_expand (MatchState *ms, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L364'>ms</a>                364 src/lua/lstrlib.cpp   while (singlematch(ms, s + i, p, ep))</span>
<span class='curline'><a href='../S/1225.html#L368'>ms</a>                368 src/lua/lstrlib.cpp     const char *res = match(ms, (s+i), ep+1);</span>
<span class='curline'><a href='../S/1225.html#L376'>ms</a>                376 src/lua/lstrlib.cpp static const char *min_expand (MatchState *ms, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L379'>ms</a>                379 src/lua/lstrlib.cpp     const char *res = match(ms, s, ep+1);</span>
<span class='curline'><a href='../S/1225.html#L382'>ms</a>                382 src/lua/lstrlib.cpp     else if (singlematch(ms, s, p, ep))</span>
<span class='curline'><a href='../S/1225.html#L389'>ms</a>                389 src/lua/lstrlib.cpp static const char *start_capture (MatchState *ms, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L392'>ms</a>                392 src/lua/lstrlib.cpp   int level = ms-&gt;level;</span>
<span class='curline'><a href='../S/1225.html#L393'>ms</a>                393 src/lua/lstrlib.cpp   if (level &gt;= LUA_MAXCAPTURES) luaL_error(ms-&gt;L, "too many captures");</span>
<span class='curline'><a href='../S/1225.html#L394'>ms</a>                394 src/lua/lstrlib.cpp   ms-&gt;capture[level].init = s;</span>
<span class='curline'><a href='../S/1225.html#L395'>ms</a>                395 src/lua/lstrlib.cpp   ms-&gt;capture[level].len = what;</span>
<span class='curline'><a href='../S/1225.html#L396'>ms</a>                396 src/lua/lstrlib.cpp   ms-&gt;level = level+1;</span>
<span class='curline'><a href='../S/1225.html#L397'>ms</a>                397 src/lua/lstrlib.cpp   if ((res=match(ms, s, p)) == NULL)  /* match failed? */</span>
<span class='curline'><a href='../S/1225.html#L398'>ms</a>                398 src/lua/lstrlib.cpp     ms-&gt;level--;  /* undo capture */</span>
<span class='curline'><a href='../S/1225.html#L403'>ms</a>                403 src/lua/lstrlib.cpp static const char *end_capture (MatchState *ms, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L405'>ms</a>                405 src/lua/lstrlib.cpp   int l = capture_to_close(ms);</span>
<span class='curline'><a href='../S/1225.html#L407'>ms</a>                407 src/lua/lstrlib.cpp   ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  /* close capture */</span>
<span class='curline'><a href='../S/1225.html#L408'>ms</a>                408 src/lua/lstrlib.cpp   if ((res = match(ms, s, p)) == NULL)  /* match failed? */</span>
<span class='curline'><a href='../S/1225.html#L409'>ms</a>                409 src/lua/lstrlib.cpp     ms-&gt;capture[l].len = CAP_UNFINISHED;  /* undo capture */</span>
<span class='curline'><a href='../S/1225.html#L414'>ms</a>                414 src/lua/lstrlib.cpp static const char *match_capture (MatchState *ms, const char *s, int l) {</span>
<span class='curline'><a href='../S/1225.html#L416'>ms</a>                416 src/lua/lstrlib.cpp   l = check_capture(ms, l);</span>
<span class='curline'><a href='../S/1225.html#L417'>ms</a>                417 src/lua/lstrlib.cpp   len = ms-&gt;capture[l].len;</span>
<span class='curline'><a href='../S/1225.html#L418'>ms</a>                418 src/lua/lstrlib.cpp   if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;</span>
<span class='curline'><a href='../S/1225.html#L419'>ms</a>                419 src/lua/lstrlib.cpp       memcmp(ms-&gt;capture[l].init, s, len) == 0)</span>
<span class='curline'><a href='../S/1225.html#L425'>ms</a>                425 src/lua/lstrlib.cpp static const char *match (MatchState *ms, const char *s, const char *p) {</span>
<span class='curline'><a href='../S/1225.html#L426'>ms</a>                426 src/lua/lstrlib.cpp   if (ms-&gt;matchdepth-- == 0)</span>
<span class='curline'><a href='../S/1225.html#L427'>ms</a>                427 src/lua/lstrlib.cpp     luaL_error(ms-&gt;L, "pattern too complex");</span>
<span class='curline'><a href='../S/1225.html#L429'>ms</a>                429 src/lua/lstrlib.cpp   if (p != ms-&gt;p_end) {  /* end of pattern? */</span>
<span class='curline'><a href='../S/1225.html#L433'>ms</a>                433 src/lua/lstrlib.cpp           s = start_capture(ms, s, p + 2, CAP_POSITION);</span>
<span class='curline'><a href='../S/1225.html#L435'>ms</a>                435 src/lua/lstrlib.cpp           s = start_capture(ms, s, p + 1, CAP_UNFINISHED);</span>
<span class='curline'><a href='../S/1225.html#L439'>ms</a>                439 src/lua/lstrlib.cpp         s = end_capture(ms, s, p + 1);</span>
<span class='curline'><a href='../S/1225.html#L443'>ms</a>                443 src/lua/lstrlib.cpp         if ((p + 1) != ms-&gt;p_end)  /* is the '$' the last char in pattern? */</span>
<span class='curline'><a href='../S/1225.html#L445'>ms</a>                445 src/lua/lstrlib.cpp         s = (s == ms-&gt;src_end) ? s : NULL;  /* check end of string */</span>
<span class='curline'><a href='../S/1225.html#L451'>ms</a>                451 src/lua/lstrlib.cpp             s = matchbalance(ms, s, p + 2);</span>
<span class='curline'><a href='../S/1225.html#L461'>ms</a>                461 src/lua/lstrlib.cpp               luaL_error(ms-&gt;L, "missing '[' after '%%f' in pattern");</span>
<span class='curline'><a href='../S/1225.html#L462'>ms</a>                462 src/lua/lstrlib.cpp             ep = classend(ms, p);  /* points to what is next */</span>
<span class='curline'><a href='../S/1225.html#L463'>ms</a>                463 src/lua/lstrlib.cpp             previous = (s == ms-&gt;src_init) ? '\0' : *(s - 1);</span>
<span class='curline'><a href='../S/1225.html#L474'>ms</a>                474 src/lua/lstrlib.cpp             s = match_capture(ms, s, uchar(*(p + 1)));</span>
<span class='curline'><a href='../S/1225.html#L485'>ms</a>                485 src/lua/lstrlib.cpp         const char *ep = classend(ms, p);  /* points to optional suffix */</span>
<span class='curline'><a href='../S/1225.html#L487'>ms</a>                487 src/lua/lstrlib.cpp         if (!singlematch(ms, s, p, ep)) {</span>
<span class='curline'><a href='../S/1225.html#L498'>ms</a>                498 src/lua/lstrlib.cpp               if ((res = match(ms, s + 1, ep + 1)) != NULL)</span>
<span class='curline'><a href='../S/1225.html#L509'>ms</a>                509 src/lua/lstrlib.cpp               s = max_expand(ms, s, p, ep);</span>
<span class='curline'><a href='../S/1225.html#L512'>ms</a>                512 src/lua/lstrlib.cpp               s = min_expand(ms, s, p, ep);</span>
<span class='curline'><a href='../S/1225.html#L522'>ms</a>                522 src/lua/lstrlib.cpp   ms-&gt;matchdepth++;</span>
<span class='curline'><a href='../S/1225.html#L550'>ms</a>                550 src/lua/lstrlib.cpp static void push_onecapture (MatchState *ms, int i, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L552'>ms</a>                552 src/lua/lstrlib.cpp   if (i &gt;= ms-&gt;level) {</span>
<span class='curline'><a href='../S/1225.html#L554'>ms</a>                554 src/lua/lstrlib.cpp       lua_pushlstring(ms-&gt;L, s, e - s);  /* add whole match */</span>
<span class='curline'><a href='../S/1225.html#L556'>ms</a>                556 src/lua/lstrlib.cpp       luaL_error(ms-&gt;L, "invalid capture index %%%d", i + 1);</span>
<span class='curline'><a href='../S/1225.html#L559'>ms</a>                559 src/lua/lstrlib.cpp     ptrdiff_t l = ms-&gt;capture[i].len;</span>
<span class='curline'><a href='../S/1225.html#L560'>ms</a>                560 src/lua/lstrlib.cpp     if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, "unfinished capture");</span>
<span class='curline'><a href='../S/1225.html#L562'>ms</a>                562 src/lua/lstrlib.cpp       lua_pushinteger(ms-&gt;L, (ms-&gt;capture[i].init - ms-&gt;src_init) + 1);</span>
<span class='curline'><a href='../S/1225.html#L564'>ms</a>                564 src/lua/lstrlib.cpp       lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);</span>
<span class='curline'><a href='../S/1225.html#L569'>ms</a>                569 src/lua/lstrlib.cpp static int push_captures (MatchState *ms, const char *s, const char *e) {</span>
<span class='curline'><a href='../S/1225.html#L571'>ms</a>                571 src/lua/lstrlib.cpp   int nlevels = (ms-&gt;level == 0 &amp;&amp; s) ? 1 : ms-&gt;level;</span>
<span class='curline'><a href='../S/1225.html#L572'>ms</a>                572 src/lua/lstrlib.cpp   luaL_checkstack(ms-&gt;L, nlevels, "too many captures");</span>
<span class='curline'><a href='../S/1225.html#L574'>ms</a>                574 src/lua/lstrlib.cpp     push_onecapture(ms, i, s, e);</span>
<span class='curline'><a href='../S/1225.html#L591'>ms</a>                591 src/lua/lstrlib.cpp static void prepstate (MatchState *ms, lua_State *L,</span>
<span class='curline'><a href='../S/1225.html#L593'>ms</a>                593 src/lua/lstrlib.cpp   ms-&gt;L = L;</span>
<span class='curline'><a href='../S/1225.html#L594'>ms</a>                594 src/lua/lstrlib.cpp   ms-&gt;matchdepth = MAXCCALLS;</span>
<span class='curline'><a href='../S/1225.html#L595'>ms</a>                595 src/lua/lstrlib.cpp   ms-&gt;src_init = s;</span>
<span class='curline'><a href='../S/1225.html#L596'>ms</a>                596 src/lua/lstrlib.cpp   ms-&gt;src_end = s + ls;</span>
<span class='curline'><a href='../S/1225.html#L597'>ms</a>                597 src/lua/lstrlib.cpp   ms-&gt;p_end = p + lp;</span>
<span class='curline'><a href='../S/1225.html#L601'>ms</a>                601 src/lua/lstrlib.cpp static void reprepstate (MatchState *ms) {</span>
<span class='curline'><a href='../S/1225.html#L602'>ms</a>                602 src/lua/lstrlib.cpp   ms-&gt;level = 0;</span>
<span class='curline'><a href='../S/1225.html#L603'>ms</a>                603 src/lua/lstrlib.cpp   lua_assert(ms-&gt;matchdepth == MAXCCALLS);</span>
<span class='curline'><a href='../S/1225.html#L628'>ms</a>                628 src/lua/lstrlib.cpp     MatchState ms;</span>
<span class='curline'><a href='../S/1225.html#L634'>ms</a>                634 src/lua/lstrlib.cpp     prepstate(&amp;ms, L, s, ls, p, lp);</span>
<span class='curline'><a href='../S/1225.html#L637'>ms</a>                637 src/lua/lstrlib.cpp       reprepstate(&amp;ms);</span>
<span class='curline'><a href='../S/1225.html#L638'>ms</a>                638 src/lua/lstrlib.cpp       if ((res=match(&amp;ms, s1, p)) != NULL) {</span>
<span class='curline'><a href='../S/1225.html#L642'>ms</a>                642 src/lua/lstrlib.cpp           return push_captures(&amp;ms, NULL, 0) + 2;</span>
<span class='curline'><a href='../S/1225.html#L645'>ms</a>                645 src/lua/lstrlib.cpp           return push_captures(&amp;ms, s1, res);</span>
<span class='curline'><a href='../S/1225.html#L647'>ms</a>                647 src/lua/lstrlib.cpp     } while (s1++ &lt; ms.src_end &amp;&amp; !anchor);</span>
<span class='curline'><a href='../S/1225.html#L669'>ms</a>                669 src/lua/lstrlib.cpp   MatchState ms;  /* match state */</span>
<span class='curline'><a href='../S/1225.html#L676'>ms</a>                676 src/lua/lstrlib.cpp   gm-&gt;ms.L = L;</span>
<span class='curline'><a href='../S/1225.html#L677'>ms</a>                677 src/lua/lstrlib.cpp   for (src = gm-&gt;src; src &lt;= gm-&gt;ms.src_end; src++) {</span>
<span class='curline'><a href='../S/1225.html#L679'>ms</a>                679 src/lua/lstrlib.cpp     reprepstate(&amp;gm-&gt;ms);</span>
<span class='curline'><a href='../S/1225.html#L680'>ms</a>                680 src/lua/lstrlib.cpp     if ((e = match(&amp;gm-&gt;ms, src, gm-&gt;p)) != NULL &amp;&amp; e != gm-&gt;lastmatch) {</span>
<span class='curline'><a href='../S/1225.html#L682'>ms</a>                682 src/lua/lstrlib.cpp       return push_captures(&amp;gm-&gt;ms, src, e);</span>
<span class='curline'><a href='../S/1225.html#L696'>ms</a>                696 src/lua/lstrlib.cpp   prepstate(&amp;gm-&gt;ms, L, s, ls, p, lp);</span>
<span class='curline'><a href='../S/1225.html#L703'>ms</a>                703 src/lua/lstrlib.cpp static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L706'>ms</a>                706 src/lua/lstrlib.cpp   lua_State *L = ms-&gt;L;</span>
<span class='curline'><a href='../S/1225.html#L721'>ms</a>                721 src/lua/lstrlib.cpp         push_onecapture(ms, news[i] - '1', s, e);</span>
<span class='curline'><a href='../S/1225.html#L731'>ms</a>                731 src/lua/lstrlib.cpp static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,</span>
<span class='curline'><a href='../S/1225.html#L733'>ms</a>                733 src/lua/lstrlib.cpp   lua_State *L = ms-&gt;L;</span>
<span class='curline'><a href='../S/1225.html#L738'>ms</a>                738 src/lua/lstrlib.cpp       n = push_captures(ms, s, e);</span>
<span class='curline'><a href='../S/1225.html#L743'>ms</a>                743 src/lua/lstrlib.cpp       push_onecapture(ms, 0, s, e);</span>
<span class='curline'><a href='../S/1225.html#L748'>ms</a>                748 src/lua/lstrlib.cpp       add_s(ms, b, s, e);</span>
<span class='curline'><a href='../S/1225.html#L771'>ms</a>                771 src/lua/lstrlib.cpp   MatchState ms;</span>
<span class='curline'><a href='../S/1225.html#L780'>ms</a>                780 src/lua/lstrlib.cpp   prepstate(&amp;ms, L, src, srcl, p, lp);</span>
<span class='curline'><a href='../S/1225.html#L783'>ms</a>                783 src/lua/lstrlib.cpp     reprepstate(&amp;ms);  /* (re)prepare state for new match */</span>
<span class='curline'><a href='../S/1225.html#L784'>ms</a>                784 src/lua/lstrlib.cpp     if ((e = match(&amp;ms, src, p)) != NULL &amp;&amp; e != lastmatch) {  /* match? */</span>
<span class='curline'><a href='../S/1225.html#L786'>ms</a>                786 src/lua/lstrlib.cpp       add_value(&amp;ms, &amp;b, src, e, tr);  /* add replacement to buffer */</span>
<span class='curline'><a href='../S/1225.html#L789'>ms</a>                789 src/lua/lstrlib.cpp     else if (src &lt; ms.src_end)  /* otherwise, skip one character */</span>
<span class='curline'><a href='../S/1225.html#L794'>ms</a>                794 src/lua/lstrlib.cpp   luaL_addlstring(&amp;b, src, ms.src_end-src);</span>
</pre>
</body>
</html>
