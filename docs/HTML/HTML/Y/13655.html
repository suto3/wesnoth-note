<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>ls</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/680.html#L626'>ls</a>                626 src/image.cpp  	light_string ls;</span>
<span class='curline'><a href='../S/680.html#L627'>ls</a>                627 src/image.cpp  	ls.reserve(4);</span>
<span class='curline'><a href='../S/680.html#L628'>ls</a>                628 src/image.cpp  	ls.push_back(op);</span>
<span class='curline'><a href='../S/680.html#L629'>ls</a>                629 src/image.cpp  	ls.push_back(col_to_uchar(r));</span>
<span class='curline'><a href='../S/680.html#L630'>ls</a>                630 src/image.cpp  	ls.push_back(col_to_uchar(g));</span>
<span class='curline'><a href='../S/680.html#L631'>ls</a>                631 src/image.cpp  	ls.push_back(col_to_uchar(b));</span>
<span class='curline'><a href='../S/680.html#L633'>ls</a>                633 src/image.cpp  	return ls;</span>
<span class='curline'><a href='../S/680.html#L636'>ls</a>                636 src/image.cpp  static surface apply_light(surface surf, const light_string&amp; ls)</span>
<span class='curline'><a href='../S/680.html#L639'>ls</a>                639 src/image.cpp  	if(ls.size() == 4) {</span>
<span class='curline'><a href='../S/680.html#L642'>ls</a>                642 src/image.cpp  		int m = ls[0] == -1 ? 2 : 1;</span>
<span class='curline'><a href='../S/680.html#L643'>ls</a>                643 src/image.cpp  		return adjust_surface_color(surf, ls[1] * m, ls[2] * m, ls[3] * m);</span>
<span class='curline'><a href='../S/680.html#L648'>ls</a>                648 src/image.cpp  	auto i = lightmaps_.find(ls);</span>
<span class='curline'><a href='../S/680.html#L665'>ls</a>                665 src/image.cpp  		for(size_t c = 0; c + 3 &lt; ls.size(); c += 4) {</span>
<span class='curline'><a href='../S/680.html#L666'>ls</a>                666 src/image.cpp  			light_string sls = ls.substr(c, 4);</span>
<span class='curline'><a href='../S/680.html#L683'>ls</a>                683 src/image.cpp  		lightmaps_[ls] = lightmap;</span>
<span class='curline'><a href='../S/680.html#L1010'>ls</a>               1010 src/image.cpp  surface get_lighted_image(const image::locator&amp; i_locator, const light_string&amp; ls, TYPE type)</span>
<span class='curline'><a href='../S/680.html#L1035'>ls</a>               1035 src/image.cpp  		auto lvi = lvar.find(ls);</span>
<span class='curline'><a href='../S/680.html#L1045'>ls</a>               1045 src/image.cpp  		res = apply_light(res, ls);</span>
<span class='curline'><a href='../S/680.html#L1049'>ls</a>               1049 src/image.cpp  		res = get_lighted_image(i_locator, ls, HEXED);</span>
<span class='curline'><a href='../S/680.html#L1057'>ls</a>               1057 src/image.cpp  	i_locator.access_in_cache(*imap)[ls] = res;</span>
<span class='curline'><a href='../S/756.html#L197'>ls</a>                197 src/image.hpp  	surface get_lighted_image(const image::locator&amp; i_locator, const light_string&amp; ls, TYPE type);</span>
<span class='curline'><a href='../S/1193.html#L746'>ls</a>                746 src/lua/lauxlib.cpp   LoadS *ls = (LoadS *)ud;</span>
<span class='curline'><a href='../S/1193.html#L748'>ls</a>                748 src/lua/lauxlib.cpp   if (ls-&gt;size == 0) return NULL;</span>
<span class='curline'><a href='../S/1193.html#L749'>ls</a>                749 src/lua/lauxlib.cpp   *size = ls-&gt;size;</span>
<span class='curline'><a href='../S/1193.html#L750'>ls</a>                750 src/lua/lauxlib.cpp   ls-&gt;size = 0;</span>
<span class='curline'><a href='../S/1193.html#L751'>ls</a>                751 src/lua/lauxlib.cpp   return ls-&gt;s;</span>
<span class='curline'><a href='../S/1193.html#L757'>ls</a>                757 src/lua/lauxlib.cpp   LoadS ls;</span>
<span class='curline'><a href='../S/1193.html#L758'>ls</a>                758 src/lua/lauxlib.cpp   ls.s = buff;</span>
<span class='curline'><a href='../S/1193.html#L759'>ls</a>                759 src/lua/lauxlib.cpp   ls.size = size;</span>
<span class='curline'><a href='../S/1193.html#L760'>ls</a>                760 src/lua/lauxlib.cpp   return lua_load(L, getS, &amp;ls, name, mode);</span>
<span class='curline'><a href='../S/1185.html#L108'>ls</a>                108 src/lua/lcode.cpp     luaX_syntaxerror(fs-&gt;ls, "control structure too long");</span>
<span class='curline'><a href='../S/1185.html#L297'>ls</a>                297 src/lua/lcode.cpp   luaM_growvector(fs-&gt;ls-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,</span>
<span class='curline'><a href='../S/1185.html#L301'>ls</a>                301 src/lua/lcode.cpp   luaM_growvector(fs-&gt;ls-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,</span>
<span class='curline'><a href='../S/1185.html#L303'>ls</a>                303 src/lua/lcode.cpp   f-&gt;lineinfo[fs-&gt;pc] = fs-&gt;ls-&gt;lastline;</span>
<span class='curline'><a href='../S/1185.html#L365'>ls</a>                365 src/lua/lcode.cpp       luaX_syntaxerror(fs-&gt;ls,</span>
<span class='curline'><a href='../S/1185.html#L429'>ls</a>                429 src/lua/lcode.cpp   lua_State *L = fs-&gt;ls-&gt;L;</span>
<span class='curline'><a href='../S/1185.html#L431'>ls</a>                431 src/lua/lcode.cpp   TValue *idx = luaH_set(L, fs-&gt;ls-&gt;h, key);  /* index scanner table */</span>
<span class='curline'><a href='../S/1185.html#L460'>ls</a>                460 src/lua/lcode.cpp   setsvalue(fs-&gt;ls-&gt;L, &amp;o, s);</span>
<span class='curline'><a href='../S/1185.html#L505'>ls</a>                505 src/lua/lcode.cpp   sethvalue(fs-&gt;ls-&gt;L, &amp;k, fs-&gt;ls-&gt;h);</span>
<span class='curline'><a href='../S/1185.html#L983'>ls</a>                983 src/lua/lcode.cpp   luaO_arith(fs-&gt;ls-&gt;L, op, &amp;v1, &amp;v2, &amp;res);  /* does operation */</span>
<span class='curline'><a href='../S/1185.html#L1200'>ls</a>               1200 src/lua/lcode.cpp     luaX_syntaxerror(fs-&gt;ls, "constructor too long");</span>
<span class='curline'><a href='../S/1177.html#L32'>ls</a>                 32 src/lua/llex.cpp #define next(ls) (ls-&gt;current = zgetc(ls-&gt;z))</span>
<span class='curline'><a href='../S/1177.html#L36'>ls</a>                 36 src/lua/llex.cpp #define currIsNewline(ls)	(ls-&gt;current == '\n' || ls-&gt;current == '\r')</span>
<span class='curline'><a href='../S/1177.html#L51'>ls</a>                 51 src/lua/llex.cpp #define save_and_next(ls) (save(ls, ls-&gt;current), next(ls))</span>
<span class='curline'><a href='../S/1177.html#L54'>ls</a>                 54 src/lua/llex.cpp static l_noret lexerror (LexState *ls, const char *msg, int token);</span>
<span class='curline'><a href='../S/1177.html#L57'>ls</a>                 57 src/lua/llex.cpp static void save (LexState *ls, int c) {</span>
<span class='curline'><a href='../S/1177.html#L58'>ls</a>                 58 src/lua/llex.cpp   Mbuffer *b = ls-&gt;buff;</span>
<span class='curline'><a href='../S/1177.html#L62'>ls</a>                 62 src/lua/llex.cpp       lexerror(ls, "lexical element too long", 0);</span>
<span class='curline'><a href='../S/1177.html#L64'>ls</a>                 64 src/lua/llex.cpp     luaZ_resizebuffer(ls-&gt;L, b, newsize);</span>
<span class='curline'><a href='../S/1177.html#L82'>ls</a>                 82 src/lua/llex.cpp const char *luaX_token2str (LexState *ls, int token) {</span>
<span class='curline'><a href='../S/1177.html#L85'>ls</a>                 85 src/lua/llex.cpp     return luaO_pushfstring(ls-&gt;L, "'%c'", token);</span>
<span class='curline'><a href='../S/1177.html#L90'>ls</a>                 90 src/lua/llex.cpp       return luaO_pushfstring(ls-&gt;L, "'%s'", s);</span>
<span class='curline'><a href='../S/1177.html#L97'>ls</a>                 97 src/lua/llex.cpp static const char *txtToken (LexState *ls, int token) {</span>
<span class='curline'><a href='../S/1177.html#L101'>ls</a>                101 src/lua/llex.cpp       save(ls, '\0');</span>
<span class='curline'><a href='../S/1177.html#L102'>ls</a>                102 src/lua/llex.cpp       return luaO_pushfstring(ls-&gt;L, "'%s'", luaZ_buffer(ls-&gt;buff));</span>
<span class='curline'><a href='../S/1177.html#L104'>ls</a>                104 src/lua/llex.cpp       return luaX_token2str(ls, token);</span>
<span class='curline'><a href='../S/1177.html#L109'>ls</a>                109 src/lua/llex.cpp static l_noret lexerror (LexState *ls, const char *msg, int token) {</span>
<span class='curline'><a href='../S/1177.html#L110'>ls</a>                110 src/lua/llex.cpp   msg = luaG_addinfo(ls-&gt;L, msg, ls-&gt;source, ls-&gt;linenumber);</span>
<span class='curline'><a href='../S/1177.html#L112'>ls</a>                112 src/lua/llex.cpp     luaO_pushfstring(ls-&gt;L, "%s near %s", msg, txtToken(ls, token));</span>
<span class='curline'><a href='../S/1177.html#L113'>ls</a>                113 src/lua/llex.cpp   luaD_throw(ls-&gt;L, LUA_ERRSYNTAX);</span>
<span class='curline'><a href='../S/1177.html#L117'>ls</a>                117 src/lua/llex.cpp l_noret luaX_syntaxerror (LexState *ls, const char *msg) {</span>
<span class='curline'><a href='../S/1177.html#L118'>ls</a>                118 src/lua/llex.cpp   lexerror(ls, msg, ls-&gt;t.token);</span>
<span class='curline'><a href='../S/1177.html#L127'>ls</a>                127 src/lua/llex.cpp TString *luaX_newstring (LexState *ls, const char *str, size_t l) {</span>
<span class='curline'><a href='../S/1177.html#L128'>ls</a>                128 src/lua/llex.cpp   lua_State *L = ls-&gt;L;</span>
<span class='curline'><a href='../S/1177.html#L132'>ls</a>                132 src/lua/llex.cpp   o = luaH_set(L, ls-&gt;h, L-&gt;top - 1);</span>
<span class='curline'><a href='../S/1177.html#L151'>ls</a>                151 src/lua/llex.cpp static void inclinenumber (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L152'>ls</a>                152 src/lua/llex.cpp   int old = ls-&gt;current;</span>
<span class='curline'><a href='../S/1177.html#L153'>ls</a>                153 src/lua/llex.cpp   lua_assert(currIsNewline(ls));</span>
<span class='curline'><a href='../S/1177.html#L154'>ls</a>                154 src/lua/llex.cpp   next(ls);  /* skip '\n' or '\r' */</span>
<span class='curline'><a href='../S/1177.html#L155'>ls</a>                155 src/lua/llex.cpp   if (currIsNewline(ls) &amp;&amp; ls-&gt;current != old)</span>
<span class='curline'><a href='../S/1177.html#L156'>ls</a>                156 src/lua/llex.cpp     next(ls);  /* skip '\n\r' or '\r\n' */</span>
<span class='curline'><a href='../S/1177.html#L157'>ls</a>                157 src/lua/llex.cpp   if (++ls-&gt;linenumber &gt;= MAX_INT)</span>
<span class='curline'><a href='../S/1177.html#L158'>ls</a>                158 src/lua/llex.cpp     lexerror(ls, "chunk has too many lines", 0);</span>
<span class='curline'><a href='../S/1177.html#L162'>ls</a>                162 src/lua/llex.cpp void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,</span>
<span class='curline'><a href='../S/1177.html#L164'>ls</a>                164 src/lua/llex.cpp   ls-&gt;t.token = 0;</span>
<span class='curline'><a href='../S/1177.html#L165'>ls</a>                165 src/lua/llex.cpp   ls-&gt;L = L;</span>
<span class='curline'><a href='../S/1177.html#L166'>ls</a>                166 src/lua/llex.cpp   ls-&gt;current = firstchar;</span>
<span class='curline'><a href='../S/1177.html#L167'>ls</a>                167 src/lua/llex.cpp   ls-&gt;lookahead.token = TK_EOS;  /* no look-ahead token */</span>
<span class='curline'><a href='../S/1177.html#L168'>ls</a>                168 src/lua/llex.cpp   ls-&gt;z = z;</span>
<span class='curline'><a href='../S/1177.html#L169'>ls</a>                169 src/lua/llex.cpp   ls-&gt;fs = NULL;</span>
<span class='curline'><a href='../S/1177.html#L170'>ls</a>                170 src/lua/llex.cpp   ls-&gt;linenumber = 1;</span>
<span class='curline'><a href='../S/1177.html#L171'>ls</a>                171 src/lua/llex.cpp   ls-&gt;lastline = 1;</span>
<span class='curline'><a href='../S/1177.html#L172'>ls</a>                172 src/lua/llex.cpp   ls-&gt;source = source;</span>
<span class='curline'><a href='../S/1177.html#L173'>ls</a>                173 src/lua/llex.cpp   ls-&gt;envn = luaS_newliteral(L, LUA_ENV);  /* get env name */</span>
<span class='curline'><a href='../S/1177.html#L174'>ls</a>                174 src/lua/llex.cpp   luaZ_resizebuffer(ls-&gt;L, ls-&gt;buff, LUA_MINBUFFER);  /* initialize buffer */</span>
<span class='curline'><a href='../S/1177.html#L186'>ls</a>                186 src/lua/llex.cpp static int check_next1 (LexState *ls, int c) {</span>
<span class='curline'><a href='../S/1177.html#L187'>ls</a>                187 src/lua/llex.cpp   if (ls-&gt;current == c) {</span>
<span class='curline'><a href='../S/1177.html#L188'>ls</a>                188 src/lua/llex.cpp     next(ls);</span>
<span class='curline'><a href='../S/1177.html#L199'>ls</a>                199 src/lua/llex.cpp static int check_next2 (LexState *ls, const char *set) {</span>
<span class='curline'><a href='../S/1177.html#L201'>ls</a>                201 src/lua/llex.cpp   if (ls-&gt;current == set[0] || ls-&gt;current == set[1]) {</span>
<span class='curline'><a href='../S/1177.html#L202'>ls</a>                202 src/lua/llex.cpp     save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L214'>ls</a>                214 src/lua/llex.cpp static int read_numeral (LexState *ls, SemInfo *seminfo) {</span>
<span class='curline'><a href='../S/1177.html#L217'>ls</a>                217 src/lua/llex.cpp   int first = ls-&gt;current;</span>
<span class='curline'><a href='../S/1177.html#L218'>ls</a>                218 src/lua/llex.cpp   lua_assert(lisdigit(ls-&gt;current));</span>
<span class='curline'><a href='../S/1177.html#L219'>ls</a>                219 src/lua/llex.cpp   save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L220'>ls</a>                220 src/lua/llex.cpp   if (first == '0' &amp;&amp; check_next2(ls, "xX"))  /* hexadecimal? */</span>
<span class='curline'><a href='../S/1177.html#L223'>ls</a>                223 src/lua/llex.cpp     if (check_next2(ls, expo))  /* exponent part? */</span>
<span class='curline'><a href='../S/1177.html#L224'>ls</a>                224 src/lua/llex.cpp       check_next2(ls, "-+");  /* optional exponent sign */</span>
<span class='curline'><a href='../S/1177.html#L225'>ls</a>                225 src/lua/llex.cpp     if (lisxdigit(ls-&gt;current))</span>
<span class='curline'><a href='../S/1177.html#L226'>ls</a>                226 src/lua/llex.cpp       save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L227'>ls</a>                227 src/lua/llex.cpp     else if (ls-&gt;current == '.')</span>
<span class='curline'><a href='../S/1177.html#L228'>ls</a>                228 src/lua/llex.cpp       save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L231'>ls</a>                231 src/lua/llex.cpp   save(ls, '\0');</span>
<span class='curline'><a href='../S/1177.html#L232'>ls</a>                232 src/lua/llex.cpp   if (luaO_str2num(luaZ_buffer(ls-&gt;buff), &amp;obj) == 0)  /* format error? */</span>
<span class='curline'><a href='../S/1177.html#L233'>ls</a>                233 src/lua/llex.cpp     lexerror(ls, "malformed number", TK_FLT);</span>
<span class='curline'><a href='../S/1177.html#L251'>ls</a>                251 src/lua/llex.cpp static int skip_sep (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L253'>ls</a>                253 src/lua/llex.cpp   int s = ls-&gt;current;</span>
<span class='curline'><a href='../S/1177.html#L255'>ls</a>                255 src/lua/llex.cpp   save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L256'>ls</a>                256 src/lua/llex.cpp   while (ls-&gt;current == '=') {</span>
<span class='curline'><a href='../S/1177.html#L257'>ls</a>                257 src/lua/llex.cpp     save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L260'>ls</a>                260 src/lua/llex.cpp   return (ls-&gt;current == s) ? count : (-count) - 1;</span>
<span class='curline'><a href='../S/1177.html#L264'>ls</a>                264 src/lua/llex.cpp static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {</span>
<span class='curline'><a href='../S/1177.html#L265'>ls</a>                265 src/lua/llex.cpp   int line = ls-&gt;linenumber;  /* initial line (for error message) */</span>
<span class='curline'><a href='../S/1177.html#L266'>ls</a>                266 src/lua/llex.cpp   save_and_next(ls);  /* skip 2nd '[' */</span>
<span class='curline'><a href='../S/1177.html#L267'>ls</a>                267 src/lua/llex.cpp   if (currIsNewline(ls))  /* string starts with a newline? */</span>
<span class='curline'><a href='../S/1177.html#L268'>ls</a>                268 src/lua/llex.cpp     inclinenumber(ls);  /* skip it */</span>
<span class='curline'><a href='../S/1177.html#L270'>ls</a>                270 src/lua/llex.cpp     switch (ls-&gt;current) {</span>
<span class='curline'><a href='../S/1177.html#L273'>ls</a>                273 src/lua/llex.cpp         const char *msg = luaO_pushfstring(ls-&gt;L,</span>
<span class='curline'><a href='../S/1177.html#L275'>ls</a>                275 src/lua/llex.cpp         lexerror(ls, msg, TK_EOS);</span>
<span class='curline'><a href='../S/1177.html#L279'>ls</a>                279 src/lua/llex.cpp         if (skip_sep(ls) == sep) {</span>
<span class='curline'><a href='../S/1177.html#L280'>ls</a>                280 src/lua/llex.cpp           save_and_next(ls);  /* skip 2nd ']' */</span>
<span class='curline'><a href='../S/1177.html#L286'>ls</a>                286 src/lua/llex.cpp         save(ls, '\n');</span>
<span class='curline'><a href='../S/1177.html#L287'>ls</a>                287 src/lua/llex.cpp         inclinenumber(ls);</span>
<span class='curline'><a href='../S/1177.html#L288'>ls</a>                288 src/lua/llex.cpp         if (!seminfo) luaZ_resetbuffer(ls-&gt;buff);  /* avoid wasting space */</span>
<span class='curline'><a href='../S/1177.html#L292'>ls</a>                292 src/lua/llex.cpp         if (seminfo) save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L293'>ls</a>                293 src/lua/llex.cpp         else next(ls);</span>
<span class='curline'><a href='../S/1177.html#L298'>ls</a>                298 src/lua/llex.cpp     seminfo-&gt;ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff) + (2 + sep),</span>
<span class='curline'><a href='../S/1177.html#L299'>ls</a>                299 src/lua/llex.cpp                                      luaZ_bufflen(ls-&gt;buff) - 2*(2 + sep));</span>
<span class='curline'><a href='../S/1177.html#L303'>ls</a>                303 src/lua/llex.cpp static void esccheck (LexState *ls, int c, const char *msg) {</span>
<span class='curline'><a href='../S/1177.html#L305'>ls</a>                305 src/lua/llex.cpp     if (ls-&gt;current != EOZ)</span>
<span class='curline'><a href='../S/1177.html#L306'>ls</a>                306 src/lua/llex.cpp       save_and_next(ls);  /* add current to buffer for error message */</span>
<span class='curline'><a href='../S/1177.html#L307'>ls</a>                307 src/lua/llex.cpp     lexerror(ls, msg, TK_STRING);</span>
<span class='curline'><a href='../S/1177.html#L312'>ls</a>                312 src/lua/llex.cpp static int gethexa (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L313'>ls</a>                313 src/lua/llex.cpp   save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L314'>ls</a>                314 src/lua/llex.cpp   esccheck (ls, lisxdigit(ls-&gt;current), "hexadecimal digit expected");</span>
<span class='curline'><a href='../S/1177.html#L315'>ls</a>                315 src/lua/llex.cpp   return luaO_hexavalue(ls-&gt;current);</span>
<span class='curline'><a href='../S/1177.html#L319'>ls</a>                319 src/lua/llex.cpp static int readhexaesc (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L320'>ls</a>                320 src/lua/llex.cpp   int r = gethexa(ls);</span>
<span class='curline'><a href='../S/1177.html#L321'>ls</a>                321 src/lua/llex.cpp   r = (r &lt;&lt; 4) + gethexa(ls);</span>
<span class='curline'><a href='../S/1177.html#L322'>ls</a>                322 src/lua/llex.cpp   luaZ_buffremove(ls-&gt;buff, 2);  /* remove saved chars from buffer */</span>
<span class='curline'><a href='../S/1177.html#L327'>ls</a>                327 src/lua/llex.cpp static unsigned long readutf8esc (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L330'>ls</a>                330 src/lua/llex.cpp   save_and_next(ls);  /* skip 'u' */</span>
<span class='curline'><a href='../S/1177.html#L331'>ls</a>                331 src/lua/llex.cpp   esccheck(ls, ls-&gt;current == '{', "missing '{'");</span>
<span class='curline'><a href='../S/1177.html#L332'>ls</a>                332 src/lua/llex.cpp   r = gethexa(ls);  /* must have at least one digit */</span>
<span class='curline'><a href='../S/1177.html#L333'>ls</a>                333 src/lua/llex.cpp   while ((save_and_next(ls), lisxdigit(ls-&gt;current))) {</span>
<span class='curline'><a href='../S/1177.html#L335'>ls</a>                335 src/lua/llex.cpp     r = (r &lt;&lt; 4) + luaO_hexavalue(ls-&gt;current);</span>
<span class='curline'><a href='../S/1177.html#L336'>ls</a>                336 src/lua/llex.cpp     esccheck(ls, r &lt;= 0x10FFFF, "UTF-8 value too large");</span>
<span class='curline'><a href='../S/1177.html#L338'>ls</a>                338 src/lua/llex.cpp   esccheck(ls, ls-&gt;current == '}', "missing '}'");</span>
<span class='curline'><a href='../S/1177.html#L339'>ls</a>                339 src/lua/llex.cpp   next(ls);  /* skip '}' */</span>
<span class='curline'><a href='../S/1177.html#L340'>ls</a>                340 src/lua/llex.cpp   luaZ_buffremove(ls-&gt;buff, i);  /* remove saved chars from buffer */</span>
<span class='curline'><a href='../S/1177.html#L345'>ls</a>                345 src/lua/llex.cpp static void utf8esc (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L347'>ls</a>                347 src/lua/llex.cpp   int n = luaO_utf8esc(buff, readutf8esc(ls));</span>
<span class='curline'><a href='../S/1177.html#L349'>ls</a>                349 src/lua/llex.cpp     save(ls, buff[UTF8BUFFSZ - n]);</span>
<span class='curline'><a href='../S/1177.html#L353'>ls</a>                353 src/lua/llex.cpp static int readdecesc (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L356'>ls</a>                356 src/lua/llex.cpp   for (i = 0; i &lt; 3 &amp;&amp; lisdigit(ls-&gt;current); i++) {  /* read up to 3 digits */</span>
<span class='curline'><a href='../S/1177.html#L357'>ls</a>                357 src/lua/llex.cpp     r = 10*r + ls-&gt;current - '0';</span>
<span class='curline'><a href='../S/1177.html#L358'>ls</a>                358 src/lua/llex.cpp     save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L360'>ls</a>                360 src/lua/llex.cpp   esccheck(ls, r &lt;= UCHAR_MAX, "decimal escape too large");</span>
<span class='curline'><a href='../S/1177.html#L361'>ls</a>                361 src/lua/llex.cpp   luaZ_buffremove(ls-&gt;buff, i);  /* remove read digits from buffer */</span>
<span class='curline'><a href='../S/1177.html#L366'>ls</a>                366 src/lua/llex.cpp static void read_string (LexState *ls, int del, SemInfo *seminfo) {</span>
<span class='curline'><a href='../S/1177.html#L367'>ls</a>                367 src/lua/llex.cpp   save_and_next(ls);  /* keep delimiter (for error messages) */</span>
<span class='curline'><a href='../S/1177.html#L368'>ls</a>                368 src/lua/llex.cpp   while (ls-&gt;current != del) {</span>
<span class='curline'><a href='../S/1177.html#L369'>ls</a>                369 src/lua/llex.cpp     switch (ls-&gt;current) {</span>
<span class='curline'><a href='../S/1177.html#L371'>ls</a>                371 src/lua/llex.cpp         lexerror(ls, "unfinished string", TK_EOS);</span>
<span class='curline'><a href='../S/1177.html#L375'>ls</a>                375 src/lua/llex.cpp         lexerror(ls, "unfinished string", TK_STRING);</span>
<span class='curline'><a href='../S/1177.html#L379'>ls</a>                379 src/lua/llex.cpp         save_and_next(ls);  /* keep '\\' for error messages */</span>
<span class='curline'><a href='../S/1177.html#L380'>ls</a>                380 src/lua/llex.cpp         switch (ls-&gt;current) {</span>
<span class='curline'><a href='../S/1177.html#L388'>ls</a>                388 src/lua/llex.cpp           case 'x': c = readhexaesc(ls); goto read_save;</span>
<span class='curline'><a href='../S/1177.html#L389'>ls</a>                389 src/lua/llex.cpp           case 'u': utf8esc(ls);  goto no_save;</span>
<span class='curline'><a href='../S/1177.html#L391'>ls</a>                391 src/lua/llex.cpp             inclinenumber(ls); c = '\n'; goto only_save;</span>
<span class='curline'><a href='../S/1177.html#L393'>ls</a>                393 src/lua/llex.cpp             c = ls-&gt;current; goto read_save;</span>
<span class='curline'><a href='../S/1177.html#L396'>ls</a>                396 src/lua/llex.cpp             luaZ_buffremove(ls-&gt;buff, 1);  /* remove '\\' */</span>
<span class='curline'><a href='../S/1177.html#L397'>ls</a>                397 src/lua/llex.cpp             next(ls);  /* skip the 'z' */</span>
<span class='curline'><a href='../S/1177.html#L398'>ls</a>                398 src/lua/llex.cpp             while (lisspace(ls-&gt;current)) {</span>
<span class='curline'><a href='../S/1177.html#L399'>ls</a>                399 src/lua/llex.cpp               if (currIsNewline(ls)) inclinenumber(ls);</span>
<span class='curline'><a href='../S/1177.html#L400'>ls</a>                400 src/lua/llex.cpp               else next(ls);</span>
<span class='curline'><a href='../S/1177.html#L405'>ls</a>                405 src/lua/llex.cpp             esccheck(ls, lisdigit(ls-&gt;current), "invalid escape sequence");</span>
<span class='curline'><a href='../S/1177.html#L406'>ls</a>                406 src/lua/llex.cpp             c = readdecesc(ls);  /* digital escape '\ddd' */</span>
<span class='curline'><a href='../S/1177.html#L411'>ls</a>                411 src/lua/llex.cpp          next(ls);</span>
<span class='curline'><a href='../S/1177.html#L414'>ls</a>                414 src/lua/llex.cpp          luaZ_buffremove(ls-&gt;buff, 1);  /* remove '\\' */</span>
<span class='curline'><a href='../S/1177.html#L415'>ls</a>                415 src/lua/llex.cpp          save(ls, c);</span>
<span class='curline'><a href='../S/1177.html#L420'>ls</a>                420 src/lua/llex.cpp         save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L423'>ls</a>                423 src/lua/llex.cpp   save_and_next(ls);  /* skip delimiter */</span>
<span class='curline'><a href='../S/1177.html#L424'>ls</a>                424 src/lua/llex.cpp   seminfo-&gt;ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff) + 1,</span>
<span class='curline'><a href='../S/1177.html#L425'>ls</a>                425 src/lua/llex.cpp                                    luaZ_bufflen(ls-&gt;buff) - 2);</span>
<span class='curline'><a href='../S/1177.html#L429'>ls</a>                429 src/lua/llex.cpp static int llex (LexState *ls, SemInfo *seminfo) {</span>
<span class='curline'><a href='../S/1177.html#L430'>ls</a>                430 src/lua/llex.cpp   luaZ_resetbuffer(ls-&gt;buff);</span>
<span class='curline'><a href='../S/1177.html#L432'>ls</a>                432 src/lua/llex.cpp     switch (ls-&gt;current) {</span>
<span class='curline'><a href='../S/1177.html#L434'>ls</a>                434 src/lua/llex.cpp         inclinenumber(ls);</span>
<span class='curline'><a href='../S/1177.html#L438'>ls</a>                438 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L442'>ls</a>                442 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L443'>ls</a>                443 src/lua/llex.cpp         if (ls-&gt;current != '-') return '-';</span>
<span class='curline'><a href='../S/1177.html#L445'>ls</a>                445 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L446'>ls</a>                446 src/lua/llex.cpp         if (ls-&gt;current == '[') {  /* long comment? */</span>
<span class='curline'><a href='../S/1177.html#L447'>ls</a>                447 src/lua/llex.cpp           int sep = skip_sep(ls);</span>
<span class='curline'><a href='../S/1177.html#L448'>ls</a>                448 src/lua/llex.cpp           luaZ_resetbuffer(ls-&gt;buff);  /* 'skip_sep' may dirty the buffer */</span>
<span class='curline'><a href='../S/1177.html#L450'>ls</a>                450 src/lua/llex.cpp             read_long_string(ls, NULL, sep);  /* skip long comment */</span>
<span class='curline'><a href='../S/1177.html#L451'>ls</a>                451 src/lua/llex.cpp             luaZ_resetbuffer(ls-&gt;buff);  /* previous call may dirty the buff. */</span>
<span class='curline'><a href='../S/1177.html#L456'>ls</a>                456 src/lua/llex.cpp         while (!currIsNewline(ls) &amp;&amp; ls-&gt;current != EOZ)</span>
<span class='curline'><a href='../S/1177.html#L457'>ls</a>                457 src/lua/llex.cpp           next(ls);  /* skip until end of line (or end of file) */</span>
<span class='curline'><a href='../S/1177.html#L461'>ls</a>                461 src/lua/llex.cpp         int sep = skip_sep(ls);</span>
<span class='curline'><a href='../S/1177.html#L463'>ls</a>                463 src/lua/llex.cpp           read_long_string(ls, seminfo, sep);</span>
<span class='curline'><a href='../S/1177.html#L467'>ls</a>                467 src/lua/llex.cpp           lexerror(ls, "invalid long string delimiter", TK_STRING);</span>
<span class='curline'><a href='../S/1177.html#L471'>ls</a>                471 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L472'>ls</a>                472 src/lua/llex.cpp         if (check_next1(ls, '=')) return TK_EQ;</span>
<span class='curline'><a href='../S/1177.html#L476'>ls</a>                476 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L477'>ls</a>                477 src/lua/llex.cpp         if (check_next1(ls, '=')) return TK_LE;</span>
<span class='curline'><a href='../S/1177.html#L478'>ls</a>                478 src/lua/llex.cpp         else if (check_next1(ls, '&lt;')) return TK_SHL;</span>
<span class='curline'><a href='../S/1177.html#L482'>ls</a>                482 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L483'>ls</a>                483 src/lua/llex.cpp         if (check_next1(ls, '=')) return TK_GE;</span>
<span class='curline'><a href='../S/1177.html#L484'>ls</a>                484 src/lua/llex.cpp         else if (check_next1(ls, '&gt;')) return TK_SHR;</span>
<span class='curline'><a href='../S/1177.html#L488'>ls</a>                488 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L489'>ls</a>                489 src/lua/llex.cpp         if (check_next1(ls, '/')) return TK_IDIV;</span>
<span class='curline'><a href='../S/1177.html#L493'>ls</a>                493 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L494'>ls</a>                494 src/lua/llex.cpp         if (check_next1(ls, '=')) return TK_NE;</span>
<span class='curline'><a href='../S/1177.html#L498'>ls</a>                498 src/lua/llex.cpp         next(ls);</span>
<span class='curline'><a href='../S/1177.html#L499'>ls</a>                499 src/lua/llex.cpp         if (check_next1(ls, ':')) return TK_DBCOLON;</span>
<span class='curline'><a href='../S/1177.html#L503'>ls</a>                503 src/lua/llex.cpp         read_string(ls, ls-&gt;current, seminfo);</span>
<span class='curline'><a href='../S/1177.html#L507'>ls</a>                507 src/lua/llex.cpp         save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L508'>ls</a>                508 src/lua/llex.cpp         if (check_next1(ls, '.')) {</span>
<span class='curline'><a href='../S/1177.html#L509'>ls</a>                509 src/lua/llex.cpp           if (check_next1(ls, '.'))</span>
<span class='curline'><a href='../S/1177.html#L513'>ls</a>                513 src/lua/llex.cpp         else if (!lisdigit(ls-&gt;current)) return '.';</span>
<span class='curline'><a href='../S/1177.html#L514'>ls</a>                514 src/lua/llex.cpp         else return read_numeral(ls, seminfo);</span>
<span class='curline'><a href='../S/1177.html#L518'>ls</a>                518 src/lua/llex.cpp         return read_numeral(ls, seminfo);</span>
<span class='curline'><a href='../S/1177.html#L524'>ls</a>                524 src/lua/llex.cpp         if (lislalpha(ls-&gt;current)) {  /* identifier or reserved word? */</span>
<span class='curline'><a href='../S/1177.html#L527'>ls</a>                527 src/lua/llex.cpp             save_and_next(ls);</span>
<span class='curline'><a href='../S/1177.html#L528'>ls</a>                528 src/lua/llex.cpp           } while (lislalnum(ls-&gt;current));</span>
<span class='curline'><a href='../S/1177.html#L529'>ls</a>                529 src/lua/llex.cpp           ts = luaX_newstring(ls, luaZ_buffer(ls-&gt;buff),</span>
<span class='curline'><a href='../S/1177.html#L530'>ls</a>                530 src/lua/llex.cpp                                   luaZ_bufflen(ls-&gt;buff));</span>
<span class='curline'><a href='../S/1177.html#L539'>ls</a>                539 src/lua/llex.cpp           int c = ls-&gt;current;</span>
<span class='curline'><a href='../S/1177.html#L540'>ls</a>                540 src/lua/llex.cpp           next(ls);</span>
<span class='curline'><a href='../S/1177.html#L549'>ls</a>                549 src/lua/llex.cpp void luaX_next (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L550'>ls</a>                550 src/lua/llex.cpp   ls-&gt;lastline = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1177.html#L551'>ls</a>                551 src/lua/llex.cpp   if (ls-&gt;lookahead.token != TK_EOS) {  /* is there a look-ahead token? */</span>
<span class='curline'><a href='../S/1177.html#L552'>ls</a>                552 src/lua/llex.cpp     ls-&gt;t = ls-&gt;lookahead;  /* use this one */</span>
<span class='curline'><a href='../S/1177.html#L553'>ls</a>                553 src/lua/llex.cpp     ls-&gt;lookahead.token = TK_EOS;  /* and discharge it */</span>
<span class='curline'><a href='../S/1177.html#L556'>ls</a>                556 src/lua/llex.cpp     ls-&gt;t.token = llex(ls, &amp;ls-&gt;t.seminfo);  /* read next token */</span>
<span class='curline'><a href='../S/1177.html#L560'>ls</a>                560 src/lua/llex.cpp int luaX_lookahead (LexState *ls) {</span>
<span class='curline'><a href='../S/1177.html#L561'>ls</a>                561 src/lua/llex.cpp   lua_assert(ls-&gt;lookahead.token == TK_EOS);</span>
<span class='curline'><a href='../S/1177.html#L562'>ls</a>                562 src/lua/llex.cpp   ls-&gt;lookahead.token = llex(ls, &amp;ls-&gt;lookahead.seminfo);</span>
<span class='curline'><a href='../S/1177.html#L563'>ls</a>                563 src/lua/llex.cpp   return ls-&gt;lookahead.token;</span>
<span class='curline'><a href='../S/1176.html#L76'>ls</a>                 76 src/lua/llex.h LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,</span>
<span class='curline'><a href='../S/1176.html#L78'>ls</a>                 78 src/lua/llex.h LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);</span>
<span class='curline'><a href='../S/1176.html#L79'>ls</a>                 79 src/lua/llex.h LUAI_FUNC void luaX_next (LexState *ls);</span>
<span class='curline'><a href='../S/1176.html#L80'>ls</a>                 80 src/lua/llex.h LUAI_FUNC int luaX_lookahead (LexState *ls);</span>
<span class='curline'><a href='../S/1176.html#L81'>ls</a>                 81 src/lua/llex.h LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);</span>
<span class='curline'><a href='../S/1176.html#L82'>ls</a>                 82 src/lua/llex.h LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);</span>
<span class='curline'><a href='../S/1226.html#L62'>ls</a>                 62 src/lua/lparser.cpp static void statement (LexState *ls);</span>
<span class='curline'><a href='../S/1226.html#L63'>ls</a>                 63 src/lua/lparser.cpp static void expr (LexState *ls, expdesc *v);</span>
<span class='curline'><a href='../S/1226.html#L67'>ls</a>                 67 src/lua/lparser.cpp static l_noret semerror (LexState *ls, const char *msg) {</span>
<span class='curline'><a href='../S/1226.html#L68'>ls</a>                 68 src/lua/lparser.cpp   ls-&gt;t.token = 0;  /* remove "near &lt;token&gt;" from final message */</span>
<span class='curline'><a href='../S/1226.html#L69'>ls</a>                 69 src/lua/lparser.cpp   luaX_syntaxerror(ls, msg);</span>
<span class='curline'><a href='../S/1226.html#L73'>ls</a>                 73 src/lua/lparser.cpp static l_noret error_expected (LexState *ls, int token) {</span>
<span class='curline'><a href='../S/1226.html#L74'>ls</a>                 74 src/lua/lparser.cpp   luaX_syntaxerror(ls,</span>
<span class='curline'><a href='../S/1226.html#L75'>ls</a>                 75 src/lua/lparser.cpp       luaO_pushfstring(ls-&gt;L, "%s expected", luaX_token2str(ls, token)));</span>
<span class='curline'><a href='../S/1226.html#L80'>ls</a>                 80 src/lua/lparser.cpp   lua_State *L = fs-&gt;ls-&gt;L;</span>
<span class='curline'><a href='../S/1226.html#L88'>ls</a>                 88 src/lua/lparser.cpp   luaX_syntaxerror(fs-&gt;ls, msg);</span>
<span class='curline'><a href='../S/1226.html#L97'>ls</a>                 97 src/lua/lparser.cpp static int testnext (LexState *ls, int c) {</span>
<span class='curline'><a href='../S/1226.html#L98'>ls</a>                 98 src/lua/lparser.cpp   if (ls-&gt;t.token == c) {</span>
<span class='curline'><a href='../S/1226.html#L99'>ls</a>                 99 src/lua/lparser.cpp     luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L106'>ls</a>                106 src/lua/lparser.cpp static void check (LexState *ls, int c) {</span>
<span class='curline'><a href='../S/1226.html#L107'>ls</a>                107 src/lua/lparser.cpp   if (ls-&gt;t.token != c)</span>
<span class='curline'><a href='../S/1226.html#L108'>ls</a>                108 src/lua/lparser.cpp     error_expected(ls, c);</span>
<span class='curline'><a href='../S/1226.html#L112'>ls</a>                112 src/lua/lparser.cpp static void checknext (LexState *ls, int c) {</span>
<span class='curline'><a href='../S/1226.html#L113'>ls</a>                113 src/lua/lparser.cpp   check(ls, c);</span>
<span class='curline'><a href='../S/1226.html#L114'>ls</a>                114 src/lua/lparser.cpp   luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L118'>ls</a>                118 src/lua/lparser.cpp #define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }</span>
<span class='curline'><a href='../S/1226.html#L122'>ls</a>                122 src/lua/lparser.cpp static void check_match (LexState *ls, int what, int who, int where) {</span>
<span class='curline'><a href='../S/1226.html#L123'>ls</a>                123 src/lua/lparser.cpp   if (!testnext(ls, what)) {</span>
<span class='curline'><a href='../S/1226.html#L124'>ls</a>                124 src/lua/lparser.cpp     if (where == ls-&gt;linenumber)</span>
<span class='curline'><a href='../S/1226.html#L125'>ls</a>                125 src/lua/lparser.cpp       error_expected(ls, what);</span>
<span class='curline'><a href='../S/1226.html#L127'>ls</a>                127 src/lua/lparser.cpp       luaX_syntaxerror(ls, luaO_pushfstring(ls-&gt;L,</span>
<span class='curline'><a href='../S/1226.html#L129'>ls</a>                129 src/lua/lparser.cpp               luaX_token2str(ls, what), luaX_token2str(ls, who), where));</span>
<span class='curline'><a href='../S/1226.html#L135'>ls</a>                135 src/lua/lparser.cpp static TString *str_checkname (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L137'>ls</a>                137 src/lua/lparser.cpp   check(ls, TK_NAME);</span>
<span class='curline'><a href='../S/1226.html#L138'>ls</a>                138 src/lua/lparser.cpp   ts = ls-&gt;t.seminfo.ts;</span>
<span class='curline'><a href='../S/1226.html#L139'>ls</a>                139 src/lua/lparser.cpp   luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L151'>ls</a>                151 src/lua/lparser.cpp static void codestring (LexState *ls, expdesc *e, TString *s) {</span>
<span class='curline'><a href='../S/1226.html#L152'>ls</a>                152 src/lua/lparser.cpp   init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));</span>
<span class='curline'><a href='../S/1226.html#L156'>ls</a>                156 src/lua/lparser.cpp static void checkname (LexState *ls, expdesc *e) {</span>
<span class='curline'><a href='../S/1226.html#L157'>ls</a>                157 src/lua/lparser.cpp   codestring(ls, e, str_checkname(ls));</span>
<span class='curline'><a href='../S/1226.html#L161'>ls</a>                161 src/lua/lparser.cpp static int registerlocalvar (LexState *ls, TString *varname) {</span>
<span class='curline'><a href='../S/1226.html#L162'>ls</a>                162 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L165'>ls</a>                165 src/lua/lparser.cpp   luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,</span>
<span class='curline'><a href='../S/1226.html#L170'>ls</a>                170 src/lua/lparser.cpp   luaC_objbarrier(ls-&gt;L, f, varname);</span>
<span class='curline'><a href='../S/1226.html#L175'>ls</a>                175 src/lua/lparser.cpp static void new_localvar (LexState *ls, TString *name) {</span>
<span class='curline'><a href='../S/1226.html#L176'>ls</a>                176 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L177'>ls</a>                177 src/lua/lparser.cpp   Dyndata *dyd = ls-&gt;dyd;</span>
<span class='curline'><a href='../S/1226.html#L178'>ls</a>                178 src/lua/lparser.cpp   int reg = registerlocalvar(ls, name);</span>
<span class='curline'><a href='../S/1226.html#L181'>ls</a>                181 src/lua/lparser.cpp   luaM_growvector(ls-&gt;L, dyd-&gt;actvar.arr, dyd-&gt;actvar.n + 1,</span>
<span class='curline'><a href='../S/1226.html#L187'>ls</a>                187 src/lua/lparser.cpp static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {</span>
<span class='curline'><a href='../S/1226.html#L188'>ls</a>                188 src/lua/lparser.cpp   new_localvar(ls, luaX_newstring(ls, name, sz));</span>
<span class='curline'><a href='../S/1226.html#L191'>ls</a>                191 src/lua/lparser.cpp #define new_localvarliteral(ls,v) \</span>
<span class='curline'><a href='../S/1226.html#L192'>ls</a>                192 src/lua/lparser.cpp 	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)</span>
<span class='curline'><a href='../S/1226.html#L196'>ls</a>                196 src/lua/lparser.cpp   int idx = fs-&gt;ls-&gt;dyd-&gt;actvar.arr[fs-&gt;firstlocal + i].idx;</span>
<span class='curline'><a href='../S/1226.html#L202'>ls</a>                202 src/lua/lparser.cpp static void adjustlocalvars (LexState *ls, int nvars) {</span>
<span class='curline'><a href='../S/1226.html#L203'>ls</a>                203 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L212'>ls</a>                212 src/lua/lparser.cpp   fs-&gt;ls-&gt;dyd-&gt;actvar.n -= (fs-&gt;nactvar - tolevel);</span>
<span class='curline'><a href='../S/1226.html#L232'>ls</a>                232 src/lua/lparser.cpp   luaM_growvector(fs-&gt;ls-&gt;L, f-&gt;upvalues, fs-&gt;nups, f-&gt;sizeupvalues,</span>
<span class='curline'><a href='../S/1226.html#L239'>ls</a>                239 src/lua/lparser.cpp   luaC_objbarrier(fs-&gt;ls-&gt;L, f, name);</span>
<span class='curline'><a href='../S/1226.html#L295'>ls</a>                295 src/lua/lparser.cpp static void singlevar (LexState *ls, expdesc *var) {</span>
<span class='curline'><a href='../S/1226.html#L296'>ls</a>                296 src/lua/lparser.cpp   TString *varname = str_checkname(ls);</span>
<span class='curline'><a href='../S/1226.html#L297'>ls</a>                297 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L301'>ls</a>                301 src/lua/lparser.cpp     singlevaraux(fs, ls-&gt;envn, var, 1);  /* get environment variable */</span>
<span class='curline'><a href='../S/1226.html#L303'>ls</a>                303 src/lua/lparser.cpp     codestring(ls, &amp;key, varname);  /* key is variable name */</span>
<span class='curline'><a href='../S/1226.html#L309'>ls</a>                309 src/lua/lparser.cpp static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {</span>
<span class='curline'><a href='../S/1226.html#L310'>ls</a>                310 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L327'>ls</a>                327 src/lua/lparser.cpp     ls-&gt;fs-&gt;freereg -= nexps - nvars;  /* remove extra values */</span>
<span class='curline'><a href='../S/1226.html#L331'>ls</a>                331 src/lua/lparser.cpp static void enterlevel (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L332'>ls</a>                332 src/lua/lparser.cpp   lua_State *L = ls-&gt;L;</span>
<span class='curline'><a href='../S/1226.html#L334'>ls</a>                334 src/lua/lparser.cpp   checklimit(ls-&gt;fs, L-&gt;nCcalls, LUAI_MAXCCALLS, "C levels");</span>
<span class='curline'><a href='../S/1226.html#L338'>ls</a>                338 src/lua/lparser.cpp #define leavelevel(ls)	((ls)-&gt;L-&gt;nCcalls--)</span>
<span class='curline'><a href='../S/1226.html#L341'>ls</a>                341 src/lua/lparser.cpp static void closegoto (LexState *ls, int g, Labeldesc *label) {</span>
<span class='curline'><a href='../S/1226.html#L343'>ls</a>                343 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L344'>ls</a>                344 src/lua/lparser.cpp   Labellist *gl = &amp;ls-&gt;dyd-&gt;gt;</span>
<span class='curline'><a href='../S/1226.html#L349'>ls</a>                349 src/lua/lparser.cpp     const char *msg = luaO_pushfstring(ls-&gt;L,</span>
<span class='curline'><a href='../S/1226.html#L352'>ls</a>                352 src/lua/lparser.cpp     semerror(ls, msg);</span>
<span class='curline'><a href='../S/1226.html#L365'>ls</a>                365 src/lua/lparser.cpp static int findlabel (LexState *ls, int g) {</span>
<span class='curline'><a href='../S/1226.html#L367'>ls</a>                367 src/lua/lparser.cpp   BlockCnt *bl = ls-&gt;fs-&gt;bl;</span>
<span class='curline'><a href='../S/1226.html#L368'>ls</a>                368 src/lua/lparser.cpp   Dyndata *dyd = ls-&gt;dyd;</span>
<span class='curline'><a href='../S/1226.html#L376'>ls</a>                376 src/lua/lparser.cpp         luaK_patchclose(ls-&gt;fs, gt-&gt;pc, lb-&gt;nactvar);</span>
<span class='curline'><a href='../S/1226.html#L377'>ls</a>                377 src/lua/lparser.cpp       closegoto(ls, g, lb);  /* close it */</span>
<span class='curline'><a href='../S/1226.html#L385'>ls</a>                385 src/lua/lparser.cpp static int newlabelentry (LexState *ls, Labellist *l, TString *name,</span>
<span class='curline'><a href='../S/1226.html#L388'>ls</a>                388 src/lua/lparser.cpp   luaM_growvector(ls-&gt;L, l-&gt;arr, n, l-&gt;size,</span>
<span class='curline'><a href='../S/1226.html#L392'>ls</a>                392 src/lua/lparser.cpp   l-&gt;arr[n].nactvar = ls-&gt;fs-&gt;nactvar;</span>
<span class='curline'><a href='../S/1226.html#L403'>ls</a>                403 src/lua/lparser.cpp static void findgotos (LexState *ls, Labeldesc *lb) {</span>
<span class='curline'><a href='../S/1226.html#L404'>ls</a>                404 src/lua/lparser.cpp   Labellist *gl = &amp;ls-&gt;dyd-&gt;gt;</span>
<span class='curline'><a href='../S/1226.html#L405'>ls</a>                405 src/lua/lparser.cpp   int i = ls-&gt;fs-&gt;bl-&gt;firstgoto;</span>
<span class='curline'><a href='../S/1226.html#L408'>ls</a>                408 src/lua/lparser.cpp       closegoto(ls, i, lb);</span>
<span class='curline'><a href='../S/1226.html#L423'>ls</a>                423 src/lua/lparser.cpp   Labellist *gl = &amp;fs-&gt;ls-&gt;dyd-&gt;gt;</span>
<span class='curline'><a href='../S/1226.html#L433'>ls</a>                433 src/lua/lparser.cpp     if (!findlabel(fs-&gt;ls, i))</span>
<span class='curline'><a href='../S/1226.html#L442'>ls</a>                442 src/lua/lparser.cpp   bl-&gt;firstlabel = fs-&gt;ls-&gt;dyd-&gt;label.n;</span>
<span class='curline'><a href='../S/1226.html#L443'>ls</a>                443 src/lua/lparser.cpp   bl-&gt;firstgoto = fs-&gt;ls-&gt;dyd-&gt;gt.n;</span>
<span class='curline'><a href='../S/1226.html#L454'>ls</a>                454 src/lua/lparser.cpp static void breaklabel (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L455'>ls</a>                455 src/lua/lparser.cpp   TString *n = luaS_new(ls-&gt;L, "break");</span>
<span class='curline'><a href='../S/1226.html#L456'>ls</a>                456 src/lua/lparser.cpp   int l = newlabelentry(ls, &amp;ls-&gt;dyd-&gt;label, n, 0, ls-&gt;fs-&gt;pc);</span>
<span class='curline'><a href='../S/1226.html#L457'>ls</a>                457 src/lua/lparser.cpp   findgotos(ls, &amp;ls-&gt;dyd-&gt;label.arr[l]);</span>
<span class='curline'><a href='../S/1226.html#L464'>ls</a>                464 src/lua/lparser.cpp static l_noret undefgoto (LexState *ls, Labeldesc *gt) {</span>
<span class='curline'><a href='../S/1226.html#L468'>ls</a>                468 src/lua/lparser.cpp   msg = luaO_pushfstring(ls-&gt;L, msg, getstr(gt-&gt;name), gt-&gt;line);</span>
<span class='curline'><a href='../S/1226.html#L469'>ls</a>                469 src/lua/lparser.cpp   semerror(ls, msg);</span>
<span class='curline'><a href='../S/1226.html#L475'>ls</a>                475 src/lua/lparser.cpp   LexState *ls = fs-&gt;ls;</span>
<span class='curline'><a href='../S/1226.html#L483'>ls</a>                483 src/lua/lparser.cpp     breaklabel(ls);  /* close pending breaks */</span>
<span class='curline'><a href='../S/1226.html#L488'>ls</a>                488 src/lua/lparser.cpp   ls-&gt;dyd-&gt;label.n = bl-&gt;firstlabel;  /* remove local labels */</span>
<span class='curline'><a href='../S/1226.html#L491'>ls</a>                491 src/lua/lparser.cpp   else if (bl-&gt;firstgoto &lt; ls-&gt;dyd-&gt;gt.n)  /* pending gotos in outer block? */</span>
<span class='curline'><a href='../S/1226.html#L492'>ls</a>                492 src/lua/lparser.cpp     undefgoto(ls, &amp;ls-&gt;dyd-&gt;gt.arr[bl-&gt;firstgoto]);  /* error */</span>
<span class='curline'><a href='../S/1226.html#L499'>ls</a>                499 src/lua/lparser.cpp static Proto *addprototype (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L501'>ls</a>                501 src/lua/lparser.cpp   lua_State *L = ls-&gt;L;</span>
<span class='curline'><a href='../S/1226.html#L502'>ls</a>                502 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L522'>ls</a>                522 src/lua/lparser.cpp static void codeclosure (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L523'>ls</a>                523 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs-&gt;prev;</span>
<span class='curline'><a href='../S/1226.html#L529'>ls</a>                529 src/lua/lparser.cpp static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {</span>
<span class='curline'><a href='../S/1226.html#L531'>ls</a>                531 src/lua/lparser.cpp   fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */</span>
<span class='curline'><a href='../S/1226.html#L532'>ls</a>                532 src/lua/lparser.cpp   fs-&gt;ls = ls;</span>
<span class='curline'><a href='../S/1226.html#L533'>ls</a>                533 src/lua/lparser.cpp   ls-&gt;fs = fs;</span>
<span class='curline'><a href='../S/1226.html#L543'>ls</a>                543 src/lua/lparser.cpp   fs-&gt;firstlocal = ls-&gt;dyd-&gt;actvar.n;</span>
<span class='curline'><a href='../S/1226.html#L546'>ls</a>                546 src/lua/lparser.cpp   f-&gt;source = ls-&gt;source;</span>
<span class='curline'><a href='../S/1226.html#L552'>ls</a>                552 src/lua/lparser.cpp static void close_func (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L553'>ls</a>                553 src/lua/lparser.cpp   lua_State *L = ls-&gt;L;</span>
<span class='curline'><a href='../S/1226.html#L554'>ls</a>                554 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L571'>ls</a>                571 src/lua/lparser.cpp   ls-&gt;fs = fs-&gt;prev;</span>
<span class='curline'><a href='../S/1226.html#L587'>ls</a>                587 src/lua/lparser.cpp static int block_follow (LexState *ls, int withuntil) {</span>
<span class='curline'><a href='../S/1226.html#L588'>ls</a>                588 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L598'>ls</a>                598 src/lua/lparser.cpp static void statlist (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L600'>ls</a>                600 src/lua/lparser.cpp   while (!block_follow(ls, 1)) {</span>
<span class='curline'><a href='../S/1226.html#L601'>ls</a>                601 src/lua/lparser.cpp     if (ls-&gt;t.token == TK_RETURN) {</span>
<span class='curline'><a href='../S/1226.html#L602'>ls</a>                602 src/lua/lparser.cpp       statement(ls);</span>
<span class='curline'><a href='../S/1226.html#L605'>ls</a>                605 src/lua/lparser.cpp     statement(ls);</span>
<span class='curline'><a href='../S/1226.html#L610'>ls</a>                610 src/lua/lparser.cpp static void fieldsel (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L612'>ls</a>                612 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L615'>ls</a>                615 src/lua/lparser.cpp   luaX_next(ls);  /* skip the dot or colon */</span>
<span class='curline'><a href='../S/1226.html#L616'>ls</a>                616 src/lua/lparser.cpp   checkname(ls, &amp;key);</span>
<span class='curline'><a href='../S/1226.html#L621'>ls</a>                621 src/lua/lparser.cpp static void yindex (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L623'>ls</a>                623 src/lua/lparser.cpp   luaX_next(ls);  /* skip the '[' */</span>
<span class='curline'><a href='../S/1226.html#L624'>ls</a>                624 src/lua/lparser.cpp   expr(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L625'>ls</a>                625 src/lua/lparser.cpp   luaK_exp2val(ls-&gt;fs, v);</span>
<span class='curline'><a href='../S/1226.html#L626'>ls</a>                626 src/lua/lparser.cpp   checknext(ls, ']');</span>
<span class='curline'><a href='../S/1226.html#L646'>ls</a>                646 src/lua/lparser.cpp static void recfield (LexState *ls, struct ConsControl *cc) {</span>
<span class='curline'><a href='../S/1226.html#L648'>ls</a>                648 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L649'>ls</a>                649 src/lua/lparser.cpp   int reg = ls-&gt;fs-&gt;freereg;</span>
<span class='curline'><a href='../S/1226.html#L652'>ls</a>                652 src/lua/lparser.cpp   if (ls-&gt;t.token == TK_NAME) {</span>
<span class='curline'><a href='../S/1226.html#L654'>ls</a>                654 src/lua/lparser.cpp     checkname(ls, &amp;key);</span>
<span class='curline'><a href='../S/1226.html#L657'>ls</a>                657 src/lua/lparser.cpp     yindex(ls, &amp;key);</span>
<span class='curline'><a href='../S/1226.html#L659'>ls</a>                659 src/lua/lparser.cpp   checknext(ls, '=');</span>
<span class='curline'><a href='../S/1226.html#L661'>ls</a>                661 src/lua/lparser.cpp   expr(ls, &amp;val);</span>
<span class='curline'><a href='../S/1226.html#L693'>ls</a>                693 src/lua/lparser.cpp static void listfield (LexState *ls, struct ConsControl *cc) {</span>
<span class='curline'><a href='../S/1226.html#L695'>ls</a>                695 src/lua/lparser.cpp   expr(ls, &amp;cc-&gt;v);</span>
<span class='curline'><a href='../S/1226.html#L696'>ls</a>                696 src/lua/lparser.cpp   checklimit(ls-&gt;fs, cc-&gt;na, MAX_INT, "items in a constructor");</span>
<span class='curline'><a href='../S/1226.html#L702'>ls</a>                702 src/lua/lparser.cpp static void field (LexState *ls, struct ConsControl *cc) {</span>
<span class='curline'><a href='../S/1226.html#L704'>ls</a>                704 src/lua/lparser.cpp   switch(ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L706'>ls</a>                706 src/lua/lparser.cpp       if (luaX_lookahead(ls) != '=')  /* expression? */</span>
<span class='curline'><a href='../S/1226.html#L707'>ls</a>                707 src/lua/lparser.cpp         listfield(ls, cc);</span>
<span class='curline'><a href='../S/1226.html#L709'>ls</a>                709 src/lua/lparser.cpp         recfield(ls, cc);</span>
<span class='curline'><a href='../S/1226.html#L713'>ls</a>                713 src/lua/lparser.cpp       recfield(ls, cc);</span>
<span class='curline'><a href='../S/1226.html#L717'>ls</a>                717 src/lua/lparser.cpp       listfield(ls, cc);</span>
<span class='curline'><a href='../S/1226.html#L724'>ls</a>                724 src/lua/lparser.cpp static void constructor (LexState *ls, expdesc *t) {</span>
<span class='curline'><a href='../S/1226.html#L727'>ls</a>                727 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L728'>ls</a>                728 src/lua/lparser.cpp   int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L735'>ls</a>                735 src/lua/lparser.cpp   luaK_exp2nextreg(ls-&gt;fs, t);  /* fix it at stack top */</span>
<span class='curline'><a href='../S/1226.html#L736'>ls</a>                736 src/lua/lparser.cpp   checknext(ls, '{');</span>
<span class='curline'><a href='../S/1226.html#L739'>ls</a>                739 src/lua/lparser.cpp     if (ls-&gt;t.token == '}') break;</span>
<span class='curline'><a href='../S/1226.html#L741'>ls</a>                741 src/lua/lparser.cpp     field(ls, &amp;cc);</span>
<span class='curline'><a href='../S/1226.html#L742'>ls</a>                742 src/lua/lparser.cpp   } while (testnext(ls, ',') || testnext(ls, ';'));</span>
<span class='curline'><a href='../S/1226.html#L743'>ls</a>                743 src/lua/lparser.cpp   check_match(ls, '}', '{', line);</span>
<span class='curline'><a href='../S/1226.html#L753'>ls</a>                753 src/lua/lparser.cpp static void parlist (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L755'>ls</a>                755 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L759'>ls</a>                759 src/lua/lparser.cpp   if (ls-&gt;t.token != ')') {  /* is 'parlist' not empty? */</span>
<span class='curline'><a href='../S/1226.html#L761'>ls</a>                761 src/lua/lparser.cpp       switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L763'>ls</a>                763 src/lua/lparser.cpp           new_localvar(ls, str_checkname(ls));</span>
<span class='curline'><a href='../S/1226.html#L768'>ls</a>                768 src/lua/lparser.cpp           luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L772'>ls</a>                772 src/lua/lparser.cpp         default: luaX_syntaxerror(ls, "&lt;name&gt; or '...' expected");</span>
<span class='curline'><a href='../S/1226.html#L774'>ls</a>                774 src/lua/lparser.cpp     } while (!f-&gt;is_vararg &amp;&amp; testnext(ls, ','));</span>
<span class='curline'><a href='../S/1226.html#L776'>ls</a>                776 src/lua/lparser.cpp   adjustlocalvars(ls, nparams);</span>
<span class='curline'><a href='../S/1226.html#L782'>ls</a>                782 src/lua/lparser.cpp static void body (LexState *ls, expdesc *e, int ismethod, int line) {</span>
<span class='curline'><a href='../S/1226.html#L786'>ls</a>                786 src/lua/lparser.cpp   new_fs.f = addprototype(ls);</span>
<span class='curline'><a href='../S/1226.html#L788'>ls</a>                788 src/lua/lparser.cpp   open_func(ls, &amp;new_fs, &amp;bl);</span>
<span class='curline'><a href='../S/1226.html#L789'>ls</a>                789 src/lua/lparser.cpp   checknext(ls, '(');</span>
<span class='curline'><a href='../S/1226.html#L791'>ls</a>                791 src/lua/lparser.cpp     new_localvarliteral(ls, "self");  /* create 'self' parameter */</span>
<span class='curline'><a href='../S/1226.html#L792'>ls</a>                792 src/lua/lparser.cpp     adjustlocalvars(ls, 1);</span>
<span class='curline'><a href='../S/1226.html#L794'>ls</a>                794 src/lua/lparser.cpp   parlist(ls);</span>
<span class='curline'><a href='../S/1226.html#L795'>ls</a>                795 src/lua/lparser.cpp   checknext(ls, ')');</span>
<span class='curline'><a href='../S/1226.html#L796'>ls</a>                796 src/lua/lparser.cpp   statlist(ls);</span>
<span class='curline'><a href='../S/1226.html#L797'>ls</a>                797 src/lua/lparser.cpp   new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L798'>ls</a>                798 src/lua/lparser.cpp   check_match(ls, TK_END, TK_FUNCTION, line);</span>
<span class='curline'><a href='../S/1226.html#L799'>ls</a>                799 src/lua/lparser.cpp   codeclosure(ls, e);</span>
<span class='curline'><a href='../S/1226.html#L800'>ls</a>                800 src/lua/lparser.cpp   close_func(ls);</span>
<span class='curline'><a href='../S/1226.html#L804'>ls</a>                804 src/lua/lparser.cpp static int explist (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L807'>ls</a>                807 src/lua/lparser.cpp   expr(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L808'>ls</a>                808 src/lua/lparser.cpp   while (testnext(ls, ',')) {</span>
<span class='curline'><a href='../S/1226.html#L809'>ls</a>                809 src/lua/lparser.cpp     luaK_exp2nextreg(ls-&gt;fs, v);</span>
<span class='curline'><a href='../S/1226.html#L810'>ls</a>                810 src/lua/lparser.cpp     expr(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L817'>ls</a>                817 src/lua/lparser.cpp static void funcargs (LexState *ls, expdesc *f, int line) {</span>
<span class='curline'><a href='../S/1226.html#L818'>ls</a>                818 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L821'>ls</a>                821 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L823'>ls</a>                823 src/lua/lparser.cpp       luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L824'>ls</a>                824 src/lua/lparser.cpp       if (ls-&gt;t.token == ')')  /* arg list is empty? */</span>
<span class='curline'><a href='../S/1226.html#L827'>ls</a>                827 src/lua/lparser.cpp         explist(ls, &amp;args);</span>
<span class='curline'><a href='../S/1226.html#L830'>ls</a>                830 src/lua/lparser.cpp       check_match(ls, ')', '(', line);</span>
<span class='curline'><a href='../S/1226.html#L834'>ls</a>                834 src/lua/lparser.cpp       constructor(ls, &amp;args);</span>
<span class='curline'><a href='../S/1226.html#L838'>ls</a>                838 src/lua/lparser.cpp       codestring(ls, &amp;args, ls-&gt;t.seminfo.ts);</span>
<span class='curline'><a href='../S/1226.html#L839'>ls</a>                839 src/lua/lparser.cpp       luaX_next(ls);  /* must use 'seminfo' before 'next' */</span>
<span class='curline'><a href='../S/1226.html#L843'>ls</a>                843 src/lua/lparser.cpp       luaX_syntaxerror(ls, "function arguments expected");</span>
<span class='curline'><a href='../S/1226.html#L871'>ls</a>                871 src/lua/lparser.cpp static void primaryexp (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L873'>ls</a>                873 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L875'>ls</a>                875 src/lua/lparser.cpp       int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L876'>ls</a>                876 src/lua/lparser.cpp       luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L877'>ls</a>                877 src/lua/lparser.cpp       expr(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L878'>ls</a>                878 src/lua/lparser.cpp       check_match(ls, ')', '(', line);</span>
<span class='curline'><a href='../S/1226.html#L879'>ls</a>                879 src/lua/lparser.cpp       luaK_dischargevars(ls-&gt;fs, v);</span>
<span class='curline'><a href='../S/1226.html#L883'>ls</a>                883 src/lua/lparser.cpp       singlevar(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L887'>ls</a>                887 src/lua/lparser.cpp       luaX_syntaxerror(ls, "unexpected symbol");</span>
<span class='curline'><a href='../S/1226.html#L893'>ls</a>                893 src/lua/lparser.cpp static void suffixedexp (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L896'>ls</a>                896 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L897'>ls</a>                897 src/lua/lparser.cpp   int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L898'>ls</a>                898 src/lua/lparser.cpp   primaryexp(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L900'>ls</a>                900 src/lua/lparser.cpp     switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L902'>ls</a>                902 src/lua/lparser.cpp         fieldsel(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L908'>ls</a>                908 src/lua/lparser.cpp         yindex(ls, &amp;key);</span>
<span class='curline'><a href='../S/1226.html#L914'>ls</a>                914 src/lua/lparser.cpp         luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L915'>ls</a>                915 src/lua/lparser.cpp         checkname(ls, &amp;key);</span>
<span class='curline'><a href='../S/1226.html#L917'>ls</a>                917 src/lua/lparser.cpp         funcargs(ls, v, line);</span>
<span class='curline'><a href='../S/1226.html#L922'>ls</a>                922 src/lua/lparser.cpp         funcargs(ls, v, line);</span>
<span class='curline'><a href='../S/1226.html#L931'>ls</a>                931 src/lua/lparser.cpp static void simpleexp (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L934'>ls</a>                934 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L937'>ls</a>                937 src/lua/lparser.cpp       v-&gt;u.nval = ls-&gt;t.seminfo.r;</span>
<span class='curline'><a href='../S/1226.html#L942'>ls</a>                942 src/lua/lparser.cpp       v-&gt;u.ival = ls-&gt;t.seminfo.i;</span>
<span class='curline'><a href='../S/1226.html#L946'>ls</a>                946 src/lua/lparser.cpp       codestring(ls, v, ls-&gt;t.seminfo.ts);</span>
<span class='curline'><a href='../S/1226.html#L962'>ls</a>                962 src/lua/lparser.cpp       FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L963'>ls</a>                963 src/lua/lparser.cpp       check_condition(ls, fs-&gt;f-&gt;is_vararg,</span>
<span class='curline'><a href='../S/1226.html#L969'>ls</a>                969 src/lua/lparser.cpp       constructor(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L973'>ls</a>                973 src/lua/lparser.cpp       luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L974'>ls</a>                974 src/lua/lparser.cpp       body(ls, v, 0, ls-&gt;linenumber);</span>
<span class='curline'><a href='../S/1226.html#L978'>ls</a>                978 src/lua/lparser.cpp       suffixedexp(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L982'>ls</a>                982 src/lua/lparser.cpp   luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L1048'>ls</a>               1048 src/lua/lparser.cpp static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {</span>
<span class='curline'><a href='../S/1226.html#L1051'>ls</a>               1051 src/lua/lparser.cpp   enterlevel(ls);</span>
<span class='curline'><a href='../S/1226.html#L1052'>ls</a>               1052 src/lua/lparser.cpp   uop = getunopr(ls-&gt;t.token);</span>
<span class='curline'><a href='../S/1226.html#L1054'>ls</a>               1054 src/lua/lparser.cpp     int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L1055'>ls</a>               1055 src/lua/lparser.cpp     luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L1056'>ls</a>               1056 src/lua/lparser.cpp     subexpr(ls, v, UNARY_PRIORITY);</span>
<span class='curline'><a href='../S/1226.html#L1057'>ls</a>               1057 src/lua/lparser.cpp     luaK_prefix(ls-&gt;fs, uop, v, line);</span>
<span class='curline'><a href='../S/1226.html#L1059'>ls</a>               1059 src/lua/lparser.cpp   else simpleexp(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L1061'>ls</a>               1061 src/lua/lparser.cpp   op = getbinopr(ls-&gt;t.token);</span>
<span class='curline'><a href='../S/1226.html#L1065'>ls</a>               1065 src/lua/lparser.cpp     int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L1066'>ls</a>               1066 src/lua/lparser.cpp     luaX_next(ls);</span>
<span class='curline'><a href='../S/1226.html#L1067'>ls</a>               1067 src/lua/lparser.cpp     luaK_infix(ls-&gt;fs, op, v);</span>
<span class='curline'><a href='../S/1226.html#L1069'>ls</a>               1069 src/lua/lparser.cpp     nextop = subexpr(ls, &amp;v2, priority[op].right);</span>
<span class='curline'><a href='../S/1226.html#L1070'>ls</a>               1070 src/lua/lparser.cpp     luaK_posfix(ls-&gt;fs, op, v, &amp;v2, line);</span>
<span class='curline'><a href='../S/1226.html#L1073'>ls</a>               1073 src/lua/lparser.cpp   leavelevel(ls);</span>
<span class='curline'><a href='../S/1226.html#L1078'>ls</a>               1078 src/lua/lparser.cpp static void expr (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L1079'>ls</a>               1079 src/lua/lparser.cpp   subexpr(ls, v, 0);</span>
<span class='curline'><a href='../S/1226.html#L1093'>ls</a>               1093 src/lua/lparser.cpp static void block (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1095'>ls</a>               1095 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1098'>ls</a>               1098 src/lua/lparser.cpp   statlist(ls);</span>
<span class='curline'><a href='../S/1226.html#L1119'>ls</a>               1119 src/lua/lparser.cpp static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L1120'>ls</a>               1120 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1147'>ls</a>               1147 src/lua/lparser.cpp static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {</span>
<span class='curline'><a href='../S/1226.html#L1149'>ls</a>               1149 src/lua/lparser.cpp   check_condition(ls, vkisvar(lh-&gt;v.k), "syntax error");</span>
<span class='curline'><a href='../S/1226.html#L1150'>ls</a>               1150 src/lua/lparser.cpp   if (testnext(ls, ',')) {  /* assignment -&gt; ',' suffixedexp assignment */</span>
<span class='curline'><a href='../S/1226.html#L1153'>ls</a>               1153 src/lua/lparser.cpp     suffixedexp(ls, &amp;nv.v);</span>
<span class='curline'><a href='../S/1226.html#L1155'>ls</a>               1155 src/lua/lparser.cpp       check_conflict(ls, lh, &amp;nv.v);</span>
<span class='curline'><a href='../S/1226.html#L1156'>ls</a>               1156 src/lua/lparser.cpp     checklimit(ls-&gt;fs, nvars + ls-&gt;L-&gt;nCcalls, LUAI_MAXCCALLS,</span>
<span class='curline'><a href='../S/1226.html#L1158'>ls</a>               1158 src/lua/lparser.cpp     assignment(ls, &amp;nv, nvars+1);</span>
<span class='curline'><a href='../S/1226.html#L1162'>ls</a>               1162 src/lua/lparser.cpp     checknext(ls, '=');</span>
<span class='curline'><a href='../S/1226.html#L1163'>ls</a>               1163 src/lua/lparser.cpp     nexps = explist(ls, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1165'>ls</a>               1165 src/lua/lparser.cpp       adjust_assign(ls, nvars, nexps, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1167'>ls</a>               1167 src/lua/lparser.cpp       luaK_setoneret(ls-&gt;fs, &amp;e);  /* close last expression */</span>
<span class='curline'><a href='../S/1226.html#L1168'>ls</a>               1168 src/lua/lparser.cpp       luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1172'>ls</a>               1172 src/lua/lparser.cpp   init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  /* default assignment */</span>
<span class='curline'><a href='../S/1226.html#L1173'>ls</a>               1173 src/lua/lparser.cpp   luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1177'>ls</a>               1177 src/lua/lparser.cpp static int cond (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1180'>ls</a>               1180 src/lua/lparser.cpp   expr(ls, &amp;v);  /* read condition */</span>
<span class='curline'><a href='../S/1226.html#L1182'>ls</a>               1182 src/lua/lparser.cpp   luaK_goiftrue(ls-&gt;fs, &amp;v);</span>
<span class='curline'><a href='../S/1226.html#L1187'>ls</a>               1187 src/lua/lparser.cpp static void gotostat (LexState *ls, int pc) {</span>
<span class='curline'><a href='../S/1226.html#L1188'>ls</a>               1188 src/lua/lparser.cpp   int line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L1191'>ls</a>               1191 src/lua/lparser.cpp   if (testnext(ls, TK_GOTO))</span>
<span class='curline'><a href='../S/1226.html#L1192'>ls</a>               1192 src/lua/lparser.cpp     label = str_checkname(ls);</span>
<span class='curline'><a href='../S/1226.html#L1194'>ls</a>               1194 src/lua/lparser.cpp     luaX_next(ls);  /* skip break */</span>
<span class='curline'><a href='../S/1226.html#L1195'>ls</a>               1195 src/lua/lparser.cpp     label = luaS_new(ls-&gt;L, "break");</span>
<span class='curline'><a href='../S/1226.html#L1197'>ls</a>               1197 src/lua/lparser.cpp   g = newlabelentry(ls, &amp;ls-&gt;dyd-&gt;gt, label, line, pc);</span>
<span class='curline'><a href='../S/1226.html#L1198'>ls</a>               1198 src/lua/lparser.cpp   findlabel(ls, g);  /* close it if label already defined */</span>
<span class='curline'><a href='../S/1226.html#L1207'>ls</a>               1207 src/lua/lparser.cpp       const char *msg = luaO_pushfstring(fs-&gt;ls-&gt;L,</span>
<span class='curline'><a href='../S/1226.html#L1210'>ls</a>               1210 src/lua/lparser.cpp       semerror(fs-&gt;ls, msg);</span>
<span class='curline'><a href='../S/1226.html#L1217'>ls</a>               1217 src/lua/lparser.cpp static void skipnoopstat (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1218'>ls</a>               1218 src/lua/lparser.cpp   while (ls-&gt;t.token == ';' || ls-&gt;t.token == TK_DBCOLON)</span>
<span class='curline'><a href='../S/1226.html#L1219'>ls</a>               1219 src/lua/lparser.cpp     statement(ls);</span>
<span class='curline'><a href='../S/1226.html#L1223'>ls</a>               1223 src/lua/lparser.cpp static void labelstat (LexState *ls, TString *label, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1225'>ls</a>               1225 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1226'>ls</a>               1226 src/lua/lparser.cpp   Labellist *ll = &amp;ls-&gt;dyd-&gt;label;</span>
<span class='curline'><a href='../S/1226.html#L1229'>ls</a>               1229 src/lua/lparser.cpp   checknext(ls, TK_DBCOLON);  /* skip double colon */</span>
<span class='curline'><a href='../S/1226.html#L1231'>ls</a>               1231 src/lua/lparser.cpp   l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));</span>
<span class='curline'><a href='../S/1226.html#L1232'>ls</a>               1232 src/lua/lparser.cpp   skipnoopstat(ls);  /* skip other no-op statements */</span>
<span class='curline'><a href='../S/1226.html#L1233'>ls</a>               1233 src/lua/lparser.cpp   if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */</span>
<span class='curline'><a href='../S/1226.html#L1237'>ls</a>               1237 src/lua/lparser.cpp   findgotos(ls, &amp;ll-&gt;arr[l]);</span>
<span class='curline'><a href='../S/1226.html#L1241'>ls</a>               1241 src/lua/lparser.cpp static void whilestat (LexState *ls, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1243'>ls</a>               1243 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1247'>ls</a>               1247 src/lua/lparser.cpp   luaX_next(ls);  /* skip WHILE */</span>
<span class='curline'><a href='../S/1226.html#L1249'>ls</a>               1249 src/lua/lparser.cpp   condexit = cond(ls);</span>
<span class='curline'><a href='../S/1226.html#L1251'>ls</a>               1251 src/lua/lparser.cpp   checknext(ls, TK_DO);</span>
<span class='curline'><a href='../S/1226.html#L1252'>ls</a>               1252 src/lua/lparser.cpp   block(ls);</span>
<span class='curline'><a href='../S/1226.html#L1254'>ls</a>               1254 src/lua/lparser.cpp   check_match(ls, TK_END, TK_WHILE, line);</span>
<span class='curline'><a href='../S/1226.html#L1260'>ls</a>               1260 src/lua/lparser.cpp static void repeatstat (LexState *ls, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1263'>ls</a>               1263 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1268'>ls</a>               1268 src/lua/lparser.cpp   luaX_next(ls);  /* skip REPEAT */</span>
<span class='curline'><a href='../S/1226.html#L1269'>ls</a>               1269 src/lua/lparser.cpp   statlist(ls);</span>
<span class='curline'><a href='../S/1226.html#L1270'>ls</a>               1270 src/lua/lparser.cpp   check_match(ls, TK_UNTIL, TK_REPEAT, line);</span>
<span class='curline'><a href='../S/1226.html#L1271'>ls</a>               1271 src/lua/lparser.cpp   condexit = cond(ls);  /* read condition (inside scope block) */</span>
<span class='curline'><a href='../S/1226.html#L1280'>ls</a>               1280 src/lua/lparser.cpp static int exp1 (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1283'>ls</a>               1283 src/lua/lparser.cpp   expr(ls, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1284'>ls</a>               1284 src/lua/lparser.cpp   luaK_exp2nextreg(ls-&gt;fs, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1291'>ls</a>               1291 src/lua/lparser.cpp static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {</span>
<span class='curline'><a href='../S/1226.html#L1294'>ls</a>               1294 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1296'>ls</a>               1296 src/lua/lparser.cpp   adjustlocalvars(ls, 3);  /* control variables */</span>
<span class='curline'><a href='../S/1226.html#L1297'>ls</a>               1297 src/lua/lparser.cpp   checknext(ls, TK_DO);</span>
<span class='curline'><a href='../S/1226.html#L1300'>ls</a>               1300 src/lua/lparser.cpp   adjustlocalvars(ls, nvars);</span>
<span class='curline'><a href='../S/1226.html#L1302'>ls</a>               1302 src/lua/lparser.cpp   block(ls);</span>
<span class='curline'><a href='../S/1226.html#L1317'>ls</a>               1317 src/lua/lparser.cpp static void fornum (LexState *ls, TString *varname, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1319'>ls</a>               1319 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1321'>ls</a>               1321 src/lua/lparser.cpp   new_localvarliteral(ls, "(for index)");</span>
<span class='curline'><a href='../S/1226.html#L1322'>ls</a>               1322 src/lua/lparser.cpp   new_localvarliteral(ls, "(for limit)");</span>
<span class='curline'><a href='../S/1226.html#L1323'>ls</a>               1323 src/lua/lparser.cpp   new_localvarliteral(ls, "(for step)");</span>
<span class='curline'><a href='../S/1226.html#L1324'>ls</a>               1324 src/lua/lparser.cpp   new_localvar(ls, varname);</span>
<span class='curline'><a href='../S/1226.html#L1325'>ls</a>               1325 src/lua/lparser.cpp   checknext(ls, '=');</span>
<span class='curline'><a href='../S/1226.html#L1326'>ls</a>               1326 src/lua/lparser.cpp   exp1(ls);  /* initial value */</span>
<span class='curline'><a href='../S/1226.html#L1327'>ls</a>               1327 src/lua/lparser.cpp   checknext(ls, ',');</span>
<span class='curline'><a href='../S/1226.html#L1328'>ls</a>               1328 src/lua/lparser.cpp   exp1(ls);  /* limit */</span>
<span class='curline'><a href='../S/1226.html#L1329'>ls</a>               1329 src/lua/lparser.cpp   if (testnext(ls, ','))</span>
<span class='curline'><a href='../S/1226.html#L1330'>ls</a>               1330 src/lua/lparser.cpp     exp1(ls);  /* optional step */</span>
<span class='curline'><a href='../S/1226.html#L1335'>ls</a>               1335 src/lua/lparser.cpp   forbody(ls, base, line, 1, 1);</span>
<span class='curline'><a href='../S/1226.html#L1339'>ls</a>               1339 src/lua/lparser.cpp static void forlist (LexState *ls, TString *indexname) {</span>
<span class='curline'><a href='../S/1226.html#L1341'>ls</a>               1341 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1347'>ls</a>               1347 src/lua/lparser.cpp   new_localvarliteral(ls, "(for generator)");</span>
<span class='curline'><a href='../S/1226.html#L1348'>ls</a>               1348 src/lua/lparser.cpp   new_localvarliteral(ls, "(for state)");</span>
<span class='curline'><a href='../S/1226.html#L1349'>ls</a>               1349 src/lua/lparser.cpp   new_localvarliteral(ls, "(for control)");</span>
<span class='curline'><a href='../S/1226.html#L1351'>ls</a>               1351 src/lua/lparser.cpp   new_localvar(ls, indexname);</span>
<span class='curline'><a href='../S/1226.html#L1352'>ls</a>               1352 src/lua/lparser.cpp   while (testnext(ls, ',')) {</span>
<span class='curline'><a href='../S/1226.html#L1353'>ls</a>               1353 src/lua/lparser.cpp     new_localvar(ls, str_checkname(ls));</span>
<span class='curline'><a href='../S/1226.html#L1356'>ls</a>               1356 src/lua/lparser.cpp   checknext(ls, TK_IN);</span>
<span class='curline'><a href='../S/1226.html#L1357'>ls</a>               1357 src/lua/lparser.cpp   line = ls-&gt;linenumber;</span>
<span class='curline'><a href='../S/1226.html#L1358'>ls</a>               1358 src/lua/lparser.cpp   adjust_assign(ls, 3, explist(ls, &amp;e), &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1360'>ls</a>               1360 src/lua/lparser.cpp   forbody(ls, base, line, nvars - 3, 0);</span>
<span class='curline'><a href='../S/1226.html#L1364'>ls</a>               1364 src/lua/lparser.cpp static void forstat (LexState *ls, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1366'>ls</a>               1366 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1370'>ls</a>               1370 src/lua/lparser.cpp   luaX_next(ls);  /* skip 'for' */</span>
<span class='curline'><a href='../S/1226.html#L1371'>ls</a>               1371 src/lua/lparser.cpp   varname = str_checkname(ls);  /* first variable name */</span>
<span class='curline'><a href='../S/1226.html#L1372'>ls</a>               1372 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L1373'>ls</a>               1373 src/lua/lparser.cpp     case '=': fornum(ls, varname, line); break;</span>
<span class='curline'><a href='../S/1226.html#L1374'>ls</a>               1374 src/lua/lparser.cpp     case ',': case TK_IN: forlist(ls, varname); break;</span>
<span class='curline'><a href='../S/1226.html#L1375'>ls</a>               1375 src/lua/lparser.cpp     default: luaX_syntaxerror(ls, "'=' or 'in' expected");</span>
<span class='curline'><a href='../S/1226.html#L1377'>ls</a>               1377 src/lua/lparser.cpp   check_match(ls, TK_END, TK_FOR, line);</span>
<span class='curline'><a href='../S/1226.html#L1382'>ls</a>               1382 src/lua/lparser.cpp static void test_then_block (LexState *ls, int *escapelist) {</span>
<span class='curline'><a href='../S/1226.html#L1385'>ls</a>               1385 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1388'>ls</a>               1388 src/lua/lparser.cpp   luaX_next(ls);  /* skip IF or ELSEIF */</span>
<span class='curline'><a href='../S/1226.html#L1389'>ls</a>               1389 src/lua/lparser.cpp   expr(ls, &amp;v);  /* read condition */</span>
<span class='curline'><a href='../S/1226.html#L1390'>ls</a>               1390 src/lua/lparser.cpp   checknext(ls, TK_THEN);</span>
<span class='curline'><a href='../S/1226.html#L1391'>ls</a>               1391 src/lua/lparser.cpp   if (ls-&gt;t.token == TK_GOTO || ls-&gt;t.token == TK_BREAK) {</span>
<span class='curline'><a href='../S/1226.html#L1392'>ls</a>               1392 src/lua/lparser.cpp     luaK_goiffalse(ls-&gt;fs, &amp;v);  /* will jump to label if condition is true */</span>
<span class='curline'><a href='../S/1226.html#L1394'>ls</a>               1394 src/lua/lparser.cpp     gotostat(ls, v.t);  /* handle goto/break */</span>
<span class='curline'><a href='../S/1226.html#L1395'>ls</a>               1395 src/lua/lparser.cpp     while (testnext(ls, ';')) {}  /* skip semicolons */</span>
<span class='curline'><a href='../S/1226.html#L1396'>ls</a>               1396 src/lua/lparser.cpp     if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */</span>
<span class='curline'><a href='../S/1226.html#L1404'>ls</a>               1404 src/lua/lparser.cpp     luaK_goiftrue(ls-&gt;fs, &amp;v);  /* skip over block if condition is false */</span>
<span class='curline'><a href='../S/1226.html#L1408'>ls</a>               1408 src/lua/lparser.cpp   statlist(ls);  /* 'then' part */</span>
<span class='curline'><a href='../S/1226.html#L1410'>ls</a>               1410 src/lua/lparser.cpp   if (ls-&gt;t.token == TK_ELSE ||</span>
<span class='curline'><a href='../S/1226.html#L1411'>ls</a>               1411 src/lua/lparser.cpp       ls-&gt;t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */</span>
<span class='curline'><a href='../S/1226.html#L1417'>ls</a>               1417 src/lua/lparser.cpp static void ifstat (LexState *ls, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1419'>ls</a>               1419 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1421'>ls</a>               1421 src/lua/lparser.cpp   test_then_block(ls, &amp;escapelist);  /* IF cond THEN block */</span>
<span class='curline'><a href='../S/1226.html#L1422'>ls</a>               1422 src/lua/lparser.cpp   while (ls-&gt;t.token == TK_ELSEIF)</span>
<span class='curline'><a href='../S/1226.html#L1423'>ls</a>               1423 src/lua/lparser.cpp     test_then_block(ls, &amp;escapelist);  /* ELSEIF cond THEN block */</span>
<span class='curline'><a href='../S/1226.html#L1424'>ls</a>               1424 src/lua/lparser.cpp   if (testnext(ls, TK_ELSE))</span>
<span class='curline'><a href='../S/1226.html#L1425'>ls</a>               1425 src/lua/lparser.cpp     block(ls);  /* 'else' part */</span>
<span class='curline'><a href='../S/1226.html#L1426'>ls</a>               1426 src/lua/lparser.cpp   check_match(ls, TK_END, TK_IF, line);</span>
<span class='curline'><a href='../S/1226.html#L1431'>ls</a>               1431 src/lua/lparser.cpp static void localfunc (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1433'>ls</a>               1433 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1434'>ls</a>               1434 src/lua/lparser.cpp   new_localvar(ls, str_checkname(ls));  /* new local variable */</span>
<span class='curline'><a href='../S/1226.html#L1435'>ls</a>               1435 src/lua/lparser.cpp   adjustlocalvars(ls, 1);  /* enter its scope */</span>
<span class='curline'><a href='../S/1226.html#L1436'>ls</a>               1436 src/lua/lparser.cpp   body(ls, &amp;b, 0, ls-&gt;linenumber);  /* function created in next register */</span>
<span class='curline'><a href='../S/1226.html#L1442'>ls</a>               1442 src/lua/lparser.cpp static void localstat (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1448'>ls</a>               1448 src/lua/lparser.cpp     new_localvar(ls, str_checkname(ls));</span>
<span class='curline'><a href='../S/1226.html#L1450'>ls</a>               1450 src/lua/lparser.cpp   } while (testnext(ls, ','));</span>
<span class='curline'><a href='../S/1226.html#L1451'>ls</a>               1451 src/lua/lparser.cpp   if (testnext(ls, '='))</span>
<span class='curline'><a href='../S/1226.html#L1452'>ls</a>               1452 src/lua/lparser.cpp     nexps = explist(ls, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1457'>ls</a>               1457 src/lua/lparser.cpp   adjust_assign(ls, nvars, nexps, &amp;e);</span>
<span class='curline'><a href='../S/1226.html#L1458'>ls</a>               1458 src/lua/lparser.cpp   adjustlocalvars(ls, nvars);</span>
<span class='curline'><a href='../S/1226.html#L1462'>ls</a>               1462 src/lua/lparser.cpp static int funcname (LexState *ls, expdesc *v) {</span>
<span class='curline'><a href='../S/1226.html#L1465'>ls</a>               1465 src/lua/lparser.cpp   singlevar(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L1466'>ls</a>               1466 src/lua/lparser.cpp   while (ls-&gt;t.token == '.')</span>
<span class='curline'><a href='../S/1226.html#L1467'>ls</a>               1467 src/lua/lparser.cpp     fieldsel(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L1468'>ls</a>               1468 src/lua/lparser.cpp   if (ls-&gt;t.token == ':') {</span>
<span class='curline'><a href='../S/1226.html#L1470'>ls</a>               1470 src/lua/lparser.cpp     fieldsel(ls, v);</span>
<span class='curline'><a href='../S/1226.html#L1476'>ls</a>               1476 src/lua/lparser.cpp static void funcstat (LexState *ls, int line) {</span>
<span class='curline'><a href='../S/1226.html#L1480'>ls</a>               1480 src/lua/lparser.cpp   luaX_next(ls);  /* skip FUNCTION */</span>
<span class='curline'><a href='../S/1226.html#L1481'>ls</a>               1481 src/lua/lparser.cpp   ismethod = funcname(ls, &amp;v);</span>
<span class='curline'><a href='../S/1226.html#L1482'>ls</a>               1482 src/lua/lparser.cpp   body(ls, &amp;b, ismethod, line);</span>
<span class='curline'><a href='../S/1226.html#L1483'>ls</a>               1483 src/lua/lparser.cpp   luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);</span>
<span class='curline'><a href='../S/1226.html#L1484'>ls</a>               1484 src/lua/lparser.cpp   luaK_fixline(ls-&gt;fs, line);  /* definition "happens" in the first line */</span>
<span class='curline'><a href='../S/1226.html#L1488'>ls</a>               1488 src/lua/lparser.cpp static void exprstat (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1490'>ls</a>               1490 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1492'>ls</a>               1492 src/lua/lparser.cpp   suffixedexp(ls, &amp;v.v);</span>
<span class='curline'><a href='../S/1226.html#L1493'>ls</a>               1493 src/lua/lparser.cpp   if (ls-&gt;t.token == '=' || ls-&gt;t.token == ',') { /* stat -&gt; assignment ? */</span>
<span class='curline'><a href='../S/1226.html#L1495'>ls</a>               1495 src/lua/lparser.cpp     assignment(ls, &amp;v, 1);</span>
<span class='curline'><a href='../S/1226.html#L1498'>ls</a>               1498 src/lua/lparser.cpp     check_condition(ls, v.v.k == VCALL, "syntax error");</span>
<span class='curline'><a href='../S/1226.html#L1504'>ls</a>               1504 src/lua/lparser.cpp static void retstat (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1506'>ls</a>               1506 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs;</span>
<span class='curline'><a href='../S/1226.html#L1509'>ls</a>               1509 src/lua/lparser.cpp   if (block_follow(ls, 1) || ls-&gt;t.token == ';')</span>
<span class='curline'><a href='../S/1226.html#L1512'>ls</a>               1512 src/lua/lparser.cpp     nret = explist(ls, &amp;e);  /* optional return values */</span>
<span class='curline'><a href='../S/1226.html#L1533'>ls</a>               1533 src/lua/lparser.cpp   testnext(ls, ';');  /* skip optional semicolon */</span>
<span class='curline'><a href='../S/1226.html#L1537'>ls</a>               1537 src/lua/lparser.cpp static void statement (LexState *ls) {</span>
<span class='curline'><a href='../S/1226.html#L1538'>ls</a>               1538 src/lua/lparser.cpp   int line = ls-&gt;linenumber;  /* may be needed for error messages */</span>
<span class='curline'><a href='../S/1226.html#L1539'>ls</a>               1539 src/lua/lparser.cpp   enterlevel(ls);</span>
<span class='curline'><a href='../S/1226.html#L1540'>ls</a>               1540 src/lua/lparser.cpp   switch (ls-&gt;t.token) {</span>
<span class='curline'><a href='../S/1226.html#L1542'>ls</a>               1542 src/lua/lparser.cpp       luaX_next(ls);  /* skip ';' */</span>
<span class='curline'><a href='../S/1226.html#L1546'>ls</a>               1546 src/lua/lparser.cpp       ifstat(ls, line);</span>
<span class='curline'><a href='../S/1226.html#L1550'>ls</a>               1550 src/lua/lparser.cpp       whilestat(ls, line);</span>
<span class='curline'><a href='../S/1226.html#L1554'>ls</a>               1554 src/lua/lparser.cpp       luaX_next(ls);  /* skip DO */</span>
<span class='curline'><a href='../S/1226.html#L1555'>ls</a>               1555 src/lua/lparser.cpp       block(ls);</span>
<span class='curline'><a href='../S/1226.html#L1556'>ls</a>               1556 src/lua/lparser.cpp       check_match(ls, TK_END, TK_DO, line);</span>
<span class='curline'><a href='../S/1226.html#L1560'>ls</a>               1560 src/lua/lparser.cpp       forstat(ls, line);</span>
<span class='curline'><a href='../S/1226.html#L1564'>ls</a>               1564 src/lua/lparser.cpp       repeatstat(ls, line);</span>
<span class='curline'><a href='../S/1226.html#L1568'>ls</a>               1568 src/lua/lparser.cpp       funcstat(ls, line);</span>
<span class='curline'><a href='../S/1226.html#L1572'>ls</a>               1572 src/lua/lparser.cpp       luaX_next(ls);  /* skip LOCAL */</span>
<span class='curline'><a href='../S/1226.html#L1573'>ls</a>               1573 src/lua/lparser.cpp       if (testnext(ls, TK_FUNCTION))  /* local function? */</span>
<span class='curline'><a href='../S/1226.html#L1574'>ls</a>               1574 src/lua/lparser.cpp         localfunc(ls);</span>
<span class='curline'><a href='../S/1226.html#L1576'>ls</a>               1576 src/lua/lparser.cpp         localstat(ls);</span>
<span class='curline'><a href='../S/1226.html#L1580'>ls</a>               1580 src/lua/lparser.cpp       luaX_next(ls);  /* skip double colon */</span>
<span class='curline'><a href='../S/1226.html#L1581'>ls</a>               1581 src/lua/lparser.cpp       labelstat(ls, str_checkname(ls), line);</span>
<span class='curline'><a href='../S/1226.html#L1585'>ls</a>               1585 src/lua/lparser.cpp       luaX_next(ls);  /* skip RETURN */</span>
<span class='curline'><a href='../S/1226.html#L1586'>ls</a>               1586 src/lua/lparser.cpp       retstat(ls);</span>
<span class='curline'><a href='../S/1226.html#L1591'>ls</a>               1591 src/lua/lparser.cpp       gotostat(ls, luaK_jump(ls-&gt;fs));</span>
<span class='curline'><a href='../S/1226.html#L1595'>ls</a>               1595 src/lua/lparser.cpp       exprstat(ls);</span>
<span class='curline'><a href='../S/1226.html#L1599'>ls</a>               1599 src/lua/lparser.cpp   lua_assert(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;</span>
<span class='curline'><a href='../S/1226.html#L1600'>ls</a>               1600 src/lua/lparser.cpp              ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);</span>
<span class='curline'><a href='../S/1226.html#L1601'>ls</a>               1601 src/lua/lparser.cpp   ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  /* free registers */</span>
<span class='curline'><a href='../S/1226.html#L1602'>ls</a>               1602 src/lua/lparser.cpp   leavelevel(ls);</span>
<span class='curline'><a href='../S/1226.html#L1612'>ls</a>               1612 src/lua/lparser.cpp static void mainfunc (LexState *ls, FuncState *fs) {</span>
<span class='curline'><a href='../S/1226.html#L1615'>ls</a>               1615 src/lua/lparser.cpp   open_func(ls, fs, &amp;bl);</span>
<span class='curline'><a href='../S/1226.html#L1618'>ls</a>               1618 src/lua/lparser.cpp   newupvalue(fs, ls-&gt;envn, &amp;v);  /* ...set environment upvalue */</span>
<span class='curline'><a href='../S/1226.html#L1619'>ls</a>               1619 src/lua/lparser.cpp   luaX_next(ls);  /* read first token */</span>
<span class='curline'><a href='../S/1226.html#L1620'>ls</a>               1620 src/lua/lparser.cpp   statlist(ls);  /* parse main body */</span>
<span class='curline'><a href='../S/1226.html#L1621'>ls</a>               1621 src/lua/lparser.cpp   check(ls, TK_EOS);</span>
<span class='curline'><a href='../S/1226.html#L1622'>ls</a>               1622 src/lua/lparser.cpp   close_func(ls);</span>
<span class='curline'><a href='../S/1183.html#L114'>ls</a>                114 src/lua/lparser.h   struct LexState *ls;  /* lexical state */</span>
<span class='curline'><a href='../S/1225.html#L592'>ls</a>                592 src/lua/lstrlib.cpp                        const char *s, size_t ls, const char *p, size_t lp) {</span>
<span class='curline'><a href='../S/1225.html#L596'>ls</a>                596 src/lua/lstrlib.cpp   ms-&gt;src_end = s + ls;</span>
<span class='curline'><a href='../S/1225.html#L608'>ls</a>                608 src/lua/lstrlib.cpp   size_t ls, lp;</span>
<span class='curline'><a href='../S/1225.html#L609'>ls</a>                609 src/lua/lstrlib.cpp   const char *s = luaL_checklstring(L, 1, &amp;ls);</span>
<span class='curline'><a href='../S/1225.html#L611'>ls</a>                611 src/lua/lstrlib.cpp   lua_Integer init = posrelat(luaL_optinteger(L, 3, 1), ls);</span>
<span class='curline'><a href='../S/1225.html#L613'>ls</a>                613 src/lua/lstrlib.cpp   else if (init &gt; (lua_Integer)ls + 1) {  /* start after string's end? */</span>
<span class='curline'><a href='../S/1225.html#L620'>ls</a>                620 src/lua/lstrlib.cpp     const char *s2 = lmemfind(s + init - 1, ls - (size_t)init + 1, p, lp);</span>
<span class='curline'><a href='../S/1225.html#L634'>ls</a>                634 src/lua/lstrlib.cpp     prepstate(&amp;ms, L, s, ls, p, lp);</span>
<span class='curline'><a href='../S/1225.html#L690'>ls</a>                690 src/lua/lstrlib.cpp   size_t ls, lp;</span>
<span class='curline'><a href='../S/1225.html#L691'>ls</a>                691 src/lua/lstrlib.cpp   const char *s = luaL_checklstring(L, 1, &amp;ls);</span>
<span class='curline'><a href='../S/1225.html#L696'>ls</a>                696 src/lua/lstrlib.cpp   prepstate(&amp;gm-&gt;ms, L, s, ls, p, lp);</span>
<span class='curline'><a href='../S/1182.html#L248'>ls</a>                248 src/lua/lvm.cpp static int l_strcmp (const TString *ls, const TString *rs) {</span>
<span class='curline'><a href='../S/1182.html#L249'>ls</a>                249 src/lua/lvm.cpp   const char *l = getstr(ls);</span>
<span class='curline'><a href='../S/1182.html#L250'>ls</a>                250 src/lua/lvm.cpp   size_t ll = tsslen(ls);</span>
</pre>
</body>
</html>
