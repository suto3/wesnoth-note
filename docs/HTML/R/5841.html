<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>g</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/5531.html#L5'>g</a>                   5 data/lua/wml/objectives.lua local function color_prefix(r, g, b)</span>
<span class='curline'><a href='../S/5531.html#L6'>g</a>                   6 data/lua/wml/objectives.lua 	return string.format('&lt;span foreground="#%02x%02x%02x"&gt;', r, g, b)</span>
<span class='curline'><a href='../S/5531.html#L80'>g</a>                  80 data/lua/wml/objectives.lua 				local g = obj.green or 255</span>
<span class='curline'><a href='../S/5531.html#L87'>g</a>                  87 data/lua/wml/objectives.lua 				win_objectives = win_objectives .. color_prefix(r, g, b) .. objective_bullet .. description .. turn_counter .. "&lt;/span&gt;" .. "\n"</span>
<span class='curline'><a href='../S/5531.html#L91'>g</a>                  91 data/lua/wml/objectives.lua 				local g = obj.green or 0</span>
<span class='curline'><a href='../S/5531.html#L98'>g</a>                  98 data/lua/wml/objectives.lua 				lose_objectives = lose_objectives .. color_prefix(r, g, b) .. objective_bullet .. description .. turn_counter .. "&lt;/span&gt;" .. "\n"</span>
<span class='curline'><a href='../S/5531.html#L108'>g</a>                 108 data/lua/wml/objectives.lua 		local g = obj.green or 255</span>
<span class='curline'><a href='../S/5531.html#L113'>g</a>                 113 data/lua/wml/objectives.lua 				gold_carryover = color_prefix(r, g, b) .. gold_carryover_bullet .. "&lt;small&gt;" .. _"Early finish bonus." .. "&lt;/small&gt;&lt;/span&gt;\n"</span>
<span class='curline'><a href='../S/5531.html#L115'>g</a>                 115 data/lua/wml/objectives.lua 				gold_carryover = color_prefix(r, g, b) .. gold_carryover_bullet .. "&lt;small&gt;" .. _"No early finish bonus." .. "&lt;/small&gt;&lt;/span&gt;\n"</span>
<span class='curline'><a href='../S/5531.html#L128'>g</a>                 128 data/lua/wml/objectives.lua 			gold_carryover = gold_carryover .. color_prefix(r, g, b) .. gold_carryover_bullet .. "&lt;small&gt;" .. carryover_amount_string .. "&lt;/small&gt;&lt;/span&gt;\n"</span>
<span class='curline'><a href='../S/5531.html#L137'>g</a>                 137 data/lua/wml/objectives.lua 			local g = note.green or 255</span>
<span class='curline'><a href='../S/5531.html#L141'>g</a>                 141 data/lua/wml/objectives.lua 				notes = notes .. color_prefix(r, g, b) .. note_bullet .. "&lt;small&gt;" .. note.description .. "&lt;/small&gt;&lt;/span&gt;\n"</span>
<span class='curline'><a href='../S/4245.html#L51'>g</a>                  51 data/multiplayer/eras.lua 			local r, g, b = 255, 255, 255</span>
<span class='curline'><a href='../S/4245.html#L52'>g</a>                  52 data/multiplayer/eras.lua 			if     team.__cfg.color == 1 then r, g, b = 255,   0,   0</span>
<span class='curline'><a href='../S/4245.html#L53'>g</a>                  53 data/multiplayer/eras.lua 			elseif team.__cfg.color == 2 then r, g, b =   0,   0, 255</span>
<span class='curline'><a href='../S/4245.html#L54'>g</a>                  54 data/multiplayer/eras.lua 			elseif team.__cfg.color == 3 then r, g, b =   0, 255,   0</span>
<span class='curline'><a href='../S/4245.html#L55'>g</a>                  55 data/multiplayer/eras.lua 			elseif team.__cfg.color == 4 then r, g, b = 155,  48, 255</span>
<span class='curline'><a href='../S/4245.html#L56'>g</a>                  56 data/multiplayer/eras.lua 			elseif team.__cfg.color == 5 then r, g, b =   0,   0,   0</span>
<span class='curline'><a href='../S/4245.html#L57'>g</a>                  57 data/multiplayer/eras.lua 			elseif team.__cfg.color == 6 then r, g, b = 165,  42,  42</span>
<span class='curline'><a href='../S/4245.html#L58'>g</a>                  58 data/multiplayer/eras.lua 			elseif team.__cfg.color == 7 then r, g, b = 255, 165,   0</span>
<span class='curline'><a href='../S/4245.html#L59'>g</a>                  59 data/multiplayer/eras.lua 			elseif team.__cfg.color == 8 then r, g, b = 255, 255, 255</span>
<span class='curline'><a href='../S/4245.html#L60'>g</a>                  60 data/multiplayer/eras.lua 			elseif team.__cfg.color == 9 then r, g, b =   0, 128, 128 end</span>
<span class='curline'><a href='../S/4245.html#L63'>g</a>                  63 data/multiplayer/eras.lua 				r, g, b, side)</span>
<span class='curline'><a href='../S/4245.html#L77'>g</a>                  77 data/multiplayer/eras.lua 				r, g, b, side, income, units, team.gold, total)</span>
<span class='curline'><a href='../S/4245.html#L79'>g</a>                  79 data/multiplayer/eras.lua 					color = string.format("#%02x%02x%02x", r, g, b)</span>
<span class='curline'><a href='../S/5443.html#L22'>g</a>                  22 data/shaders/default.frag 		float rgb = texture_color.r * 0.299 + texture_color.g * 0.587</span>
<span class='curline'><a href='../S/1253.html#L17'>g</a>                  17 join.lua           local g = info.game_list()</span>
<span class='curline'><a href='../S/1253.html#L18'>g</a>                  18 join.lua           if g then</span>
<span class='curline'><a href='../S/1253.html#L19'>g</a>                  19 join.lua             local gamelist = helper.get_child(g, "gamelist")</span>
<span class='curline'><a href='../S/951.html#L121'>g</a>                 121 src/SDL_SavePNG/savepng.c 			pal_ptr[i].green = pal-&gt;colors[i].g;</span>
<span class='curline'><a href='../S/286.html#L300'>g</a>                 300 src/ai/contexts.cpp 	for(const goal_ptr g : goals_) {</span>
<span class='curline'><a href='../S/286.html#L301'>g</a>                 301 src/ai/contexts.cpp 		cfg.add_child("goal",g-&gt;to_config());</span>
<span class='curline'><a href='../S/238.html#L80'>g</a>                  80 src/ai/default/ca.cpp 	for(std::vector&lt;map_location&gt;::const_iterator g = gotos.begin(); g != gotos.end(); ++g) {</span>
<span class='curline'><a href='../S/238.html#L81'>g</a>                  81 src/ai/default/ca.cpp 		unit_map::const_iterator ui = units_.find(*g);</span>
<span class='curline'><a href='../S/1016.html#L104'>g</a>                 104 src/color.cpp  	  &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(g)</span>
<span class='curline'><a href='../S/1016.html#L115'>g</a>                 115 src/color.cpp  	      &lt;&lt; static_cast&lt;int&gt;(g) &lt;&lt; ','</span>
<span class='curline'><a href='../S/1016.html#L127'>g</a>                 127 src/color.cpp  	      &lt;&lt; static_cast&lt;int&gt;(g) &lt;&lt; ','</span>
<span class='curline'><a href='../S/969.html#L54'>g</a>                  54 src/color.hpp  		, g(255)</span>
<span class='curline'><a href='../S/969.html#L61'>g</a>                  61 src/color.hpp  		, g(g_val)</span>
<span class='curline'><a href='../S/969.html#L135'>g</a>                 135 src/color.hpp  			(static_cast&lt;uint32_t&gt;(g) &lt;&lt; RGBA_GREEN_BITSHIFT) |</span>
<span class='curline'><a href='../S/969.html#L149'>g</a>                 149 src/color.hpp  			(static_cast&lt;uint32_t&gt;(g) &lt;&lt; SDL_GREEN_BITSHIFT) |</span>
<span class='curline'><a href='../S/969.html#L180'>g</a>                 180 src/color.hpp  	uint8_t g;</span>
<span class='curline'><a href='../S/969.html#L195'>g</a>                 195 src/color.hpp  		return r == c.r &amp;&amp; g == c.g &amp;&amp; b == c.b &amp;&amp; a == c.a;</span>
<span class='curline'><a href='../S/969.html#L210'>g</a>                 210 src/color.hpp  			static_cast&lt;uint8_t&gt;(g &gt; 255 - c.g ? 255 : g + c.g),</span>
<span class='curline'><a href='../S/969.html#L220'>g</a>                 220 src/color.hpp  			std::max&lt;uint8_t&gt;(g, c.g),</span>
<span class='curline'><a href='../S/969.html#L229'>g</a>                 229 src/color.hpp  			static_cast&lt;uint8_t&gt;(255 - g),</span>
<span class='curline'><a href='../S/969.html#L244'>g</a>                 244 src/color.hpp  	s &lt;&lt; int(c.r) &lt;&lt; " " &lt;&lt; int(c.g) &lt;&lt; " " &lt;&lt; int(c.b) &lt;&lt; " " &lt;&lt; int(c.a) &lt;&lt; std::endl;</span>
<span class='curline'><a href='../S/930.html#L35'>g</a>                  35 src/color_range.cpp 	const uint16_t new_green = new_range.mid().g;</span>
<span class='curline'><a href='../S/930.html#L39'>g</a>                  39 src/color_range.cpp 	const uint16_t max_green = new_range.max().g;</span>
<span class='curline'><a href='../S/930.html#L43'>g</a>                  43 src/color_range.cpp 	const uint16_t min_green = new_range.min().g;</span>
<span class='curline'><a href='../S/930.html#L49'>g</a>                  49 src/color_range.cpp 	const uint16_t reference_avg = (temp_rgb.r + temp_rgb.g + temp_rgb.b) / 3;</span>
<span class='curline'><a href='../S/930.html#L52'>g</a>                  52 src/color_range.cpp 		const uint16_t old_avg = (old_c.r + old_c.g + old_c.b) / 3;</span>
<span class='curline'><a href='../S/748.html#L65'>g</a>                  65 src/cursor.cpp 				Uint8 r,g,b,a;</span>
<span class='curline'><a href='../S/748.html#L66'>g</a>                  66 src/cursor.cpp 				SDL_GetRGBA(pixels[y*nsurf-&gt;w + x],nsurf-&gt;format,&amp;r,&amp;g,&amp;b,&amp;a);</span>
<span class='curline'><a href='../S/748.html#L72'>g</a>                  72 src/cursor.cpp 				const Uint8 black = (trans == 0 || (r+g + b) / 3 &gt; 128 ? 0 : 1) &lt;&lt; shift;</span>
<span class='curline'><a href='../S/683.html#L436'>g</a>                 436 src/display.cpp 	image::set_color_adjustment(col.r, col.g, col.b);</span>
<span class='curline'><a href='../S/683.html#L439'>g</a>                 439 src/display.cpp void display::adjust_color_overlay(int r, int g, int b)</span>
<span class='curline'><a href='../S/683.html#L441'>g</a>                 441 src/display.cpp 	color_adjust_ = tod_color(r, g, b);</span>
<span class='curline'><a href='../S/683.html#L1091'>g</a>                1091 src/display.cpp 			lt = image::get_light_string(0, col.r, col.g, col.b);</span>
<span class='curline'><a href='../S/683.html#L1096'>g</a>                1096 src/display.cpp 		lt += image::get_light_string(d + 1, acol.r, acol.g, acol.b);</span>
<span class='curline'><a href='../S/683.html#L1119'>g</a>                1119 src/display.cpp 			lt = image::get_light_string(0, col.r, col.g, col.b);</span>
<span class='curline'><a href='../S/683.html#L1124'>g</a>                1124 src/display.cpp 		lt += image::get_light_string(d + 7, acol.r, acol.g, acol.b);</span>
<span class='curline'><a href='../S/683.html#L1147'>g</a>                1147 src/display.cpp 			lt = image::get_light_string(0, col.r, col.g, col.b);</span>
<span class='curline'><a href='../S/683.html#L1152'>g</a>                1152 src/display.cpp 		lt += image::get_light_string(d + 13, acol.r, acol.g, acol.b);</span>
<span class='curline'><a href='../S/683.html#L1159'>g</a>                1159 src/display.cpp 			lt = image::get_light_string(-1, col.r, col.g, col.b);</span>
<span class='curline'><a href='../S/683.html#L1425'>g</a>                1425 src/display.cpp 	color&lt;&lt; c_start &lt;&lt; RGB.r &lt;&lt; c_sep &lt;&lt; RGB.g &lt;&lt; c_sep &lt;&lt; RGB.b &lt;&lt; c_end;</span>
<span class='curline'><a href='../S/683.html#L2562'>g</a>                2562 src/display.cpp 			lt = image::get_light_string(0, tod_col.r, tod_col.g, tod_col.b);</span>
<span class='curline'><a href='../S/683.html#L3138'>g</a>                3138 src/display.cpp 	cfg["color_adjust_green"] = color_adjust_.g;</span>
<span class='curline'><a href='../S/683.html#L3146'>g</a>                3146 src/display.cpp 	color_adjust_.g = cfg["color_adjust_green"].to_int(0);</span>
<span class='curline'><a href='../S/959.html#L187'>g</a>                 187 src/display.hpp 	void adjust_color_overlay(int r, int g, int b);</span>
<span class='curline'><a href='../S/804.html#L113'>g</a>                 113 src/floating_label.cpp 			Uint32 color = SDL_MapRGBA(foreground-&gt;format, bgcolor_.r,bgcolor_.g, bgcolor_.b, bgalpha_);</span>
<span class='curline'><a href='../S/1155.html#L628'>g</a>                 628 src/font/text.cpp 	Uint8 g = (c &gt;&gt; 8) &amp; 0xff;</span>
<span class='curline'><a href='../S/1155.html#L633'>g</a>                 633 src/font/text.cpp 	unpremultiply(g, div);</span>
<span class='curline'><a href='../S/1155.html#L636'>g</a>                 636 src/font/text.cpp 	c = (static_cast&lt;Uint32&gt;(a) &lt;&lt; 24) | (static_cast&lt;Uint32&gt;(r) &lt;&lt; 16) | (static_cast&lt;Uint32&gt;(g) &lt;&lt; 8) | static_cast&lt;Uint32&gt;(b);</span>
<span class='curline'><a href='../S/1155.html#L673'>g</a>                 673 src/font/text.cpp 		foreground_color_.g / 256.0,</span>
<span class='curline'><a href='../S/770.html#L49'>g</a>                  49 src/formula/callable_objects.hpp 	explicit gamemap_callable(const gamemap&amp; g) : gamemap_(g)</span>
<span class='curline'><a href='../S/1126.html#L230'>g</a>                 230 src/game_initialization/lobby_info.cpp 		game_info* g = get_game_by_id(ui.game_id);</span>
<span class='curline'><a href='../S/1126.html#L231'>g</a>                 231 src/game_initialization/lobby_info.cpp 		if(!g) {</span>
<span class='curline'><a href='../S/1126.html#L238'>g</a>                 238 src/game_initialization/lobby_info.cpp 				g-&gt;has_friends = true;</span>
<span class='curline'><a href='../S/1126.html#L241'>g</a>                 241 src/game_initialization/lobby_info.cpp 				g-&gt;has_ignored = true;</span>
<span class='curline'><a href='../S/1126.html#L373'>g</a>                 373 src/game_initialization/lobby_info.cpp 	for(auto g : games_) {</span>
<span class='curline'><a href='../S/1126.html#L374'>g</a>                 374 src/game_initialization/lobby_info.cpp 		game_info&amp; gi = *g;</span>
<span class='curline'><a href='../S/517.html#L87'>g</a>                  87 src/gui/core/canvas.cpp 	SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);</span>
<span class='curline'><a href='../S/395.html#L98'>g</a>                  98 src/gui/dialogs/addon/uninstall_list.cpp 		grid const* g = list.get_row_grid(k);</span>
<span class='curline'><a href='../S/395.html#L100'>g</a>                 100 src/gui/dialogs/addon/uninstall_list.cpp 				= find_widget&lt;const toggle_button&gt;(g, "checkbox", false);</span>
<span class='curline'><a href='../S/347.html#L272'>g</a>                 272 src/gui/dialogs/editor/custom_tod.cpp 	current_tod.color.g = color_field_g_-&gt;get_widget_value(window);</span>
<span class='curline'><a href='../S/347.html#L331'>g</a>                 331 src/gui/dialogs/editor/custom_tod.cpp 	color_field_g_-&gt;set_widget_value(window, current_tod.color.g);</span>
<span class='curline'><a href='../S/336.html#L83'>g</a>                  83 src/gui/dialogs/editor/edit_label.cpp 	register_color_component("slider_green", &amp;color_t::g);</span>
<span class='curline'><a href='../S/418.html#L1096'>g</a>                1096 src/gui/dialogs/lobby/lobby.cpp 	lobby_delay_gamelist_update_guard g(*this);</span>
<span class='curline'><a href='../S/367.html#L114'>g</a>                 114 src/gui/dialogs/multiplayer/mp_cmd_wrapper.cpp 	if(grid* g = find_widget&lt;grid&gt;(&amp;window, "mod_options", false, false)) {</span>
<span class='curline'><a href='../S/367.html#L115'>g</a>                 115 src/gui/dialogs/multiplayer/mp_cmd_wrapper.cpp 		g-&gt;set_active(authenticated);</span>
<span class='curline'><a href='../S/367.html#L116'>g</a>                 116 src/gui/dialogs/multiplayer/mp_cmd_wrapper.cpp 		g-&gt;set_visible(authenticated ? widget::visibility::visible : widget::visibility::invisible);</span>
<span class='curline'><a href='../S/617.html#L1063'>g</a>                1063 src/gui/widgets/generator.cpp selection::init(grid* g,</span>
<span class='curline'><a href='../S/617.html#L1067'>g</a>                1067 src/gui/widgets/generator.cpp 	for(unsigned row = 0; row &lt; g-&gt;get_rows(); ++row) {</span>
<span class='curline'><a href='../S/617.html#L1068'>g</a>                1068 src/gui/widgets/generator.cpp 		for(unsigned col = 0; col &lt; g-&gt;get_cols(); ++col) {</span>
<span class='curline'><a href='../S/617.html#L1069'>g</a>                1069 src/gui/widgets/generator.cpp 			widget* widget = g-&gt;get_widget(row, col);</span>
<span class='curline'><a href='../S/566.html#L118'>g</a>                 118 src/gui/widgets/grid.cpp 				grid* g = dynamic_cast&lt;grid*&gt;(child.get_widget());</span>
<span class='curline'><a href='../S/566.html#L119'>g</a>                 119 src/gui/widgets/grid.cpp 				if(g) {</span>
<span class='curline'><a href='../S/566.html#L121'>g</a>                 121 src/gui/widgets/grid.cpp 					std::unique_ptr&lt;widget&gt; old = g-&gt;swap_child(id, w, true);</span>
<span class='curline'><a href='../S/566.html#L184'>g</a>                 184 src/gui/widgets/grid.cpp 		grid* g = dynamic_cast&lt;grid*&gt;(widget);</span>
<span class='curline'><a href='../S/566.html#L185'>g</a>                 185 src/gui/widgets/grid.cpp 		if(g) {</span>
<span class='curline'><a href='../S/566.html#L186'>g</a>                 186 src/gui/widgets/grid.cpp 			g-&gt;set_active(active);</span>
<span class='curline'><a href='../S/553.html#L337'>g</a>                 337 src/gui/widgets/list.cpp 	grid* g = find_widget&lt;grid&gt;(&amp;get_grid(), "_header_grid", false, false);</span>
<span class='curline'><a href='../S/553.html#L338'>g</a>                 338 src/gui/widgets/list.cpp 	if(g)</span>
<span class='curline'><a href='../S/553.html#L339'>g</a>                 339 src/gui/widgets/list.cpp 		g-&gt;set_visible(widget::visibility::invisible);</span>
<span class='curline'><a href='../S/553.html#L341'>g</a>                 341 src/gui/widgets/list.cpp 	g = find_widget&lt;grid&gt;(&amp;get_grid(), "_footer_grid", false, false);</span>
<span class='curline'><a href='../S/553.html#L342'>g</a>                 342 src/gui/widgets/list.cpp 	if(g)</span>
<span class='curline'><a href='../S/553.html#L343'>g</a>                 343 src/gui/widgets/list.cpp 		g-&gt;set_visible(widget::visibility::invisible);</span>
<span class='curline'><a href='../S/553.html#L345'>g</a>                 345 src/gui/widgets/list.cpp 	g = find_widget&lt;grid&gt;(&amp;get_grid(), "_vertical_scrollbar_grid", false, false);</span>
<span class='curline'><a href='../S/553.html#L346'>g</a>                 346 src/gui/widgets/list.cpp 	if(g)</span>
<span class='curline'><a href='../S/553.html#L347'>g</a>                 347 src/gui/widgets/list.cpp 		g-&gt;set_visible(widget::visibility::invisible);</span>
<span class='curline'><a href='../S/553.html#L349'>g</a>                 349 src/gui/widgets/list.cpp 	g = find_widget&lt;grid&gt;(&amp;get_grid(), "_horizontal_scrollbar_grid", false, false);</span>
<span class='curline'><a href='../S/553.html#L350'>g</a>                 350 src/gui/widgets/list.cpp 	if(g)</span>
<span class='curline'><a href='../S/553.html#L351'>g</a>                 351 src/gui/widgets/list.cpp 		g-&gt;set_visible(widget::visibility::invisible);</span>
<span class='curline'><a href='../S/546.html#L472'>g</a>                 472 src/gui/widgets/settings.cpp 	for(const auto&amp; g : cfg.child_range("gui")) {</span>
<span class='curline'><a href='../S/546.html#L473'>g</a>                 473 src/gui/widgets/settings.cpp 		guis.emplace(g["id"], gui_definition(g));</span>
<span class='curline'><a href='../S/550.html#L413'>g</a>                 413 src/gui/widgets/styled_widget.cpp 		std::vector&lt;wfl::variant&gt; link_color_as_list{wfl::variant(link_color.r), wfl::variant(link_color.g), wfl::variant(link_color.b), wfl::variant(link_color.a)};</span>
<span class='curline'><a href='../S/619.html#L645'>g</a>                 645 src/gui/widgets/tree_view_node.cpp 		grid* g,</span>
<span class='curline'><a href='../S/619.html#L648'>g</a>                 648 src/gui/widgets/tree_view_node.cpp 	assert(g);</span>
<span class='curline'><a href='../S/619.html#L650'>g</a>                 650 src/gui/widgets/tree_view_node.cpp 	for(unsigned row = 0; row &lt; g-&gt;get_rows(); ++row) {</span>
<span class='curline'><a href='../S/619.html#L651'>g</a>                 651 src/gui/widgets/tree_view_node.cpp 		for(unsigned col = 0; col &lt; g-&gt;get_cols(); ++col) {</span>
<span class='curline'><a href='../S/619.html#L652'>g</a>                 652 src/gui/widgets/tree_view_node.cpp 			widget* wgt = g-&gt;get_widget(row, col);</span>
<span class='curline'><a href='../S/552.html#L23'>g</a>                  23 src/gui/widgets/widget_helpers.cpp void swap_grid(grid* g, grid* content_grid, widget* widget, const std::string&amp; id)</span>
<span class='curline'><a href='../S/552.html#L33'>g</a>                  33 src/gui/widgets/widget_helpers.cpp 	if(g) {</span>
<span class='curline'><a href='../S/552.html#L34'>g</a>                  34 src/gui/widgets/widget_helpers.cpp 		parent_grid = find_widget&lt;grid&gt;(g, id, false, false);</span>
<span class='curline'><a href='../S/627.html#L27'>g</a>                  27 src/gui/widgets/widget_helpers.hpp void swap_grid(grid* g, grid* content_grid, widget* widget, const std::string&amp; id);</span>
<span class='curline'><a href='../S/570.html#L1211'>g</a>                1211 src/gui/widgets/window.cpp void window_swap_grid(grid* g,</span>
<span class='curline'><a href='../S/570.html#L1224'>g</a>                1224 src/gui/widgets/window.cpp 	if(g) {</span>
<span class='curline'><a href='../S/570.html#L1225'>g</a>                1225 src/gui/widgets/window.cpp 		parent_grid = find_widget&lt;grid&gt;(g, id, false, false);</span>
<span class='curline'><a href='../S/810.html#L341'>g</a>                 341 src/help/help_impl.cpp topic_text &amp;topic_text::operator=(topic_generator *g)</span>
<span class='curline'><a href='../S/810.html#L345'>g</a>                 345 src/help/help_impl.cpp 	generator_ = g;</span>
<span class='curline'><a href='../S/815.html#L98'>g</a>                  98 src/help/help_impl.hpp 	explicit topic_text(topic_generator *g):</span>
<span class='curline'><a href='../S/815.html#L100'>g</a>                 100 src/help/help_impl.hpp 		generator_(g)</span>
<span class='curline'><a href='../S/815.html#L103'>g</a>                 103 src/help/help_impl.hpp 	topic_text &amp;operator=(topic_generator *g);</span>
<span class='curline'><a href='../S/815.html#L128'>g</a>                 128 src/help/help_impl.hpp 	topic(const std::string &amp;_title, const std::string &amp;_id, topic_generator *g)</span>
<span class='curline'><a href='../S/815.html#L129'>g</a>                 129 src/help/help_impl.hpp 		: title(_title), id(_id), text(g) {}</span>
<span class='curline'><a href='../S/681.html#L624'>g</a>                 624 src/image.cpp  light_string get_light_string(int op, int r, int g, int b)</span>
<span class='curline'><a href='../S/681.html#L630'>g</a>                 630 src/image.cpp  	ls.push_back(col_to_uchar(g));</span>
<span class='curline'><a href='../S/681.html#L751'>g</a>                 751 src/image.cpp  void set_color_adjustment(int r, int g, int b)</span>
<span class='curline'><a href='../S/681.html#L753'>g</a>                 753 src/image.cpp  	if(r != red_adjust || g != green_adjust || b != blue_adjust) {</span>
<span class='curline'><a href='../S/681.html#L755'>g</a>                 755 src/image.cpp  		green_adjust = g;</span>
<span class='curline'><a href='../S/756.html#L145'>g</a>                 145 src/image.hpp  	light_string get_light_string(int op, int r, int g, int b);</span>
<span class='curline'><a href='../S/756.html#L166'>g</a>                 166 src/image.hpp  	void set_color_adjustment(int r, int g, int b);</span>
<span class='curline'><a href='../S/970.html#L253'>g</a>                 253 src/image_modifications.cpp 			return variant(clr.g);</span>
<span class='curline'><a href='../S/970.html#L298'>g</a>                 298 src/image_modifications.cpp 			pixel.g = (*cur) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/970.html#L308'>g</a>                 308 src/image_modifications.cpp 			*cur = (pixel.a &lt;&lt; 24) + (pixel.r &lt;&lt; 16) + (pixel.g &lt;&lt; 8) + pixel.b;</span>
<span class='curline'><a href='../S/970.html#L345'>g</a>                 345 src/image_modifications.cpp 			pixel.g = (*cur) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/970.html#L355'>g</a>                 355 src/image_modifications.cpp 			pixel.g = std::min&lt;unsigned&gt;(new_green.evaluate(px).as_int(), 255);</span>
<span class='curline'><a href='../S/970.html#L358'>g</a>                 358 src/image_modifications.cpp 			*cur = (pixel.a &lt;&lt; 24) + (pixel.r &lt;&lt; 16) + (pixel.g &lt;&lt; 8) + pixel.b;</span>
<span class='curline'><a href='../S/970.html#L555'>g</a>                 555 src/image_modifications.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/970.html#L557'>g</a>                 557 src/image_modifications.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/970.html#L561'>g</a>                 561 src/image_modifications.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/970.html#L592'>g</a>                 592 src/image_modifications.cpp 	SDL_FillRect(ret, nullptr, SDL_MapRGBA(ret-&gt;format, color_.r, color_.g,</span>
<span class='curline'><a href='../S/970.html#L928'>g</a>                 928 src/image_modifications.cpp 	int r = 0, g = 0, b = 0;</span>
<span class='curline'><a href='../S/970.html#L933'>g</a>                 933 src/image_modifications.cpp 		g = lexical_cast_default&lt;int&gt;(factors[1]);</span>
<span class='curline'><a href='../S/970.html#L939'>g</a>                 939 src/image_modifications.cpp 	return new cs_modification(r, g, b);</span>
<span class='curline'><a href='../S/970.html#L1225'>g</a>                1225 src/image_modifications.cpp 	const int g = lexical_cast_default&lt;int&gt;(args);</span>
<span class='curline'><a href='../S/970.html#L1227'>g</a>                1227 src/image_modifications.cpp 	return new cs_modification(0,g,0);</span>
<span class='curline'><a href='../S/827.html#L251'>g</a>                 251 src/image_modifications.hpp 	negative_modification(int r, int g, int b): red_(r), green_(g), blue_(b) {}</span>
<span class='curline'><a href='../S/827.html#L524'>g</a>                 524 src/image_modifications.hpp 	cs_modification(int r, int g, int b)</span>
<span class='curline'><a href='../S/827.html#L525'>g</a>                 525 src/image_modifications.hpp 		: r_(r), g_(g), b_(b)</span>
<span class='curline'><a href='../S/827.html#L543'>g</a>                 543 src/image_modifications.hpp 	blend_modification(int r, int g, int b, float a)</span>
<span class='curline'><a href='../S/827.html#L544'>g</a>                 544 src/image_modifications.hpp 		: r_(r), g_(g), b_(b), a_(a)</span>
<span class='curline'><a href='../S/827.html#L601'>g</a>                 601 src/image_modifications.hpp 	swap_modification(channel r, channel g, channel b, channel a): red_(r), green_(g), blue_(b), alpha_(a) {}</span>
<span class='curline'><a href='../S/1172.html#L1041'>g</a>                1041 src/lua/lapi.cpp   global_State *g;</span>
<span class='curline'><a href='../S/1172.html#L1043'>g</a>                1043 src/lua/lapi.cpp   g = G(L);</span>
<span class='curline'><a href='../S/1172.html#L1046'>g</a>                1046 src/lua/lapi.cpp       g-&gt;gcrunning = 0;</span>
<span class='curline'><a href='../S/1172.html#L1050'>g</a>                1050 src/lua/lapi.cpp       luaE_setdebt(g, 0);</span>
<span class='curline'><a href='../S/1172.html#L1051'>g</a>                1051 src/lua/lapi.cpp       g-&gt;gcrunning = 1;</span>
<span class='curline'><a href='../S/1172.html#L1060'>g</a>                1060 src/lua/lapi.cpp       res = cast_int(gettotalbytes(g) &gt;&gt; 10);</span>
<span class='curline'><a href='../S/1172.html#L1064'>g</a>                1064 src/lua/lapi.cpp       res = cast_int(gettotalbytes(g) &amp; 0x3ff);</span>
<span class='curline'><a href='../S/1172.html#L1069'>g</a>                1069 src/lua/lapi.cpp       lu_byte oldrunning = g-&gt;gcrunning;</span>
<span class='curline'><a href='../S/1172.html#L1070'>g</a>                1070 src/lua/lapi.cpp       g-&gt;gcrunning = 1;  /* allow GC to run */</span>
<span class='curline'><a href='../S/1172.html#L1072'>g</a>                1072 src/lua/lapi.cpp         luaE_setdebt(g, -GCSTEPSIZE);  /* to do a "small" step */</span>
<span class='curline'><a href='../S/1172.html#L1076'>g</a>                1076 src/lua/lapi.cpp         debt = cast(l_mem, data) * 1024 + g-&gt;GCdebt;</span>
<span class='curline'><a href='../S/1172.html#L1077'>g</a>                1077 src/lua/lapi.cpp         luaE_setdebt(g, debt);</span>
<span class='curline'><a href='../S/1172.html#L1080'>g</a>                1080 src/lua/lapi.cpp       g-&gt;gcrunning = oldrunning;  /* restore previous state */</span>
<span class='curline'><a href='../S/1172.html#L1081'>g</a>                1081 src/lua/lapi.cpp       if (debt &gt; 0 &amp;&amp; g-&gt;gcstate == GCSpause)  /* end of cycle? */</span>
<span class='curline'><a href='../S/1172.html#L1086'>g</a>                1086 src/lua/lapi.cpp       res = g-&gt;gcpause;</span>
<span class='curline'><a href='../S/1172.html#L1087'>g</a>                1087 src/lua/lapi.cpp       g-&gt;gcpause = data;</span>
<span class='curline'><a href='../S/1172.html#L1091'>g</a>                1091 src/lua/lapi.cpp       res = g-&gt;gcstepmul;</span>
<span class='curline'><a href='../S/1172.html#L1093'>g</a>                1093 src/lua/lapi.cpp       g-&gt;gcstepmul = data;</span>
<span class='curline'><a href='../S/1172.html#L1097'>g</a>                1097 src/lua/lapi.cpp       res = g-&gt;gcrunning;</span>
<span class='curline'><a href='../S/1205.html#L116'>g</a>                 116 src/lua/ldo.cpp     global_State *g = G(L);</span>
<span class='curline'><a href='../S/1205.html#L118'>g</a>                 118 src/lua/ldo.cpp     if (g-&gt;mainthread-&gt;errorJmp) {  /* main thread has a handler? */</span>
<span class='curline'><a href='../S/1205.html#L119'>g</a>                 119 src/lua/ldo.cpp       setobjs2s(L, g-&gt;mainthread-&gt;top++, L-&gt;top - 1);  /* copy error obj. */</span>
<span class='curline'><a href='../S/1205.html#L120'>g</a>                 120 src/lua/ldo.cpp       luaD_throw(g-&gt;mainthread, errcode);  /* re-throw in main thread */</span>
<span class='curline'><a href='../S/1205.html#L123'>g</a>                 123 src/lua/ldo.cpp       if (g-&gt;panic) {  /* panic function? */</span>
<span class='curline'><a href='../S/1205.html#L128'>g</a>                 128 src/lua/ldo.cpp         g-&gt;panic(L);  /* call panic function (last chance to jump out) */</span>
<span class='curline'><a href='../S/1200.html#L67'>g</a>                  67 src/lua/lgc.cpp #define makewhite(g,x)	\</span>
<span class='curline'><a href='../S/1200.html#L68'>g</a>                  68 src/lua/lgc.cpp  (x-&gt;marked = cast_byte((x-&gt;marked &amp; maskcolors) | luaC_white(g)))</span>
<span class='curline'><a href='../S/1200.html#L83'>g</a>                  83 src/lua/lgc.cpp #define markvalue(g,o) { checkconsistency(o); \</span>
<span class='curline'><a href='../S/1200.html#L84'>g</a>                  84 src/lua/lgc.cpp   if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }</span>
<span class='curline'><a href='../S/1200.html#L86'>g</a>                  86 src/lua/lgc.cpp #define markobject(g,t)	{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }</span>
<span class='curline'><a href='../S/1200.html#L92'>g</a>                  92 src/lua/lgc.cpp #define markobjectN(g,t)	{ if (t) markobject(g,t); }</span>
<span class='curline'><a href='../S/1200.html#L94'>g</a>                  94 src/lua/lgc.cpp static void reallymarkobject (global_State *g, GCObject *o);</span>
<span class='curline'><a href='../S/1200.html#L139'>g</a>                 139 src/lua/lgc.cpp static int iscleared (global_State *g, const TValue *o) {</span>
<span class='curline'><a href='../S/1200.html#L142'>g</a>                 142 src/lua/lgc.cpp     markobject(g, tsvalue(o));  /* strings are 'values', so are never weak */</span>
<span class='curline'><a href='../S/1200.html#L156'>g</a>                 156 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L157'>g</a>                 157 src/lua/lgc.cpp   lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span>
<span class='curline'><a href='../S/1200.html#L158'>g</a>                 158 src/lua/lgc.cpp   if (keepinvariant(g))  /* must keep invariant? */</span>
<span class='curline'><a href='../S/1200.html#L159'>g</a>                 159 src/lua/lgc.cpp     reallymarkobject(g, v);  /* restore invariant */</span>
<span class='curline'><a href='../S/1200.html#L161'>g</a>                 161 src/lua/lgc.cpp     lua_assert(issweepphase(g));</span>
<span class='curline'><a href='../S/1200.html#L162'>g</a>                 162 src/lua/lgc.cpp     makewhite(g, o);  /* mark main obj. as white to avoid other barriers */</span>
<span class='curline'><a href='../S/1200.html#L172'>g</a>                 172 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L173'>g</a>                 173 src/lua/lgc.cpp   lua_assert(isblack(t) &amp;&amp; !isdead(g, t));</span>
<span class='curline'><a href='../S/1200.html#L175'>g</a>                 175 src/lua/lgc.cpp   linkgclist(t, g-&gt;grayagain);</span>
<span class='curline'><a href='../S/1200.html#L186'>g</a>                 186 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L189'>g</a>                 189 src/lua/lgc.cpp   if (keepinvariant(g))</span>
<span class='curline'><a href='../S/1200.html#L190'>g</a>                 190 src/lua/lgc.cpp     markobject(g, o);</span>
<span class='curline'><a href='../S/1200.html#L195'>g</a>                 195 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L196'>g</a>                 196 src/lua/lgc.cpp   lua_assert(g-&gt;allgc == o);  /* object must be 1st in 'allgc' list! */</span>
<span class='curline'><a href='../S/1200.html#L198'>g</a>                 198 src/lua/lgc.cpp   g-&gt;allgc = o-&gt;next;  /* remove object from 'allgc' list */</span>
<span class='curline'><a href='../S/1200.html#L199'>g</a>                 199 src/lua/lgc.cpp   o-&gt;next = g-&gt;fixedgc;  /* link it to 'fixedgc' list */</span>
<span class='curline'><a href='../S/1200.html#L200'>g</a>                 200 src/lua/lgc.cpp   g-&gt;fixedgc = o;</span>
<span class='curline'><a href='../S/1200.html#L209'>g</a>                 209 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L211'>g</a>                 211 src/lua/lgc.cpp   o-&gt;marked = luaC_white(g);</span>
<span class='curline'><a href='../S/1200.html#L213'>g</a>                 213 src/lua/lgc.cpp   o-&gt;next = g-&gt;allgc;</span>
<span class='curline'><a href='../S/1200.html#L214'>g</a>                 214 src/lua/lgc.cpp   g-&gt;allgc = o;</span>
<span class='curline'><a href='../S/1200.html#L235'>g</a>                 235 src/lua/lgc.cpp static void reallymarkobject (global_State *g, GCObject *o) {</span>
<span class='curline'><a href='../S/1200.html#L241'>g</a>                 241 src/lua/lgc.cpp       g-&gt;GCmemtrav += sizelstring(gco2ts(o)-&gt;shrlen);</span>
<span class='curline'><a href='../S/1200.html#L246'>g</a>                 246 src/lua/lgc.cpp       g-&gt;GCmemtrav += sizelstring(gco2ts(o)-&gt;u.lnglen);</span>
<span class='curline'><a href='../S/1200.html#L251'>g</a>                 251 src/lua/lgc.cpp       markobjectN(g, gco2u(o)-&gt;metatable);  /* mark its metatable */</span>
<span class='curline'><a href='../S/1200.html#L253'>g</a>                 253 src/lua/lgc.cpp       g-&gt;GCmemtrav += sizeudata(gco2u(o));</span>
<span class='curline'><a href='../S/1200.html#L254'>g</a>                 254 src/lua/lgc.cpp       getuservalue(g-&gt;mainthread, gco2u(o), &amp;uvalue);</span>
<span class='curline'><a href='../S/1200.html#L262'>g</a>                 262 src/lua/lgc.cpp       linkgclist(gco2lcl(o), g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L266'>g</a>                 266 src/lua/lgc.cpp       linkgclist(gco2ccl(o), g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L270'>g</a>                 270 src/lua/lgc.cpp       linkgclist(gco2t(o), g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L274'>g</a>                 274 src/lua/lgc.cpp       linkgclist(gco2th(o), g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L278'>g</a>                 278 src/lua/lgc.cpp       linkgclist(gco2p(o), g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L289'>g</a>                 289 src/lua/lgc.cpp static void markmt (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L292'>g</a>                 292 src/lua/lgc.cpp     markobjectN(g, g-&gt;mt[i]);</span>
<span class='curline'><a href='../S/1200.html#L299'>g</a>                 299 src/lua/lgc.cpp static void markbeingfnz (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L301'>g</a>                 301 src/lua/lgc.cpp   for (o = g-&gt;tobefnz; o != NULL; o = o-&gt;next)</span>
<span class='curline'><a href='../S/1200.html#L302'>g</a>                 302 src/lua/lgc.cpp     markobject(g, o);</span>
<span class='curline'><a href='../S/1200.html#L312'>g</a>                 312 src/lua/lgc.cpp static void remarkupvals (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L314'>g</a>                 314 src/lua/lgc.cpp   lua_State **p = &amp;g-&gt;twups;</span>
<span class='curline'><a href='../S/1200.html#L325'>g</a>                 325 src/lua/lgc.cpp           markvalue(g, uv-&gt;v);  /* remark upvalue's value */</span>
<span class='curline'><a href='../S/1200.html#L337'>g</a>                 337 src/lua/lgc.cpp static void restartcollection (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L338'>g</a>                 338 src/lua/lgc.cpp   g-&gt;gray = g-&gt;grayagain = NULL;</span>
<span class='curline'><a href='../S/1200.html#L339'>g</a>                 339 src/lua/lgc.cpp   g-&gt;weak = g-&gt;allweak = g-&gt;ephemeron = NULL;</span>
<span class='curline'><a href='../S/1200.html#L340'>g</a>                 340 src/lua/lgc.cpp   markobject(g, g-&gt;mainthread);</span>
<span class='curline'><a href='../S/1200.html#L341'>g</a>                 341 src/lua/lgc.cpp   markvalue(g, &amp;g-&gt;l_registry);</span>
<span class='curline'><a href='../S/1200.html#L342'>g</a>                 342 src/lua/lgc.cpp   markmt(g);</span>
<span class='curline'><a href='../S/1200.html#L343'>g</a>                 343 src/lua/lgc.cpp   markbeingfnz(g);  /* mark any finalizing object left from previous cycle */</span>
<span class='curline'><a href='../S/1200.html#L361'>g</a>                 361 src/lua/lgc.cpp static void traverseweakvalue (global_State *g, Table *h) {</span>
<span class='curline'><a href='../S/1200.html#L372'>g</a>                 372 src/lua/lgc.cpp       markvalue(g, gkey(n));  /* mark key */</span>
<span class='curline'><a href='../S/1200.html#L373'>g</a>                 373 src/lua/lgc.cpp       if (!hasclears &amp;&amp; iscleared(g, gval(n)))  /* is there a white value? */</span>
<span class='curline'><a href='../S/1200.html#L377'>g</a>                 377 src/lua/lgc.cpp   if (g-&gt;gcstate == GCSpropagate)</span>
<span class='curline'><a href='../S/1200.html#L378'>g</a>                 378 src/lua/lgc.cpp     linkgclist(h, g-&gt;grayagain);  /* must retraverse it in atomic phase */</span>
<span class='curline'><a href='../S/1200.html#L380'>g</a>                 380 src/lua/lgc.cpp     linkgclist(h, g-&gt;weak);  /* has to be cleared later */</span>
<span class='curline'><a href='../S/1200.html#L394'>g</a>                 394 src/lua/lgc.cpp static int traverseephemeron (global_State *g, Table *h) {</span>
<span class='curline'><a href='../S/1200.html#L404'>g</a>                 404 src/lua/lgc.cpp       reallymarkobject(g, gcvalue(&amp;h-&gt;array[i]));</span>
<span class='curline'><a href='../S/1200.html#L412'>g</a>                 412 src/lua/lgc.cpp     else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */</span>
<span class='curline'><a href='../S/1200.html#L419'>g</a>                 419 src/lua/lgc.cpp       reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */</span>
<span class='curline'><a href='../S/1200.html#L423'>g</a>                 423 src/lua/lgc.cpp   if (g-&gt;gcstate == GCSpropagate)</span>
<span class='curline'><a href='../S/1200.html#L424'>g</a>                 424 src/lua/lgc.cpp     linkgclist(h, g-&gt;grayagain);  /* must retraverse it in atomic phase */</span>
<span class='curline'><a href='../S/1200.html#L426'>g</a>                 426 src/lua/lgc.cpp     linkgclist(h, g-&gt;ephemeron);  /* have to propagate again */</span>
<span class='curline'><a href='../S/1200.html#L428'>g</a>                 428 src/lua/lgc.cpp     linkgclist(h, g-&gt;allweak);  /* may have to clean white keys */</span>
<span class='curline'><a href='../S/1200.html#L433'>g</a>                 433 src/lua/lgc.cpp static void traversestrongtable (global_State *g, Table *h) {</span>
<span class='curline'><a href='../S/1200.html#L437'>g</a>                 437 src/lua/lgc.cpp     markvalue(g, &amp;h-&gt;array[i]);</span>
<span class='curline'><a href='../S/1200.html#L444'>g</a>                 444 src/lua/lgc.cpp       markvalue(g, gkey(n));  /* mark key */</span>
<span class='curline'><a href='../S/1200.html#L445'>g</a>                 445 src/lua/lgc.cpp       markvalue(g, gval(n));  /* mark value */</span>
<span class='curline'><a href='../S/1200.html#L451'>g</a>                 451 src/lua/lgc.cpp static lu_mem traversetable (global_State *g, Table *h) {</span>
<span class='curline'><a href='../S/1200.html#L453'>g</a>                 453 src/lua/lgc.cpp   const TValue *mode = gfasttm(g, h-&gt;metatable, TM_MODE);</span>
<span class='curline'><a href='../S/1200.html#L454'>g</a>                 454 src/lua/lgc.cpp   markobjectN(g, h-&gt;metatable);</span>
<span class='curline'><a href='../S/1200.html#L461'>g</a>                 461 src/lua/lgc.cpp       traverseweakvalue(g, h);</span>
<span class='curline'><a href='../S/1200.html#L463'>g</a>                 463 src/lua/lgc.cpp       traverseephemeron(g, h);</span>
<span class='curline'><a href='../S/1200.html#L465'>g</a>                 465 src/lua/lgc.cpp       linkgclist(h, g-&gt;allweak);  /* nothing to traverse now */</span>
<span class='curline'><a href='../S/1200.html#L468'>g</a>                 468 src/lua/lgc.cpp     traversestrongtable(g, h);</span>
<span class='curline'><a href='../S/1200.html#L479'>g</a>                 479 src/lua/lgc.cpp static int traverseproto (global_State *g, Proto *f) {</span>
<span class='curline'><a href='../S/1200.html#L483'>g</a>                 483 src/lua/lgc.cpp   markobjectN(g, f-&gt;source);</span>
<span class='curline'><a href='../S/1200.html#L485'>g</a>                 485 src/lua/lgc.cpp     markvalue(g, &amp;f-&gt;k[i]);</span>
<span class='curline'><a href='../S/1200.html#L487'>g</a>                 487 src/lua/lgc.cpp     markobjectN(g, f-&gt;upvalues[i].name);</span>
<span class='curline'><a href='../S/1200.html#L489'>g</a>                 489 src/lua/lgc.cpp     markobjectN(g, f-&gt;p[i]);</span>
<span class='curline'><a href='../S/1200.html#L491'>g</a>                 491 src/lua/lgc.cpp     markobjectN(g, f-&gt;locvars[i].varname);</span>
<span class='curline'><a href='../S/1200.html#L501'>g</a>                 501 src/lua/lgc.cpp static lu_mem traverseCclosure (global_State *g, CClosure *cl) {</span>
<span class='curline'><a href='../S/1200.html#L504'>g</a>                 504 src/lua/lgc.cpp     markvalue(g, &amp;cl-&gt;upvalue[i]);</span>
<span class='curline'><a href='../S/1200.html#L514'>g</a>                 514 src/lua/lgc.cpp static lu_mem traverseLclosure (global_State *g, LClosure *cl) {</span>
<span class='curline'><a href='../S/1200.html#L516'>g</a>                 516 src/lua/lgc.cpp   markobjectN(g, cl-&gt;p);  /* mark its prototype */</span>
<span class='curline'><a href='../S/1200.html#L520'>g</a>                 520 src/lua/lgc.cpp       if (upisopen(uv) &amp;&amp; g-&gt;gcstate != GCSinsideatomic)</span>
<span class='curline'><a href='../S/1200.html#L523'>g</a>                 523 src/lua/lgc.cpp         markvalue(g, uv-&gt;v);</span>
<span class='curline'><a href='../S/1200.html#L530'>g</a>                 530 src/lua/lgc.cpp static lu_mem traversethread (global_State *g, lua_State *th) {</span>
<span class='curline'><a href='../S/1200.html#L534'>g</a>                 534 src/lua/lgc.cpp   lua_assert(g-&gt;gcstate == GCSinsideatomic ||</span>
<span class='curline'><a href='../S/1200.html#L537'>g</a>                 537 src/lua/lgc.cpp     markvalue(g, o);</span>
<span class='curline'><a href='../S/1200.html#L538'>g</a>                 538 src/lua/lgc.cpp   if (g-&gt;gcstate == GCSinsideatomic) {  /* final traversal? */</span>
<span class='curline'><a href='../S/1200.html#L544'>g</a>                 544 src/lua/lgc.cpp       th-&gt;twups = g-&gt;twups;  /* link it back to the list */</span>
<span class='curline'><a href='../S/1200.html#L545'>g</a>                 545 src/lua/lgc.cpp       g-&gt;twups = th;</span>
<span class='curline'><a href='../S/1200.html#L548'>g</a>                 548 src/lua/lgc.cpp   else if (g-&gt;gckind != KGC_EMERGENCY)</span>
<span class='curline'><a href='../S/1200.html#L559'>g</a>                 559 src/lua/lgc.cpp static void propagatemark (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L561'>g</a>                 561 src/lua/lgc.cpp   GCObject *o = g-&gt;gray;</span>
<span class='curline'><a href='../S/1200.html#L567'>g</a>                 567 src/lua/lgc.cpp       g-&gt;gray = h-&gt;gclist;  /* remove from 'gray' list */</span>
<span class='curline'><a href='../S/1200.html#L568'>g</a>                 568 src/lua/lgc.cpp       size = traversetable(g, h);</span>
<span class='curline'><a href='../S/1200.html#L573'>g</a>                 573 src/lua/lgc.cpp       g-&gt;gray = cl-&gt;gclist;  /* remove from 'gray' list */</span>
<span class='curline'><a href='../S/1200.html#L574'>g</a>                 574 src/lua/lgc.cpp       size = traverseLclosure(g, cl);</span>
<span class='curline'><a href='../S/1200.html#L579'>g</a>                 579 src/lua/lgc.cpp       g-&gt;gray = cl-&gt;gclist;  /* remove from 'gray' list */</span>
<span class='curline'><a href='../S/1200.html#L580'>g</a>                 580 src/lua/lgc.cpp       size = traverseCclosure(g, cl);</span>
<span class='curline'><a href='../S/1200.html#L585'>g</a>                 585 src/lua/lgc.cpp       g-&gt;gray = th-&gt;gclist;  /* remove from 'gray' list */</span>
<span class='curline'><a href='../S/1200.html#L586'>g</a>                 586 src/lua/lgc.cpp       linkgclist(th, g-&gt;grayagain);  /* insert into 'grayagain' list */</span>
<span class='curline'><a href='../S/1200.html#L588'>g</a>                 588 src/lua/lgc.cpp       size = traversethread(g, th);</span>
<span class='curline'><a href='../S/1200.html#L593'>g</a>                 593 src/lua/lgc.cpp       g-&gt;gray = p-&gt;gclist;  /* remove from 'gray' list */</span>
<span class='curline'><a href='../S/1200.html#L594'>g</a>                 594 src/lua/lgc.cpp       size = traverseproto(g, p);</span>
<span class='curline'><a href='../S/1200.html#L599'>g</a>                 599 src/lua/lgc.cpp   g-&gt;GCmemtrav += size;</span>
<span class='curline'><a href='../S/1200.html#L603'>g</a>                 603 src/lua/lgc.cpp static void propagateall (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L604'>g</a>                 604 src/lua/lgc.cpp   while (g-&gt;gray) propagatemark(g);</span>
<span class='curline'><a href='../S/1200.html#L608'>g</a>                 608 src/lua/lgc.cpp static void convergeephemerons (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L612'>g</a>                 612 src/lua/lgc.cpp     GCObject *next = g-&gt;ephemeron;  /* get ephemeron list */</span>
<span class='curline'><a href='../S/1200.html#L613'>g</a>                 613 src/lua/lgc.cpp     g-&gt;ephemeron = NULL;  /* tables may return to this list when traversed */</span>
<span class='curline'><a href='../S/1200.html#L617'>g</a>                 617 src/lua/lgc.cpp       if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */</span>
<span class='curline'><a href='../S/1200.html#L618'>g</a>                 618 src/lua/lgc.cpp         propagateall(g);  /* propagate changes */</span>
<span class='curline'><a href='../S/1200.html#L639'>g</a>                 639 src/lua/lgc.cpp static void clearkeys (global_State *g, GCObject *l, GCObject *f) {</span>
<span class='curline'><a href='../S/1200.html#L644'>g</a>                 644 src/lua/lgc.cpp       if (!ttisnil(gval(n)) &amp;&amp; (iscleared(g, gkey(n)))) {</span>
<span class='curline'><a href='../S/1200.html#L657'>g</a>                 657 src/lua/lgc.cpp static void clearvalues (global_State *g, GCObject *l, GCObject *f) {</span>
<span class='curline'><a href='../S/1200.html#L664'>g</a>                 664 src/lua/lgc.cpp       if (iscleared(g, o))  /* value was collected? */</span>
<span class='curline'><a href='../S/1200.html#L668'>g</a>                 668 src/lua/lgc.cpp       if (!ttisnil(gval(n)) &amp;&amp; iscleared(g, gval(n))) {</span>
<span class='curline'><a href='../S/1200.html#L735'>g</a>                 735 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L736'>g</a>                 736 src/lua/lgc.cpp   int ow = otherwhite(g);</span>
<span class='curline'><a href='../S/1200.html#L737'>g</a>                 737 src/lua/lgc.cpp   int white = luaC_white(g);  /* current white */</span>
<span class='curline'><a href='../S/1200.html#L777'>g</a>                 777 src/lua/lgc.cpp static void checkSizes (lua_State *L, global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L778'>g</a>                 778 src/lua/lgc.cpp   if (g-&gt;gckind != KGC_EMERGENCY) {</span>
<span class='curline'><a href='../S/1200.html#L779'>g</a>                 779 src/lua/lgc.cpp     l_mem olddebt = g-&gt;GCdebt;</span>
<span class='curline'><a href='../S/1200.html#L780'>g</a>                 780 src/lua/lgc.cpp     if (g-&gt;strt.nuse &lt; g-&gt;strt.size / 4)  /* string table too big? */</span>
<span class='curline'><a href='../S/1200.html#L781'>g</a>                 781 src/lua/lgc.cpp       luaS_resize(L, g-&gt;strt.size / 2);  /* shrink it a little */</span>
<span class='curline'><a href='../S/1200.html#L782'>g</a>                 782 src/lua/lgc.cpp     g-&gt;GCestimate += g-&gt;GCdebt - olddebt;  /* update estimate */</span>
<span class='curline'><a href='../S/1200.html#L787'>g</a>                 787 src/lua/lgc.cpp static GCObject *udata2finalize (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L788'>g</a>                 788 src/lua/lgc.cpp   GCObject *o = g-&gt;tobefnz;  /* get first element */</span>
<span class='curline'><a href='../S/1200.html#L790'>g</a>                 790 src/lua/lgc.cpp   g-&gt;tobefnz = o-&gt;next;  /* remove it from 'tobefnz' list */</span>
<span class='curline'><a href='../S/1200.html#L791'>g</a>                 791 src/lua/lgc.cpp   o-&gt;next = g-&gt;allgc;  /* return it to 'allgc' list */</span>
<span class='curline'><a href='../S/1200.html#L792'>g</a>                 792 src/lua/lgc.cpp   g-&gt;allgc = o;</span>
<span class='curline'><a href='../S/1200.html#L794'>g</a>                 794 src/lua/lgc.cpp   if (issweepphase(g))</span>
<span class='curline'><a href='../S/1200.html#L795'>g</a>                 795 src/lua/lgc.cpp     makewhite(g, o);  /* "sweep" object */</span>
<span class='curline'><a href='../S/1200.html#L807'>g</a>                 807 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L810'>g</a>                 810 src/lua/lgc.cpp   setgcovalue(L, &amp;v, udata2finalize(g));</span>
<span class='curline'><a href='../S/1200.html#L815'>g</a>                 815 src/lua/lgc.cpp     int running  = g-&gt;gcrunning;</span>
<span class='curline'><a href='../S/1200.html#L817'>g</a>                 817 src/lua/lgc.cpp     g-&gt;gcrunning = 0;  /* avoid GC steps */</span>
<span class='curline'><a href='../S/1200.html#L823'>g</a>                 823 src/lua/lgc.cpp     g-&gt;gcrunning = running;  /* restore state */</span>
<span class='curline'><a href='../S/1200.html#L842'>g</a>                 842 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L844'>g</a>                 844 src/lua/lgc.cpp   lua_assert(!g-&gt;tobefnz || g-&gt;gcfinnum &gt; 0);</span>
<span class='curline'><a href='../S/1200.html#L845'>g</a>                 845 src/lua/lgc.cpp   for (i = 0; g-&gt;tobefnz &amp;&amp; i &lt; g-&gt;gcfinnum; i++)</span>
<span class='curline'><a href='../S/1200.html#L847'>g</a>                 847 src/lua/lgc.cpp   g-&gt;gcfinnum = (!g-&gt;tobefnz) ? 0  /* nothing more to finalize? */</span>
<span class='curline'><a href='../S/1200.html#L848'>g</a>                 848 src/lua/lgc.cpp                     : g-&gt;gcfinnum * 2;  /* else call a few more next time */</span>
<span class='curline'><a href='../S/1200.html#L857'>g</a>                 857 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L858'>g</a>                 858 src/lua/lgc.cpp   while (g-&gt;tobefnz)</span>
<span class='curline'><a href='../S/1200.html#L877'>g</a>                 877 src/lua/lgc.cpp static void separatetobefnz (global_State *g, int all) {</span>
<span class='curline'><a href='../S/1200.html#L879'>g</a>                 879 src/lua/lgc.cpp   GCObject **p = &amp;g-&gt;finobj;</span>
<span class='curline'><a href='../S/1200.html#L880'>g</a>                 880 src/lua/lgc.cpp   GCObject **lastnext = findlast(&amp;g-&gt;tobefnz);</span>
<span class='curline'><a href='../S/1200.html#L900'>g</a>                 900 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L902'>g</a>                 902 src/lua/lgc.cpp       gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */</span>
<span class='curline'><a href='../S/1200.html#L906'>g</a>                 906 src/lua/lgc.cpp     if (issweepphase(g)) {</span>
<span class='curline'><a href='../S/1200.html#L907'>g</a>                 907 src/lua/lgc.cpp       makewhite(g, o);  /* "sweep" object 'o' */</span>
<span class='curline'><a href='../S/1200.html#L908'>g</a>                 908 src/lua/lgc.cpp       if (g-&gt;sweepgc == &amp;o-&gt;next)  /* should not remove 'sweepgc' object */</span>
<span class='curline'><a href='../S/1200.html#L909'>g</a>                 909 src/lua/lgc.cpp         g-&gt;sweepgc = sweeptolive(L, g-&gt;sweepgc);  /* change 'sweepgc' */</span>
<span class='curline'><a href='../S/1200.html#L912'>g</a>                 912 src/lua/lgc.cpp     for (p = &amp;g-&gt;allgc; *p != o; p = &amp;(*p)-&gt;next) { /* empty */ }</span>
<span class='curline'><a href='../S/1200.html#L914'>g</a>                 914 src/lua/lgc.cpp     o-&gt;next = g-&gt;finobj;  /* link it in 'finobj' list */</span>
<span class='curline'><a href='../S/1200.html#L915'>g</a>                 915 src/lua/lgc.cpp     g-&gt;finobj = o;</span>
<span class='curline'><a href='../S/1200.html#L937'>g</a>                 937 src/lua/lgc.cpp static void setpause (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L939'>g</a>                 939 src/lua/lgc.cpp   l_mem estimate = g-&gt;GCestimate / PAUSEADJ;  /* adjust 'estimate' */</span>
<span class='curline'><a href='../S/1200.html#L941'>g</a>                 941 src/lua/lgc.cpp   threshold = (g-&gt;gcpause &lt; MAX_LMEM / estimate)  /* overflow? */</span>
<span class='curline'><a href='../S/1200.html#L942'>g</a>                 942 src/lua/lgc.cpp             ? estimate * g-&gt;gcpause  /* no overflow */</span>
<span class='curline'><a href='../S/1200.html#L944'>g</a>                 944 src/lua/lgc.cpp   debt = gettotalbytes(g) - threshold;</span>
<span class='curline'><a href='../S/1200.html#L945'>g</a>                 945 src/lua/lgc.cpp   luaE_setdebt(g, debt);</span>
<span class='curline'><a href='../S/1200.html#L957'>g</a>                 957 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L958'>g</a>                 958 src/lua/lgc.cpp   g-&gt;gcstate = GCSswpallgc;</span>
<span class='curline'><a href='../S/1200.html#L959'>g</a>                 959 src/lua/lgc.cpp   lua_assert(g-&gt;sweepgc == NULL);</span>
<span class='curline'><a href='../S/1200.html#L960'>g</a>                 960 src/lua/lgc.cpp   g-&gt;sweepgc = sweeplist(L, &amp;g-&gt;allgc, 1);</span>
<span class='curline'><a href='../S/1200.html#L965'>g</a>                 965 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L966'>g</a>                 966 src/lua/lgc.cpp   separatetobefnz(g, 1);  /* separate all objects with finalizers */</span>
<span class='curline'><a href='../S/1200.html#L967'>g</a>                 967 src/lua/lgc.cpp   lua_assert(g-&gt;finobj == NULL);</span>
<span class='curline'><a href='../S/1200.html#L969'>g</a>                 969 src/lua/lgc.cpp   lua_assert(g-&gt;tobefnz == NULL);</span>
<span class='curline'><a href='../S/1200.html#L970'>g</a>                 970 src/lua/lgc.cpp   g-&gt;currentwhite = WHITEBITS; /* this "white" makes all objects look dead */</span>
<span class='curline'><a href='../S/1200.html#L971'>g</a>                 971 src/lua/lgc.cpp   g-&gt;gckind = KGC_NORMAL;</span>
<span class='curline'><a href='../S/1200.html#L972'>g</a>                 972 src/lua/lgc.cpp   sweepwholelist(L, &amp;g-&gt;finobj);</span>
<span class='curline'><a href='../S/1200.html#L973'>g</a>                 973 src/lua/lgc.cpp   sweepwholelist(L, &amp;g-&gt;allgc);</span>
<span class='curline'><a href='../S/1200.html#L974'>g</a>                 974 src/lua/lgc.cpp   sweepwholelist(L, &amp;g-&gt;fixedgc);  /* collect fixed objects */</span>
<span class='curline'><a href='../S/1200.html#L975'>g</a>                 975 src/lua/lgc.cpp   lua_assert(g-&gt;strt.nuse == 0);</span>
<span class='curline'><a href='../S/1200.html#L980'>g</a>                 980 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L983'>g</a>                 983 src/lua/lgc.cpp   GCObject *grayagain = g-&gt;grayagain;  /* save original list */</span>
<span class='curline'><a href='../S/1200.html#L984'>g</a>                 984 src/lua/lgc.cpp   lua_assert(g-&gt;ephemeron == NULL &amp;&amp; g-&gt;weak == NULL);</span>
<span class='curline'><a href='../S/1200.html#L985'>g</a>                 985 src/lua/lgc.cpp   lua_assert(!iswhite(g-&gt;mainthread));</span>
<span class='curline'><a href='../S/1200.html#L986'>g</a>                 986 src/lua/lgc.cpp   g-&gt;gcstate = GCSinsideatomic;</span>
<span class='curline'><a href='../S/1200.html#L987'>g</a>                 987 src/lua/lgc.cpp   g-&gt;GCmemtrav = 0;  /* start counting work */</span>
<span class='curline'><a href='../S/1200.html#L988'>g</a>                 988 src/lua/lgc.cpp   markobject(g, L);  /* mark running thread */</span>
<span class='curline'><a href='../S/1200.html#L990'>g</a>                 990 src/lua/lgc.cpp   markvalue(g, &amp;g-&gt;l_registry);</span>
<span class='curline'><a href='../S/1200.html#L991'>g</a>                 991 src/lua/lgc.cpp   markmt(g);  /* mark global metatables */</span>
<span class='curline'><a href='../S/1200.html#L993'>g</a>                 993 src/lua/lgc.cpp   remarkupvals(g);</span>
<span class='curline'><a href='../S/1200.html#L994'>g</a>                 994 src/lua/lgc.cpp   propagateall(g);  /* propagate changes */</span>
<span class='curline'><a href='../S/1200.html#L995'>g</a>                 995 src/lua/lgc.cpp   work = g-&gt;GCmemtrav;  /* stop counting (do not recount 'grayagain') */</span>
<span class='curline'><a href='../S/1200.html#L996'>g</a>                 996 src/lua/lgc.cpp   g-&gt;gray = grayagain;</span>
<span class='curline'><a href='../S/1200.html#L997'>g</a>                 997 src/lua/lgc.cpp   propagateall(g);  /* traverse 'grayagain' list */</span>
<span class='curline'><a href='../S/1200.html#L998'>g</a>                 998 src/lua/lgc.cpp   g-&gt;GCmemtrav = 0;  /* restart counting */</span>
<span class='curline'><a href='../S/1200.html#L999'>g</a>                 999 src/lua/lgc.cpp   convergeephemerons(g);</span>
<span class='curline'><a href='../S/1200.html#L1002'>g</a>                1002 src/lua/lgc.cpp   clearvalues(g, g-&gt;weak, NULL);</span>
<span class='curline'><a href='../S/1200.html#L1003'>g</a>                1003 src/lua/lgc.cpp   clearvalues(g, g-&gt;allweak, NULL);</span>
<span class='curline'><a href='../S/1200.html#L1004'>g</a>                1004 src/lua/lgc.cpp   origweak = g-&gt;weak; origall = g-&gt;allweak;</span>
<span class='curline'><a href='../S/1200.html#L1005'>g</a>                1005 src/lua/lgc.cpp   work += g-&gt;GCmemtrav;  /* stop counting (objects being finalized) */</span>
<span class='curline'><a href='../S/1200.html#L1006'>g</a>                1006 src/lua/lgc.cpp   separatetobefnz(g, 0);  /* separate objects to be finalized */</span>
<span class='curline'><a href='../S/1200.html#L1007'>g</a>                1007 src/lua/lgc.cpp   g-&gt;gcfinnum = 1;  /* there may be objects to be finalized */</span>
<span class='curline'><a href='../S/1200.html#L1008'>g</a>                1008 src/lua/lgc.cpp   markbeingfnz(g);  /* mark objects that will be finalized */</span>
<span class='curline'><a href='../S/1200.html#L1009'>g</a>                1009 src/lua/lgc.cpp   propagateall(g);  /* remark, to propagate 'resurrection' */</span>
<span class='curline'><a href='../S/1200.html#L1010'>g</a>                1010 src/lua/lgc.cpp   g-&gt;GCmemtrav = 0;  /* restart counting */</span>
<span class='curline'><a href='../S/1200.html#L1011'>g</a>                1011 src/lua/lgc.cpp   convergeephemerons(g);</span>
<span class='curline'><a href='../S/1200.html#L1014'>g</a>                1014 src/lua/lgc.cpp   clearkeys(g, g-&gt;ephemeron, NULL);  /* clear keys from all ephemeron tables */</span>
<span class='curline'><a href='../S/1200.html#L1015'>g</a>                1015 src/lua/lgc.cpp   clearkeys(g, g-&gt;allweak, NULL);  /* clear keys from all 'allweak' tables */</span>
<span class='curline'><a href='../S/1200.html#L1017'>g</a>                1017 src/lua/lgc.cpp   clearvalues(g, g-&gt;weak, origweak);</span>
<span class='curline'><a href='../S/1200.html#L1018'>g</a>                1018 src/lua/lgc.cpp   clearvalues(g, g-&gt;allweak, origall);</span>
<span class='curline'><a href='../S/1200.html#L1019'>g</a>                1019 src/lua/lgc.cpp   luaS_clearcache(g);</span>
<span class='curline'><a href='../S/1200.html#L1020'>g</a>                1020 src/lua/lgc.cpp   g-&gt;currentwhite = cast_byte(otherwhite(g));  /* flip current white */</span>
<span class='curline'><a href='../S/1200.html#L1021'>g</a>                1021 src/lua/lgc.cpp   work += g-&gt;GCmemtrav;  /* complete counting */</span>
<span class='curline'><a href='../S/1200.html#L1026'>g</a>                1026 src/lua/lgc.cpp static lu_mem sweepstep (lua_State *L, global_State *g,</span>
<span class='curline'><a href='../S/1200.html#L1028'>g</a>                1028 src/lua/lgc.cpp   if (g-&gt;sweepgc) {</span>
<span class='curline'><a href='../S/1200.html#L1029'>g</a>                1029 src/lua/lgc.cpp     l_mem olddebt = g-&gt;GCdebt;</span>
<span class='curline'><a href='../S/1200.html#L1030'>g</a>                1030 src/lua/lgc.cpp     g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span>
<span class='curline'><a href='../S/1200.html#L1031'>g</a>                1031 src/lua/lgc.cpp     g-&gt;GCestimate += g-&gt;GCdebt - olddebt;  /* update estimate */</span>
<span class='curline'><a href='../S/1200.html#L1032'>g</a>                1032 src/lua/lgc.cpp     if (g-&gt;sweepgc)  /* is there still something to sweep? */</span>
<span class='curline'><a href='../S/1200.html#L1036'>g</a>                1036 src/lua/lgc.cpp   g-&gt;gcstate = nextstate;</span>
<span class='curline'><a href='../S/1200.html#L1037'>g</a>                1037 src/lua/lgc.cpp   g-&gt;sweepgc = nextlist;</span>
<span class='curline'><a href='../S/1200.html#L1043'>g</a>                1043 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L1044'>g</a>                1044 src/lua/lgc.cpp   switch (g-&gt;gcstate) {</span>
<span class='curline'><a href='../S/1200.html#L1046'>g</a>                1046 src/lua/lgc.cpp       g-&gt;GCmemtrav = g-&gt;strt.size * sizeof(GCObject*);</span>
<span class='curline'><a href='../S/1200.html#L1047'>g</a>                1047 src/lua/lgc.cpp       restartcollection(g);</span>
<span class='curline'><a href='../S/1200.html#L1048'>g</a>                1048 src/lua/lgc.cpp       g-&gt;gcstate = GCSpropagate;</span>
<span class='curline'><a href='../S/1200.html#L1049'>g</a>                1049 src/lua/lgc.cpp       return g-&gt;GCmemtrav;</span>
<span class='curline'><a href='../S/1200.html#L1052'>g</a>                1052 src/lua/lgc.cpp       g-&gt;GCmemtrav = 0;</span>
<span class='curline'><a href='../S/1200.html#L1053'>g</a>                1053 src/lua/lgc.cpp       lua_assert(g-&gt;gray);</span>
<span class='curline'><a href='../S/1200.html#L1054'>g</a>                1054 src/lua/lgc.cpp       propagatemark(g);</span>
<span class='curline'><a href='../S/1200.html#L1055'>g</a>                1055 src/lua/lgc.cpp        if (g-&gt;gray == NULL)  /* no more gray objects? */</span>
<span class='curline'><a href='../S/1200.html#L1056'>g</a>                1056 src/lua/lgc.cpp         g-&gt;gcstate = GCSatomic;  /* finish propagate phase */</span>
<span class='curline'><a href='../S/1200.html#L1057'>g</a>                1057 src/lua/lgc.cpp       return g-&gt;GCmemtrav;  /* memory traversed in this step */</span>
<span class='curline'><a href='../S/1200.html#L1061'>g</a>                1061 src/lua/lgc.cpp       propagateall(g);  /* make sure gray list is empty */</span>
<span class='curline'><a href='../S/1200.html#L1064'>g</a>                1064 src/lua/lgc.cpp       g-&gt;GCestimate = gettotalbytes(g);  /* first estimate */;</span>
<span class='curline'><a href='../S/1200.html#L1068'>g</a>                1068 src/lua/lgc.cpp       return sweepstep(L, g, GCSswpfinobj, &amp;g-&gt;finobj);</span>
<span class='curline'><a href='../S/1200.html#L1071'>g</a>                1071 src/lua/lgc.cpp       return sweepstep(L, g, GCSswptobefnz, &amp;g-&gt;tobefnz);</span>
<span class='curline'><a href='../S/1200.html#L1074'>g</a>                1074 src/lua/lgc.cpp       return sweepstep(L, g, GCSswpend, NULL);</span>
<span class='curline'><a href='../S/1200.html#L1077'>g</a>                1077 src/lua/lgc.cpp       makewhite(g, g-&gt;mainthread);  /* sweep main thread */</span>
<span class='curline'><a href='../S/1200.html#L1078'>g</a>                1078 src/lua/lgc.cpp       checkSizes(L, g);</span>
<span class='curline'><a href='../S/1200.html#L1079'>g</a>                1079 src/lua/lgc.cpp       g-&gt;gcstate = GCScallfin;</span>
<span class='curline'><a href='../S/1200.html#L1083'>g</a>                1083 src/lua/lgc.cpp       if (g-&gt;tobefnz &amp;&amp; g-&gt;gckind != KGC_EMERGENCY) {</span>
<span class='curline'><a href='../S/1200.html#L1088'>g</a>                1088 src/lua/lgc.cpp         g-&gt;gcstate = GCSpause;  /* finish collection */</span>
<span class='curline'><a href='../S/1200.html#L1102'>g</a>                1102 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L1103'>g</a>                1103 src/lua/lgc.cpp   while (!testbit(statesmask, g-&gt;gcstate))</span>
<span class='curline'><a href='../S/1200.html#L1112'>g</a>                1112 src/lua/lgc.cpp static l_mem getdebt (global_State *g) {</span>
<span class='curline'><a href='../S/1200.html#L1113'>g</a>                1113 src/lua/lgc.cpp   l_mem debt = g-&gt;GCdebt;</span>
<span class='curline'><a href='../S/1200.html#L1114'>g</a>                1114 src/lua/lgc.cpp   int stepmul = g-&gt;gcstepmul;</span>
<span class='curline'><a href='../S/1200.html#L1127'>g</a>                1127 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L1128'>g</a>                1128 src/lua/lgc.cpp   l_mem debt = getdebt(g);  /* GC deficit (be paid now) */</span>
<span class='curline'><a href='../S/1200.html#L1129'>g</a>                1129 src/lua/lgc.cpp   if (!g-&gt;gcrunning) {  /* not running? */</span>
<span class='curline'><a href='../S/1200.html#L1130'>g</a>                1130 src/lua/lgc.cpp     luaE_setdebt(g, -GCSTEPSIZE * 10);  /* avoid being called too often */</span>
<span class='curline'><a href='../S/1200.html#L1136'>g</a>                1136 src/lua/lgc.cpp   } while (debt &gt; -GCSTEPSIZE &amp;&amp; g-&gt;gcstate != GCSpause);</span>
<span class='curline'><a href='../S/1200.html#L1137'>g</a>                1137 src/lua/lgc.cpp   if (g-&gt;gcstate == GCSpause)</span>
<span class='curline'><a href='../S/1200.html#L1138'>g</a>                1138 src/lua/lgc.cpp     setpause(g);  /* pause until next cycle */</span>
<span class='curline'><a href='../S/1200.html#L1140'>g</a>                1140 src/lua/lgc.cpp     debt = (debt / g-&gt;gcstepmul) * STEPMULADJ;  /* convert 'work units' to Kb */</span>
<span class='curline'><a href='../S/1200.html#L1141'>g</a>                1141 src/lua/lgc.cpp     luaE_setdebt(g, debt);</span>
<span class='curline'><a href='../S/1200.html#L1157'>g</a>                1157 src/lua/lgc.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1200.html#L1158'>g</a>                1158 src/lua/lgc.cpp   lua_assert(g-&gt;gckind == KGC_NORMAL);</span>
<span class='curline'><a href='../S/1200.html#L1159'>g</a>                1159 src/lua/lgc.cpp   if (isemergency) g-&gt;gckind = KGC_EMERGENCY;  /* set flag */</span>
<span class='curline'><a href='../S/1200.html#L1160'>g</a>                1160 src/lua/lgc.cpp   if (keepinvariant(g)) {  /* black objects? */</span>
<span class='curline'><a href='../S/1200.html#L1168'>g</a>                1168 src/lua/lgc.cpp   lua_assert(g-&gt;GCestimate == gettotalbytes(g));</span>
<span class='curline'><a href='../S/1200.html#L1170'>g</a>                1170 src/lua/lgc.cpp   g-&gt;gckind = KGC_NORMAL;</span>
<span class='curline'><a href='../S/1200.html#L1171'>g</a>                1171 src/lua/lgc.cpp   setpause(g);</span>
<span class='curline'><a href='../S/1195.html#L49'>g</a>                  49 src/lua/lgc.h  #define issweepphase(g)  \</span>
<span class='curline'><a href='../S/1195.html#L50'>g</a>                  50 src/lua/lgc.h  	(GCSswpallgc &lt;= (g)-&gt;gcstate &amp;&amp; (g)-&gt;gcstate &lt;= GCSswpend)</span>
<span class='curline'><a href='../S/1195.html#L61'>g</a>                  61 src/lua/lgc.h  #define keepinvariant(g)	((g)-&gt;gcstate &lt;= GCSatomic)</span>
<span class='curline'><a href='../S/1195.html#L94'>g</a>                  94 src/lua/lgc.h  #define otherwhite(g)	((g)-&gt;currentwhite ^ WHITEBITS)</span>
<span class='curline'><a href='../S/1195.html#L96'>g</a>                  96 src/lua/lgc.h  #define isdead(g,v)	isdeadm(otherwhite(g), (v)-&gt;marked)</span>
<span class='curline'><a href='../S/1195.html#L101'>g</a>                 101 src/lua/lgc.h  #define luaC_white(g)	cast(lu_byte, (g)-&gt;currentwhite &amp; WHITEBITS)</span>
<span class='curline'><a href='../S/1165.html#L79'>g</a>                  79 src/lua/lmem.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1165.html#L83'>g</a>                  83 src/lua/lmem.cpp   if (nsize &gt; realosize &amp;&amp; g-&gt;gcrunning)</span>
<span class='curline'><a href='../S/1165.html#L86'>g</a>                  86 src/lua/lmem.cpp   newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);</span>
<span class='curline'><a href='../S/1165.html#L89'>g</a>                  89 src/lua/lmem.cpp     if (g-&gt;version) {  /* is state fully built? */</span>
<span class='curline'><a href='../S/1165.html#L91'>g</a>                  91 src/lua/lmem.cpp       newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  /* try again */</span>
<span class='curline'><a href='../S/1165.html#L97'>g</a>                  97 src/lua/lmem.cpp   g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;</span>
<span class='curline'><a href='../S/1217.html#L341'>g</a>                 341 src/lua/lparser.cpp static void closegoto (LexState *ls, int g, Labeldesc *label) {</span>
<span class='curline'><a href='../S/1217.html#L345'>g</a>                 345 src/lua/lparser.cpp   Labeldesc *gt = &amp;gl-&gt;arr[g];</span>
<span class='curline'><a href='../S/1217.html#L356'>g</a>                 356 src/lua/lparser.cpp   for (i = g; i &lt; gl-&gt;n - 1; i++)</span>
<span class='curline'><a href='../S/1217.html#L365'>g</a>                 365 src/lua/lparser.cpp static int findlabel (LexState *ls, int g) {</span>
<span class='curline'><a href='../S/1217.html#L369'>g</a>                 369 src/lua/lparser.cpp   Labeldesc *gt = &amp;dyd-&gt;gt.arr[g];</span>
<span class='curline'><a href='../S/1217.html#L377'>g</a>                 377 src/lua/lparser.cpp       closegoto(ls, g, lb);  /* close it */</span>
<span class='curline'><a href='../S/1217.html#L1191'>g</a>                1191 src/lua/lparser.cpp   int g;</span>
<span class='curline'><a href='../S/1217.html#L1198'>g</a>                1198 src/lua/lparser.cpp   g = newlabelentry(ls, &amp;ls-&gt;dyd-&gt;gt, label, line, pc);</span>
<span class='curline'><a href='../S/1217.html#L1199'>g</a>                1199 src/lua/lparser.cpp   findlabel(ls, g);  /* close it if label already defined */</span>
<span class='curline'><a href='../S/1181.html#L65'>g</a>                  65 src/lua/lstate.cpp   global_State g;</span>
<span class='curline'><a href='../S/1181.html#L98'>g</a>                  98 src/lua/lstate.cpp void luaE_setdebt (global_State *g, l_mem debt) {</span>
<span class='curline'><a href='../S/1181.html#L99'>g</a>                  99 src/lua/lstate.cpp   l_mem tb = gettotalbytes(g);</span>
<span class='curline'><a href='../S/1181.html#L103'>g</a>                 103 src/lua/lstate.cpp   g-&gt;totalbytes = tb - debt;</span>
<span class='curline'><a href='../S/1181.html#L104'>g</a>                 104 src/lua/lstate.cpp   g-&gt;GCdebt = debt;</span>
<span class='curline'><a href='../S/1181.html#L184'>g</a>                 184 src/lua/lstate.cpp static void init_registry (lua_State *L, global_State *g) {</span>
<span class='curline'><a href='../S/1181.html#L188'>g</a>                 188 src/lua/lstate.cpp   sethvalue(L, &amp;g-&gt;l_registry, registry);</span>
<span class='curline'><a href='../S/1181.html#L204'>g</a>                 204 src/lua/lstate.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1181.html#L207'>g</a>                 207 src/lua/lstate.cpp   init_registry(L, g);</span>
<span class='curline'><a href='../S/1181.html#L211'>g</a>                 211 src/lua/lstate.cpp   g-&gt;gcrunning = 1;  /* allow gc */</span>
<span class='curline'><a href='../S/1181.html#L212'>g</a>                 212 src/lua/lstate.cpp   g-&gt;version = lua_version(NULL);</span>
<span class='curline'><a href='../S/1181.html#L221'>g</a>                 221 src/lua/lstate.cpp static void preinit_thread (lua_State *L, global_State *g) {</span>
<span class='curline'><a href='../S/1181.html#L222'>g</a>                 222 src/lua/lstate.cpp   G(L) = g;</span>
<span class='curline'><a href='../S/1181.html#L243'>g</a>                 243 src/lua/lstate.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1181.html#L246'>g</a>                 246 src/lua/lstate.cpp   if (g-&gt;version)  /* closing a fully built state? */</span>
<span class='curline'><a href='../S/1181.html#L250'>g</a>                 250 src/lua/lstate.cpp   lua_assert(gettotalbytes(g) == sizeof(LG));</span>
<span class='curline'><a href='../S/1181.html#L251'>g</a>                 251 src/lua/lstate.cpp   (*g-&gt;frealloc)(g-&gt;ud, fromstate(L), sizeof(LG), 0);  /* free main block */</span>
<span class='curline'><a href='../S/1181.html#L256'>g</a>                 256 src/lua/lstate.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1181.html#L262'>g</a>                 262 src/lua/lstate.cpp   L1-&gt;marked = luaC_white(g);</span>
<span class='curline'><a href='../S/1181.html#L265'>g</a>                 265 src/lua/lstate.cpp   L1-&gt;next = g-&gt;allgc;</span>
<span class='curline'><a href='../S/1181.html#L266'>g</a>                 266 src/lua/lstate.cpp   g-&gt;allgc = obj2gco(L1);</span>
<span class='curline'><a href='../S/1181.html#L270'>g</a>                 270 src/lua/lstate.cpp   preinit_thread(L1, g);</span>
<span class='curline'><a href='../S/1181.html#L276'>g</a>                 276 src/lua/lstate.cpp   memcpy(lua_getextraspace(L1), lua_getextraspace(g-&gt;mainthread),</span>
<span class='curline'><a href='../S/1181.html#L298'>g</a>                 298 src/lua/lstate.cpp   global_State *g;</span>
<span class='curline'><a href='../S/1181.html#L302'>g</a>                 302 src/lua/lstate.cpp   g = &amp;l-&gt;g;</span>
<span class='curline'><a href='../S/1181.html#L305'>g</a>                 305 src/lua/lstate.cpp   g-&gt;currentwhite = bitmask(WHITE0BIT);</span>
<span class='curline'><a href='../S/1181.html#L306'>g</a>                 306 src/lua/lstate.cpp   L-&gt;marked = luaC_white(g);</span>
<span class='curline'><a href='../S/1181.html#L307'>g</a>                 307 src/lua/lstate.cpp   preinit_thread(L, g);</span>
<span class='curline'><a href='../S/1181.html#L308'>g</a>                 308 src/lua/lstate.cpp   g-&gt;frealloc = f;</span>
<span class='curline'><a href='../S/1181.html#L309'>g</a>                 309 src/lua/lstate.cpp   g-&gt;ud = ud;</span>
<span class='curline'><a href='../S/1181.html#L310'>g</a>                 310 src/lua/lstate.cpp   g-&gt;mainthread = L;</span>
<span class='curline'><a href='../S/1181.html#L311'>g</a>                 311 src/lua/lstate.cpp   g-&gt;seed = makeseed(L);</span>
<span class='curline'><a href='../S/1181.html#L312'>g</a>                 312 src/lua/lstate.cpp   g-&gt;gcrunning = 0;  /* no GC while building state */</span>
<span class='curline'><a href='../S/1181.html#L313'>g</a>                 313 src/lua/lstate.cpp   g-&gt;GCestimate = 0;</span>
<span class='curline'><a href='../S/1181.html#L314'>g</a>                 314 src/lua/lstate.cpp   g-&gt;strt.size = g-&gt;strt.nuse = 0;</span>
<span class='curline'><a href='../S/1181.html#L315'>g</a>                 315 src/lua/lstate.cpp   g-&gt;strt.hash = NULL;</span>
<span class='curline'><a href='../S/1181.html#L316'>g</a>                 316 src/lua/lstate.cpp   setnilvalue(&amp;g-&gt;l_registry);</span>
<span class='curline'><a href='../S/1181.html#L317'>g</a>                 317 src/lua/lstate.cpp   g-&gt;panic = NULL;</span>
<span class='curline'><a href='../S/1181.html#L318'>g</a>                 318 src/lua/lstate.cpp   g-&gt;version = NULL;</span>
<span class='curline'><a href='../S/1181.html#L319'>g</a>                 319 src/lua/lstate.cpp   g-&gt;gcstate = GCSpause;</span>
<span class='curline'><a href='../S/1181.html#L320'>g</a>                 320 src/lua/lstate.cpp   g-&gt;gckind = KGC_NORMAL;</span>
<span class='curline'><a href='../S/1181.html#L321'>g</a>                 321 src/lua/lstate.cpp   g-&gt;allgc = g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL;</span>
<span class='curline'><a href='../S/1181.html#L322'>g</a>                 322 src/lua/lstate.cpp   g-&gt;sweepgc = NULL;</span>
<span class='curline'><a href='../S/1181.html#L323'>g</a>                 323 src/lua/lstate.cpp   g-&gt;gray = g-&gt;grayagain = NULL;</span>
<span class='curline'><a href='../S/1181.html#L324'>g</a>                 324 src/lua/lstate.cpp   g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL;</span>
<span class='curline'><a href='../S/1181.html#L325'>g</a>                 325 src/lua/lstate.cpp   g-&gt;twups = NULL;</span>
<span class='curline'><a href='../S/1181.html#L326'>g</a>                 326 src/lua/lstate.cpp   g-&gt;totalbytes = sizeof(LG);</span>
<span class='curline'><a href='../S/1181.html#L327'>g</a>                 327 src/lua/lstate.cpp   g-&gt;GCdebt = 0;</span>
<span class='curline'><a href='../S/1181.html#L328'>g</a>                 328 src/lua/lstate.cpp   g-&gt;gcfinnum = 0;</span>
<span class='curline'><a href='../S/1181.html#L329'>g</a>                 329 src/lua/lstate.cpp   g-&gt;gcpause = LUAI_GCPAUSE;</span>
<span class='curline'><a href='../S/1181.html#L330'>g</a>                 330 src/lua/lstate.cpp   g-&gt;gcstepmul = LUAI_GCMUL;</span>
<span class='curline'><a href='../S/1181.html#L331'>g</a>                 331 src/lua/lstate.cpp   for (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL;</span>
<span class='curline'><a href='../S/1175.html#L224'>g</a>                 224 src/lua/lstate.h #define gettotalbytes(g)	cast(lu_mem, (g)-&gt;totalbytes + (g)-&gt;GCdebt)</span>
<span class='curline'><a href='../S/1175.html#L226'>g</a>                 226 src/lua/lstate.h LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);</span>
<span class='curline'><a href='../S/1177.html#L103'>g</a>                 103 src/lua/lstring.cpp void luaS_clearcache (global_State *g) {</span>
<span class='curline'><a href='../S/1177.html#L107'>g</a>                 107 src/lua/lstring.cpp     if (iswhite(g-&gt;strcache[i][j]))  /* will entry be collected? */</span>
<span class='curline'><a href='../S/1177.html#L108'>g</a>                 108 src/lua/lstring.cpp       g-&gt;strcache[i][j] = g-&gt;memerrmsg;  /* replace it with something fixed */</span>
<span class='curline'><a href='../S/1177.html#L117'>g</a>                 117 src/lua/lstring.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1177.html#L121'>g</a>                 121 src/lua/lstring.cpp   g-&gt;memerrmsg = luaS_newliteral(L, MEMERRMSG);</span>
<span class='curline'><a href='../S/1177.html#L122'>g</a>                 122 src/lua/lstring.cpp   luaC_fix(L, obj2gco(g-&gt;memerrmsg));  /* it should never be collected */</span>
<span class='curline'><a href='../S/1177.html#L125'>g</a>                 125 src/lua/lstring.cpp       g-&gt;strcache[i][j] = g-&gt;memerrmsg;</span>
<span class='curline'><a href='../S/1177.html#L169'>g</a>                 169 src/lua/lstring.cpp   global_State *g = G(L);</span>
<span class='curline'><a href='../S/1177.html#L170'>g</a>                 170 src/lua/lstring.cpp   unsigned int h = luaS_hash(str, l, g-&gt;seed);</span>
<span class='curline'><a href='../S/1177.html#L171'>g</a>                 171 src/lua/lstring.cpp   TString **list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];</span>
<span class='curline'><a href='../S/1177.html#L177'>g</a>                 177 src/lua/lstring.cpp       if (isdead(g, ts))  /* dead (but not collected yet)? */</span>
<span class='curline'><a href='../S/1177.html#L182'>g</a>                 182 src/lua/lstring.cpp   if (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/2) {</span>
<span class='curline'><a href='../S/1177.html#L183'>g</a>                 183 src/lua/lstring.cpp     luaS_resize(L, g-&gt;strt.size * 2);</span>
<span class='curline'><a href='../S/1177.html#L184'>g</a>                 184 src/lua/lstring.cpp     list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  /* recompute with new size */</span>
<span class='curline'><a href='../S/1177.html#L191'>g</a>                 191 src/lua/lstring.cpp   g-&gt;strt.nuse++;</span>
<span class='curline'><a href='../S/1210.html#L40'>g</a>                  40 src/lua/lstring.h LUAI_FUNC void luaS_clearcache (global_State *g);</span>
<span class='curline'><a href='../S/1197.html#L48'>g</a>                  48 src/lua/ltm.h  #define gfasttm(g,et,e) ((et) == NULL ? NULL : \</span>
<span class='curline'><a href='../S/1197.html#L49'>g</a>                  49 src/lua/ltm.h    ((et)-&gt;flags &amp; (1u&lt;&lt;(e))) ? NULL : luaT_gettm(et, e, (g)-&gt;tmname[e]))</span>
<span class='curline'><a href='../S/755.html#L208'>g</a>                 208 src/minimap.cpp 							if (tmp.g &lt; 50) tmp.g = 0;</span>
<span class='curline'><a href='../S/755.html#L209'>g</a>                 209 src/minimap.cpp 							else tmp.g -= 50;</span>
<span class='curline'><a href='../S/755.html#L217'>g</a>                 217 src/minimap.cpp 							if (tmp.g &gt; 205) tmp.g = 255;</span>
<span class='curline'><a href='../S/755.html#L218'>g</a>                 218 src/minimap.cpp 							else tmp.g += 50;</span>
<span class='curline'><a href='../S/755.html#L228'>g</a>                 228 src/minimap.cpp 							col.g = col.g - (col.g - tmp.g)/2;</span>
<span class='curline'><a href='../S/755.html#L233'>g</a>                 233 src/minimap.cpp 					const Uint32 mapped_col = SDL_MapRGB(minimap-&gt;format,col.r,col.g,col.b);</span>
<span class='curline'><a href='../S/755.html#L273'>g</a>                 273 src/minimap.cpp 				const Uint32 mapped_col = SDL_MapRGB(minimap-&gt;format,col.r,col.g,col.b);</span>
<span class='curline'><a href='../S/848.html#L64'>g</a>                  64 src/pathfind/astarsearch.cpp 	double g, h, t;</span>
<span class='curline'><a href='../S/848.html#L74'>g</a>                  74 src/pathfind/astarsearch.cpp 		: g(1e25)</span>
<span class='curline'><a href='../S/848.html#L83'>g</a>                  83 src/pathfind/astarsearch.cpp 		g(s), h(heuristic(c, dst)), t(g + h), curr(c), prev(p), in(search_counter + i)</span>
<span class='curline'><a href='../S/848.html#L110'>g</a>                 110 src/pathfind/astarsearch.cpp 				t = g + h;</span>
<span class='curline'><a href='../S/848.html#L172'>g</a>                 172 src/pathfind/astarsearch.cpp 	nodes[index(dst)].g = stop_at + 1;</span>
<span class='curline'><a href='../S/848.html#L186'>g</a>                 186 src/pathfind/astarsearch.cpp 		if (n.t &gt;= nodes[index(dst)].g) break;</span>
<span class='curline'><a href='../S/848.html#L206'>g</a>                 206 src/pathfind/astarsearch.cpp 			double thresh = (next.in - search_counter &lt;= 1u) ? next.g : stop_at + 1;</span>
<span class='curline'><a href='../S/848.html#L208'>g</a>                 208 src/pathfind/astarsearch.cpp 			if (n.g + 1 &gt;= thresh) continue;</span>
<span class='curline'><a href='../S/848.html#L209'>g</a>                 209 src/pathfind/astarsearch.cpp 			double cost = n.g + calc.cost(locs[i], n.g);</span>
<span class='curline'><a href='../S/848.html#L226'>g</a>                 226 src/pathfind/astarsearch.cpp 	if (nodes[index(dst)].g &lt;= stop_at) {</span>
<span class='curline'><a href='../S/848.html#L228'>g</a>                 228 src/pathfind/astarsearch.cpp 		route.move_cost = static_cast&lt;int&gt;(nodes[index(dst)].g);</span>
<span class='curline'><a href='../S/762.html#L97'>g</a>                  97 src/reports.cpp 	report_generator_helper(const char *name, reports::generator_function g)</span>
<span class='curline'><a href='../S/762.html#L99'>g</a>                  99 src/reports.cpp 		static_generators.insert(static_report_generators::value_type(name, g));</span>
<span class='curline'><a href='../S/762.html#L1548'>g</a>                1548 src/reports.cpp void reports::register_generator(const std::string &amp;name, reports::generator *g)</span>
<span class='curline'><a href='../S/762.html#L1550'>g</a>                1550 src/reports.cpp 	dynamic_generators_[name] = std::shared_ptr&lt;reports::generator&gt;(g);</span>
<span class='curline'><a href='../S/185.html#L1092'>g</a>                1092 src/scripting/game_lua_kernel.cpp 	lua_pushinteger(L, tod.color.g);</span>
<span class='curline'><a href='../S/977.html#L66'>g</a>                  66 src/sdl/rect.cpp 	SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);</span>
<span class='curline'><a href='../S/977.html#L74'>g</a>                  74 src/sdl/rect.cpp 	SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);</span>
<span class='curline'><a href='../S/980.html#L306'>g</a>                 306 src/sdl/utils.cpp 				Uint8 r,g,b,a;</span>
<span class='curline'><a href='../S/980.html#L354'>g</a>                 354 src/sdl/utils.cpp 				  g = pix[loc] &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L365'>g</a>                 365 src/sdl/utils.cpp 				  gg += g * temp;</span>
<span class='curline'><a href='../S/980.html#L377'>g</a>                 377 src/sdl/utils.cpp 				g = gg &gt;&gt; (16);</span>
<span class='curline'><a href='../S/980.html#L379'>g</a>                 379 src/sdl/utils.cpp 				*dst_word = (a &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L444'>g</a>                 444 src/sdl/utils.cpp 						Uint8 r,g,b,a;</span>
<span class='curline'><a href='../S/980.html#L446'>g</a>                 446 src/sdl/utils.cpp 						SDL_GetRGBA(src_pixels[ysrcint*src-&gt;w + xsrcint],src-&gt;format,&amp;r,&amp;g,&amp;b,&amp;a);</span>
<span class='curline'><a href='../S/980.html#L453'>g</a>                 453 src/sdl/utils.cpp 						green += g * value;</span>
<span class='curline'><a href='../S/980.html#L550'>g</a>                 550 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L552'>g</a>                 552 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L556'>g</a>                 556 src/sdl/utils.cpp 				g = std::max&lt;int&gt;(0,std::min&lt;int&gt;(255,int(g)+green));</span>
<span class='curline'><a href='../S/980.html#L559'>g</a>                 559 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L589'>g</a>                 589 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L591'>g</a>                 591 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L601'>g</a>                 601 src/sdl/utils.cpp 					150 * static_cast&lt;Uint16&gt;(g) +</span>
<span class='curline'><a href='../S/980.html#L634'>g</a>                 634 src/sdl/utils.cpp 				Uint8 r, g, b, result;</span>
<span class='curline'><a href='../S/980.html#L636'>g</a>                 636 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L642'>g</a>                 642 src/sdl/utils.cpp 				result = static_cast&lt;Uint8&gt;(0.299 * r + 0.587 * g + 0.114 * b) &gt; threshold ? 255 : 0;</span>
<span class='curline'><a href='../S/980.html#L674'>g</a>                 674 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L676'>g</a>                 676 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L682'>g</a>                 682 src/sdl/utils.cpp 				Uint8 outRed = std::min(255, static_cast&lt;int&gt;((r * 0.393) + (g * 0.769) + (b * 0.189)));</span>
<span class='curline'><a href='../S/980.html#L683'>g</a>                 683 src/sdl/utils.cpp 				Uint8 outGreen = std::min(255, static_cast&lt;int&gt;((r * 0.349) + (g * 0.686) + (b * 0.168)));</span>
<span class='curline'><a href='../S/980.html#L684'>g</a>                 684 src/sdl/utils.cpp 				Uint8 outBlue = std::min(255, static_cast&lt;int&gt;((r * 0.272) + (g * 0.534) + (b * 0.131)));</span>
<span class='curline'><a href='../S/980.html#L716'>g</a>                 716 src/sdl/utils.cpp 				Uint8 r, g, b, newR, newG, newB;</span>
<span class='curline'><a href='../S/980.html#L718'>g</a>                 718 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L726'>g</a>                 726 src/sdl/utils.cpp 				newG = g &gt; thresholdG ? 255 - g : g;</span>
<span class='curline'><a href='../S/980.html#L832'>g</a>                 832 src/sdl/utils.cpp surface swap_channels_image(const surface&amp; surf, channel r, channel g, channel b, channel a) {</span>
<span class='curline'><a href='../S/980.html#L873'>g</a>                 873 src/sdl/utils.cpp 				switch (g) {</span>
<span class='curline'><a href='../S/980.html#L996'>g</a>                 996 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L998'>g</a>                 998 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1002'>g</a>                1002 src/sdl/utils.cpp 				g = std::min&lt;unsigned&gt;(unsigned(fxpmult(g, amount)),255);</span>
<span class='curline'><a href='../S/980.html#L1005'>g</a>                1005 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L1046'>g</a>                1046 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L1048'>g</a>                1048 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1052'>g</a>                1052 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L1106'>g</a>                1106 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L1108'>g</a>                1108 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1118'>g</a>                1118 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L1197'>g</a>                1197 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L1199'>g</a>                1199 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1205'>g</a>                1205 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L1281'>g</a>                1281 src/sdl/utils.cpp 				Uint8 r, g, b;</span>
<span class='curline'><a href='../S/980.html#L1283'>g</a>                1283 src/sdl/utils.cpp 				g = (*beg) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1291'>g</a>                1291 src/sdl/utils.cpp 				g = std::max&lt;int&gt;(0,std::min&lt;int&gt;(255, g + dg));</span>
<span class='curline'><a href='../S/980.html#L1294'>g</a>                1294 src/sdl/utils.cpp 				*beg = (alpha &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</span>
<span class='curline'><a href='../S/980.html#L1644'>g</a>                1644 src/sdl/utils.cpp 		const Uint16 green = ratio * color.g;</span>
<span class='curline'><a href='../S/980.html#L1651'>g</a>                1651 src/sdl/utils.cpp 			Uint8 g = (ratio * static_cast&lt;Uint8&gt;(*beg &gt;&gt; 8)  + green) &gt;&gt; 8;</span>
<span class='curline'><a href='../S/980.html#L1654'>g</a>                1654 src/sdl/utils.cpp 			*beg = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;</span>
<span class='curline'><a href='../S/980.html#L2204'>g</a>                2204 src/sdl/utils.cpp 	Uint32 col = SDL_MapRGBA(target-&gt;format, color.r, color.g, color.b, color.a);</span>
<span class='curline'><a href='../S/980.html#L2217'>g</a>                2217 src/sdl/utils.cpp 	return {r, g, b, a};</span>
<span class='curline'><a href='../S/980.html#L2222'>g</a>                2222 src/sdl/utils.cpp 	, g(c.g)</span>
<span class='curline'><a href='../S/974.html#L136'>g</a>                 136 src/sdl/utils.hpp surface adjust_surface_color(const surface &amp;surf, int r, int g, int b);</span>
<span class='curline'><a href='../S/974.html#L147'>g</a>                 147 src/sdl/utils.hpp surface swap_channels_image(const surface&amp; surf, channel r, channel g, channel b, channel a);</span>
<span class='curline'><a href='../S/975.html#L101'>g</a>                 101 src/sdl/window.cpp void window::fill(Uint8 r, Uint8 g, Uint8 b, Uint8 a)</span>
<span class='curline'><a href='../S/975.html#L103'>g</a>                 103 src/sdl/window.cpp 	SDL_SetRenderDrawColor(*this, r, g, b, a);</span>
<span class='curline'><a href='../S/979.html#L118'>g</a>                 118 src/sdl/window.hpp 	void fill(Uint8 r, Uint8 g, Uint8 b, Uint8 a = 0);</span>
<span class='curline'><a href='../S/124.html#L150'>g</a>                 150 src/serialization/schema_validator.cpp 	for(const config &amp;g : cfg.child_range("wml_schema")) {</span>
<span class='curline'><a href='../S/124.html#L151'>g</a>                 151 src/serialization/schema_validator.cpp 		for(const config &amp;schema : g.child_range("tag")) {</span>
<span class='curline'><a href='../S/124.html#L157'>g</a>                 157 src/serialization/schema_validator.cpp 		for(const config &amp;type : g.child_range("type")) {</span>
<span class='curline'><a href='../S/149.html#L418'>g</a>                 418 src/server/game.hpp 	bool operator()(const game&amp; g) const { return g.is_owner(sock_) || g.is_member(sock_); }</span>
<span class='curline'><a href='../S/149.html#L426'>g</a>                 426 src/server/game.hpp 	bool operator()(const game&amp; g) const { return g.id() == id_; }</span>
<span class='curline'><a href='../S/168.html#L67'>g</a>                  67 src/server/player.hpp 	void set_game(game* g);</span>
<span class='curline'><a href='../S/158.html#L1131'>g</a>                1131 src/server/server.cpp 	wesnothd::game&amp; g = *host_record.get_game();</span>
<span class='curline'><a href='../S/158.html#L1133'>g</a>                1133 src/server/server.cpp 		g.set_password(game_password);</span>
<span class='curline'><a href='../S/158.html#L1136'>g</a>                1136 src/server/server.cpp 	create_game.copy_into(g.level().root());</span>
<span class='curline'><a href='../S/158.html#L1155'>g</a>                1155 src/server/server.cpp 	const simple_wml::node::child_list::const_iterator g =</span>
<span class='curline'><a href='../S/158.html#L1157'>g</a>                1157 src/server/server.cpp 	if (g != games.end()) {</span>
<span class='curline'><a href='../S/158.html#L1158'>g</a>                1158 src/server/server.cpp 		const size_t index = g - games.begin();</span>
<span class='curline'><a href='../S/158.html#L1175'>g</a>                1175 src/server/server.cpp 	std::shared_ptr&lt;game&gt; g;</span>
<span class='curline'><a href='../S/158.html#L1177'>g</a>                1177 src/server/server.cpp 		g = g_iter-&gt;get_game();</span>
<span class='curline'><a href='../S/158.html#L1180'>g</a>                1180 src/server/server.cpp 	if (!g) {</span>
<span class='curline'><a href='../S/158.html#L1187'>g</a>                1187 src/server/server.cpp 	} else if (!g-&gt;level_init()) {</span>
<span class='curline'><a href='../S/158.html#L1189'>g</a>                1189 src/server/server.cpp 				   &lt;&lt; "\tattempted to join uninitialized game:\t\"" &lt;&lt; g-&gt;name()</span>
<span class='curline'><a href='../S/158.html#L1197'>g</a>                1197 src/server/server.cpp 	} else if (g-&gt;registered_users_only() &amp;&amp; !player_connections_.find(socket)-&gt;info().registered()) {</span>
<span class='curline'><a href='../S/158.html#L1202'>g</a>                1202 src/server/server.cpp 	} else if (g-&gt;player_is_banned(socket)) {</span>
<span class='curline'><a href='../S/158.html#L1204'>g</a>                1204 src/server/server.cpp 				   &lt;&lt; player_connections_.find(socket)-&gt;info().name() &lt;&lt; "\tfrom game:\t\"" &lt;&lt; g-&gt;name()</span>
<span class='curline'><a href='../S/158.html#L1210'>g</a>                1210 src/server/server.cpp 	} else if(!observer &amp;&amp; !g-&gt;password_matches(password)) {</span>
<span class='curline'><a href='../S/158.html#L1212'>g</a>                1212 src/server/server.cpp 				   &lt;&lt; "\tattempted to join game:\t\"" &lt;&lt; g-&gt;name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1219'>g</a>                1219 src/server/server.cpp 	bool joined = g-&gt;add_player(socket, observer);</span>
<span class='curline'><a href='../S/158.html#L1222'>g</a>                1222 src/server/server.cpp 				   &lt;&lt; "\tattempted to observe game:\t\"" &lt;&lt; g-&gt;name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1232'>g</a>                1232 src/server/server.cpp 	g-&gt;describe_slots();</span>
<span class='curline'><a href='../S/158.html#L1237'>g</a>                1237 src/server/server.cpp 								  "gamelist", "game", g-&gt;description(), diff);</span>
<span class='curline'><a href='../S/158.html#L1250'>g</a>                1250 src/server/server.cpp 	game&amp; g = *(p-&gt;get_game());</span>
<span class='curline'><a href='../S/158.html#L1256'>g</a>                1256 src/server/server.cpp 		if (!g.is_owner(socket)) {</span>
<span class='curline'><a href='../S/158.html#L1265'>g</a>                1265 src/server/server.cpp 		if (!g.level_init()) {</span>
<span class='curline'><a href='../S/158.html#L1267'>g</a>                1267 src/server/server.cpp 					   &lt;&lt; "\tcreated game:\t\"" &lt;&lt; g.name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1268'>g</a>                1268 src/server/server.cpp 					   &lt;&lt; g.id() &lt;&lt; ").\n";</span>
<span class='curline'><a href='../S/158.html#L1274'>g</a>                1274 src/server/server.cpp 			g.level().root().copy_into(desc);</span>
<span class='curline'><a href='../S/158.html#L1279'>g</a>                1279 src/server/server.cpp 						   &lt;&lt; "\tsent scenario data in game:\t\"" &lt;&lt; g.name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1280'>g</a>                1280 src/server/server.cpp 						   &lt;&lt; g.id() &lt;&lt; ") without a 'multiplayer' child.\n";</span>
<span class='curline'><a href='../S/158.html#L1282'>g</a>                1282 src/server/server.cpp 				g.set_description(&amp;desc);</span>
<span class='curline'><a href='../S/158.html#L1283'>g</a>                1283 src/server/server.cpp 				delete_game(g.id());</span>
<span class='curline'><a href='../S/158.html#L1288'>g</a>                1288 src/server/server.cpp 			g.set_description(&amp;desc);</span>
<span class='curline'><a href='../S/158.html#L1289'>g</a>                1289 src/server/server.cpp 			desc.set_attr_dup("id", lexical_cast&lt;std::string&gt;(g.id()).c_str());</span>
<span class='curline'><a href='../S/158.html#L1292'>g</a>                1292 src/server/server.cpp 					   &lt;&lt; "\tsent scenario data in game:\t\"" &lt;&lt; g.name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1293'>g</a>                1293 src/server/server.cpp 					   &lt;&lt; g.id() &lt;&lt; ") although it's already initialized.\n";</span>
<span class='curline'><a href='../S/158.html#L1299'>g</a>                1299 src/server/server.cpp 		simple_wml::node&amp; desc = *g.description();</span>
<span class='curline'><a href='../S/158.html#L1326'>g</a>                1326 src/server/server.cpp 		g.level().swap(data);</span>
<span class='curline'><a href='../S/158.html#L1330'>g</a>                1330 src/server/server.cpp 		g.update_side_data();</span>
<span class='curline'><a href='../S/158.html#L1331'>g</a>                1331 src/server/server.cpp 		g.describe_slots();</span>
<span class='curline'><a href='../S/158.html#L1342'>g</a>                1342 src/server/server.cpp 	} else if (!g.level_init()) {</span>
<span class='curline'><a href='../S/158.html#L1349'>g</a>                1349 src/server/server.cpp 		if (!g.is_owner(socket)) return;</span>
<span class='curline'><a href='../S/158.html#L1350'>g</a>                1350 src/server/server.cpp 		if (!g.level_init()) {</span>
<span class='curline'><a href='../S/158.html#L1353'>g</a>                1353 src/server/server.cpp 					   &lt;&lt; g.name() &lt;&lt; "\" (" &lt;&lt; g.id()</span>
<span class='curline'><a href='../S/158.html#L1357'>g</a>                1357 src/server/server.cpp 		g.save_replay();</span>
<span class='curline'><a href='../S/158.html#L1358'>g</a>                1358 src/server/server.cpp 		g.reset_last_synced_context_id();</span>
<span class='curline'><a href='../S/158.html#L1360'>g</a>                1360 src/server/server.cpp 		g.level().clear();</span>
<span class='curline'><a href='../S/158.html#L1361'>g</a>                1361 src/server/server.cpp 		scenario-&gt;copy_into(g.level().root());</span>
<span class='curline'><a href='../S/158.html#L1363'>g</a>                1363 src/server/server.cpp 		if (g.description() == NULL) {</span>
<span class='curline'><a href='../S/158.html#L1365'>g</a>                1365 src/server/server.cpp 					   &lt;&lt; g.name() &lt;&lt; "\" (" &lt;&lt; g.id()</span>
<span class='curline'><a href='../S/158.html#L1369'>g</a>                1369 src/server/server.cpp 		simple_wml::node&amp; desc = *g.description();</span>
<span class='curline'><a href='../S/158.html#L1375'>g</a>                1375 src/server/server.cpp 					   &lt;&lt; "\tsent scenario data in game:\t\"" &lt;&lt; g.name() &lt;&lt; "\" ("</span>
<span class='curline'><a href='../S/158.html#L1376'>g</a>                1376 src/server/server.cpp 					   &lt;&lt; g.id() &lt;&lt; ") without a 'multiplayer' child.\n";</span>
<span class='curline'><a href='../S/158.html#L1377'>g</a>                1377 src/server/server.cpp 			delete_game(g.id());</span>
<span class='curline'><a href='../S/158.html#L1384'>g</a>                1384 src/server/server.cpp 		const simple_wml::node&amp; s = *wesnothd::game::starting_pos(g.level().root());</span>
<span class='curline'><a href='../S/158.html#L1401'>g</a>                1401 src/server/server.cpp 		g.send_data(notify_next_scenario, socket);</span>
<span class='curline'><a href='../S/158.html#L1404'>g</a>                1404 src/server/server.cpp 		update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1409'>g</a>                1409 src/server/server.cpp 		g.load_next_scenario(socket);</span>
<span class='curline'><a href='../S/158.html#L1412'>g</a>                1412 src/server/server.cpp 		if (!g.is_owner(socket)) return;</span>
<span class='curline'><a href='../S/158.html#L1414'>g</a>                1414 src/server/server.cpp 		g.perform_controller_tweaks();</span>
<span class='curline'><a href='../S/158.html#L1418'>g</a>                1418 src/server/server.cpp 		g.send_data(data, socket);</span>
<span class='curline'><a href='../S/158.html#L1419'>g</a>                1419 src/server/server.cpp 		g.start_game(socket);</span>
<span class='curline'><a href='../S/158.html#L1422'>g</a>                1422 src/server/server.cpp 		update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1425'>g</a>                1425 src/server/server.cpp 		g.update_game();</span>
<span class='curline'><a href='../S/158.html#L1426'>g</a>                1426 src/server/server.cpp 		update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1430'>g</a>                1430 src/server/server.cpp 		if ((g.is_player(socket) &amp;&amp; g.nplayers() == 1)</span>
<span class='curline'><a href='../S/158.html#L1431'>g</a>                1431 src/server/server.cpp 				|| (g.is_owner(socket) &amp;&amp; (!g.started() || g.nplayers() == 0))) {</span>
<span class='curline'><a href='../S/158.html#L1434'>g</a>                1434 src/server/server.cpp 			delete_game(g.id());</span>
<span class='curline'><a href='../S/158.html#L1436'>g</a>                1436 src/server/server.cpp 			g.remove_player(socket);</span>
<span class='curline'><a href='../S/158.html#L1438'>g</a>                1438 src/server/server.cpp 			g.describe_slots();</span>
<span class='curline'><a href='../S/158.html#L1443'>g</a>                1443 src/server/server.cpp 										  "gamelist", "game", g.description(), diff);</span>
<span class='curline'><a href='../S/158.html#L1456'>g</a>                1456 src/server/server.cpp 		if (!g.is_owner(socket)) return;</span>
<span class='curline'><a href='../S/158.html#L1457'>g</a>                1457 src/server/server.cpp 		g.level().root().apply_diff(*scenario_diff);</span>
<span class='curline'><a href='../S/158.html#L1464'>g</a>                1464 src/server/server.cpp 			g.update_side_data();</span>
<span class='curline'><a href='../S/158.html#L1466'>g</a>                1466 src/server/server.cpp 		if (g.describe_slots()) {</span>
<span class='curline'><a href='../S/158.html#L1467'>g</a>                1467 src/server/server.cpp 			update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1469'>g</a>                1469 src/server/server.cpp 		g.send_data(data, socket);</span>
<span class='curline'><a href='../S/158.html#L1473'>g</a>                1473 src/server/server.cpp 		g.send_data(data, socket);</span>
<span class='curline'><a href='../S/158.html#L1477'>g</a>                1477 src/server/server.cpp 		g.transfer_side_control(socket, *change);</span>
<span class='curline'><a href='../S/158.html#L1478'>g</a>                1478 src/server/server.cpp 		if (g.describe_slots()) {</span>
<span class='curline'><a href='../S/158.html#L1479'>g</a>                1479 src/server/server.cpp 			update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1484'>g</a>                1484 src/server/server.cpp 		if (!g.is_owner(socket)) {</span>
<span class='curline'><a href='../S/158.html#L1485'>g</a>                1485 src/server/server.cpp 			g.send_server_message("You cannot mute: not the game host.", socket);</span>
<span class='curline'><a href='../S/158.html#L1488'>g</a>                1488 src/server/server.cpp 		g.mute_all_observers();</span>
<span class='curline'><a href='../S/158.html#L1492'>g</a>                1492 src/server/server.cpp 		g.mute_observer(*mute, socket);</span>
<span class='curline'><a href='../S/158.html#L1496'>g</a>                1496 src/server/server.cpp 		g.unmute_observer(*unmute, socket);</span>
<span class='curline'><a href='../S/158.html#L1502'>g</a>                1502 src/server/server.cpp 				(ban ? g.ban_user(*data.child("ban"), socket)</span>
<span class='curline'><a href='../S/158.html#L1503'>g</a>                1503 src/server/server.cpp 					 : g.kick_member(*data.child("kick"), socket));</span>
<span class='curline'><a href='../S/158.html#L1506'>g</a>                1506 src/server/server.cpp 			if (g.describe_slots()) {</span>
<span class='curline'><a href='../S/158.html#L1507'>g</a>                1507 src/server/server.cpp 				update_game_in_lobby(g, user);</span>
<span class='curline'><a href='../S/158.html#L1512'>g</a>                1512 src/server/server.cpp 							 "gamelist", "game", g.description(), gamelist_diff);</span>
<span class='curline'><a href='../S/158.html#L1521'>g</a>                1521 src/server/server.cpp 		g.unban_user(*unban, socket);</span>
<span class='curline'><a href='../S/158.html#L1525'>g</a>                1525 src/server/server.cpp 		if (!g.is_player(socket)) return;</span>
<span class='curline'><a href='../S/158.html#L1527'>g</a>                1527 src/server/server.cpp 			g.set_termination_reason((*info)["condition"].to_string());</span>
<span class='curline'><a href='../S/158.html#L1529'>g</a>                1529 src/server/server.cpp 				g.send_server_message_to_all(player.name() + " reports out of sync errors.");</span>
<span class='curline'><a href='../S/158.html#L1537'>g</a>                1537 src/server/server.cpp 		if (g.process_turn(data, socket)) {</span>
<span class='curline'><a href='../S/158.html#L1538'>g</a>                1538 src/server/server.cpp 			update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1542'>g</a>                1542 src/server/server.cpp 		g.process_whiteboard(data,socket);</span>
<span class='curline'><a href='../S/158.html#L1545'>g</a>                1545 src/server/server.cpp 		g.process_change_turns_wml(data,socket);</span>
<span class='curline'><a href='../S/158.html#L1546'>g</a>                1546 src/server/server.cpp 		update_game_in_lobby(g);</span>
<span class='curline'><a href='../S/158.html#L1549'>g</a>                1549 src/server/server.cpp 		g.handle_choice(*sch, socket);</span>
<span class='curline'><a href='../S/158.html#L1552'>g</a>                1552 src/server/server.cpp 		g.process_message(data, socket);</span>
<span class='curline'><a href='../S/158.html#L1555'>g</a>                1555 src/server/server.cpp 		g.send_data(data, socket);</span>
<span class='curline'><a href='../S/158.html#L1568'>g</a>                1568 src/server/server.cpp 			   &lt;&lt; g.name() &lt;&lt; "\" (" &lt;&lt; g.id() &lt;&lt; ")\n" &lt;&lt; data.output();</span>
<span class='curline'><a href='../S/158.html#L1619'>g</a>                1619 src/server/server.cpp 	const std::shared_ptr&lt;game&gt; g = iter-&gt;get_game();</span>
<span class='curline'><a href='../S/158.html#L1620'>g</a>                1620 src/server/server.cpp 	if(g)</span>
<span class='curline'><a href='../S/158.html#L1621'>g</a>                1621 src/server/server.cpp 		g-&gt;remove_player(socket, true, false);</span>
<span class='curline'><a href='../S/158.html#L2696'>g</a>                2696 src/server/server.cpp void server::update_game_in_lobby(const wesnothd::game&amp; g, const socket_ptr&amp; exclude)</span>
<span class='curline'><a href='../S/158.html#L2699'>g</a>                2699 src/server/server.cpp 	if (make_change_diff(*games_and_users_list_.child("gamelist"), "gamelist", "game", g.description(), diff)) {</span>
<span class='curline'><a href='../S/153.html#L180'>g</a>                 180 src/server/server.hpp 	void update_game_in_lobby(const wesnothd::game&amp; g, const socket_ptr&amp; exclude=socket_ptr());</span>
<span class='curline'><a href='../S/706.html#L186'>g</a>                 186 src/tests/gui/iterator.cpp 	gui2::grid* g = new gui2::grid(2, 2);</span>
<span class='curline'><a href='../S/706.html#L187'>g</a>                 187 src/tests/gui/iterator.cpp 	add_widget(grid, g, "1", 0, 0);</span>
<span class='curline'><a href='../S/706.html#L192'>g</a>                 192 src/tests/gui/iterator.cpp 	add_widget(*g, new gui2::label(), "5", 0, 0);</span>
<span class='curline'><a href='../S/706.html#L193'>g</a>                 193 src/tests/gui/iterator.cpp 	add_widget(*g, new gui2::label(), "6", 1, 0);</span>
<span class='curline'><a href='../S/706.html#L194'>g</a>                 194 src/tests/gui/iterator.cpp 	add_widget(*g, new gui2::label(), "7", 0, 1);</span>
<span class='curline'><a href='../S/706.html#L195'>g</a>                 195 src/tests/gui/iterator.cpp 	add_widget(*g, new gui2::label(), "8", 1, 1);</span>
<span class='curline'><a href='../S/697.html#L811'>g</a>                 811 src/tests/test_image_modifications.cpp 	BOOST_CHECK_EQUAL(mod-&gt;get_color().g, 0);</span>
<span class='curline'><a href='../S/697.html#L831'>g</a>                 831 src/tests/test_image_modifications.cpp 	BOOST_CHECK_EQUAL(mod-&gt;get_color().g, 0);</span>
<span class='curline'><a href='../S/697.html#L851'>g</a>                 851 src/tests/test_image_modifications.cpp 	BOOST_CHECK_EQUAL(mod-&gt;get_color().g, 2);</span>
<span class='curline'><a href='../S/697.html#L871'>g</a>                 871 src/tests/test_image_modifications.cpp 	BOOST_CHECK_EQUAL(mod-&gt;get_color().g, 2);</span>
<span class='curline'><a href='../S/697.html#L891'>g</a>                 891 src/tests/test_image_modifications.cpp 	BOOST_CHECK_EQUAL(mod-&gt;get_color().g, 2);</span>
<span class='curline'><a href='../S/690.html#L24'>g</a>                  24 src/time_of_day.cpp 	s &lt;&lt; c.r &lt;&lt; "," &lt;&lt; c.g &lt;&lt; "," &lt;&lt; c.b;</span>
<span class='curline'><a href='../S/690.html#L58'>g</a>                  58 src/time_of_day.cpp 	cfg["green"] = color.g;</span>
<span class='curline'><a href='../S/922.html#L31'>g</a>                  31 src/time_of_day.hpp 		, g(utils::clamp(green, -255, 255))</span>
<span class='curline'><a href='../S/922.html#L35'>g</a>                  35 src/time_of_day.hpp 		return r == o.r &amp;&amp; g == o.g &amp;&amp; b == o.b;</span>
<span class='curline'><a href='../S/922.html#L38'>g</a>                  38 src/time_of_day.hpp 		return r == 0 &amp;&amp; g == 0 &amp;&amp; b == 0;</span>
<span class='curline'><a href='../S/922.html#L44'>g</a>                  44 src/time_of_day.hpp 		return tod_color(r + o.r, g + o.g, b + o.b);</span>
<span class='curline'><a href='../S/922.html#L47'>g</a>                  47 src/time_of_day.hpp 	int r,g,b;</span>
<span class='curline'><a href='../S/1012.html#L402'>g</a>                 402 src/units/drawer.cpp 		sdl::fill_surface_rect(filled_surf,&amp;filled_area,SDL_MapRGBA(bar_surf-&gt;format,col.r,col.g,col.b, r_alpha));</span>
<span class='curline'><a href='../S/997.html#L252'>g</a>                 252 src/units/types.cpp 	for(std::vector&lt;std::string&gt;::const_iterator g = genders.begin(); g != genders.end(); ++g) {</span>
<span class='curline'><a href='../S/997.html#L253'>g</a>                 253 src/units/types.cpp 		genders_.push_back(string_gender(*g));</span>
<span class='curline'><a href='../S/1008.html#L1050'>g</a>                1050 src/units/unit.cpp 		energy_color.g = 225;</span>
<span class='curline'><a href='../S/1008.html#L1054'>g</a>                1054 src/units/unit.cpp 		energy_color.g = 255;</span>
<span class='curline'><a href='../S/1008.html#L1058'>g</a>                1058 src/units/unit.cpp 		energy_color.g = 255;</span>
<span class='curline'><a href='../S/1008.html#L1062'>g</a>                1062 src/units/unit.cpp 		energy_color.g = 175;</span>
<span class='curline'><a href='../S/1008.html#L1066'>g</a>                1066 src/units/unit.cpp 		energy_color.g = 155;</span>
<span class='curline'><a href='../S/1008.html#L1070'>g</a>                1070 src/units/unit.cpp 		energy_color.g = 0;</span>
<span class='curline'><a href='../S/1081.html#L306'>g</a>                 306 src/xBRZ/xbrz.cpp     double g = getGreen(c) / 255.0;</span>
<span class='curline'><a href='../S/1081.html#L310'>g</a>                 310 src/xBRZ/xbrz.cpp     r = g &gt; 0.04045 ? std::pow(( g + 0.055 ) / 1.055, 2.4) : g / 12.92;</span>
<span class='curline'><a href='../S/1081.html#L314'>g</a>                 314 src/xBRZ/xbrz.cpp     g *= 100;</span>
<span class='curline'><a href='../S/1081.html#L317'>g</a>                 317 src/xBRZ/xbrz.cpp     double x = 0.4124564 * r + 0.3575761 * g + 0.1804375 * b;</span>
<span class='curline'><a href='../S/1081.html#L318'>g</a>                 318 src/xBRZ/xbrz.cpp     double y = 0.2126729 * r + 0.7151522 * g + 0.0721750 * b;</span>
<span class='curline'><a href='../S/1081.html#L319'>g</a>                 319 src/xBRZ/xbrz.cpp     double z = 0.0193339 * r + 0.1191920 * g + 0.9503041 * b;</span>
<span class='curline'><a href='../S/1081.html#L568'>g</a>                 568 src/xBRZ/xbrz.cpp     /**/e=0, f=0, g=0, h=0,</span>
<span class='curline'><a href='../S/1081.html#L592'>g</a>                 592 src/xBRZ/xbrz.cpp     if ((ker.f == ker.g &amp;&amp;</span>
<span class='curline'><a href='../S/1081.html#L595'>g</a>                 595 src/xBRZ/xbrz.cpp          ker.g == ker.k))</span>
<span class='curline'><a href='../S/1081.html#L601'>g</a>                 601 src/xBRZ/xbrz.cpp     double jg = dist(ker.i, ker.f) + dist(ker.f, ker.c) + dist(ker.n, ker.k) + dist(ker.k, ker.h) + weight * dist(ker.j, ker.g);</span>
<span class='curline'><a href='../S/1081.html#L602'>g</a>                 602 src/xBRZ/xbrz.cpp     double fk = dist(ker.e, ker.j) + dist(ker.j, ker.o) + dist(ker.b, ker.g) + dist(ker.g, ker.l) + weight * dist(ker.f, ker.k);</span>
<span class='curline'><a href='../S/1081.html#L607'>g</a>                 607 src/xBRZ/xbrz.cpp         if (ker.f != ker.g &amp;&amp; ker.f != ker.j)</span>
<span class='curline'><a href='../S/1081.html#L610'>g</a>                 610 src/xBRZ/xbrz.cpp         if (ker.k != ker.j &amp;&amp; ker.k != ker.g)</span>
<span class='curline'><a href='../S/1081.html#L619'>g</a>                 619 src/xBRZ/xbrz.cpp         if (ker.g != ker.f &amp;&amp; ker.g != ker.k)</span>
<span class='curline'><a href='../S/1081.html#L630'>g</a>                 630 src/xBRZ/xbrz.cpp     /**/g=0,  h=0,  i=0;</span>
<span class='curline'><a href='../S/1081.html#L639'>g</a>                 639 src/xBRZ/xbrz.cpp DEF_GETTER(g) DEF_GETTER(h) DEF_GETTER(i)</span>
<span class='curline'><a href='../S/1081.html#L645'>g</a>                 645 src/xBRZ/xbrz.cpp DEF_GETTER(g, i) DEF_GETTER(h, f) DEF_GETTER(i, c)</span>
<span class='curline'><a href='../S/1081.html#L649'>g</a>                 649 src/xBRZ/xbrz.cpp /*DEF_GETTER(a, i)*/ DEF_GETTER(b, h) DEF_GETTER(c, g)</span>
<span class='curline'><a href='../S/1081.html#L651'>g</a>                 651 src/xBRZ/xbrz.cpp DEF_GETTER(g, c) DEF_GETTER(h, b) DEF_GETTER(i, a)</span>
<span class='curline'><a href='../S/1081.html#L657'>g</a>                 657 src/xBRZ/xbrz.cpp DEF_GETTER(g, a) DEF_GETTER(h, d) DEF_GETTER(i,	g)</span>
<span class='curline'><a href='../S/1081.html#L737'>g</a>                 737 src/xBRZ/xbrz.cpp             else if (getTopR(blend) != BLEND_NONE &amp;&amp; !eq(e, g)) //but support double-blending for 90 (degrees) corners</span>
<span class='curline'><a href='../S/1081.html#L743'>g</a>                 743 src/xBRZ/xbrz.cpp             else if (eq(g, h) &amp;&amp;  eq(h , i) &amp;&amp; eq(i, f) &amp;&amp; eq(f, c) &amp;&amp; !eq(e, i))</span>
<span class='curline'><a href='../S/1081.html#L751'>g</a>                 751 src/xBRZ/xbrz.cpp             const double fg = dist(f, g); //test sample: 70% of values max(fg, hc) / min(fg, hc) are between 1.1 and 3.7 with median being 1.9</span>
<span class='curline'><a href='../S/1081.html#L754'>g</a>                 754 src/xBRZ/xbrz.cpp             const bool haveShallowLine = cfg.steepDirectionThreshold * fg &lt;= hc &amp;&amp; e != g &amp;&amp; d != g;</span>
<span class='curline'><a href='../S/1081.html#L830'>g</a>                 830 src/xBRZ/xbrz.cpp             ker.g = s_0[x_p1];</span>
<span class='curline'><a href='../S/1081.html#L892'>g</a>                 892 src/xBRZ/xbrz.cpp                 ker.g = s_0[x_p1];</span>
<span class='curline'><a href='../S/1081.html#L943'>g</a>                 943 src/xBRZ/xbrz.cpp                 ker.g = s_p1[x_m1];</span>
<span class='curline'><a href='../S/1358.html#L204'>g</a>                 204 utils/wesnothd.pl 		foreach my $g (@games) {</span>
<span class='curline'><a href='../S/1358.html#L205'>g</a>                 205 utils/wesnothd.pl 			my $players = $g-&gt;{'players'};</span>
<span class='curline'><a href='../S/1358.html#L207'>g</a>                 207 utils/wesnothd.pl 				$game = $g;</span>
</pre>
</body>
</html>
