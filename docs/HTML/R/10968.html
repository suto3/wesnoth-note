<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>prev</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/4075.html#L1'>prev</a>                1 data/tools/addon_manager/jquery.js (function(){var _jQuery=window.jQuery,_$=window.$;var jQuery=window.jQuery=window.$=function(selector,context){return new jQuery.fn.init(selector,context)};var quickExpr=/^[^&lt;]*(&lt;(.|\s)+&gt;)[^&gt;]*$|^#(\w+)$/,isSimple=/^.[^:#\[\.]*$/,undefined;jQuery.fn=jQuery.prototype={init:function(selector,context){selector=selector||document;if(selector.nodeType){this[0]=selector;this.length=1;return this}if(typeof selector=="string"){var match=quickExpr.exec(selector);if(match&amp;&amp;(match[1]||!context)){if(match[1]){selector=jQuery.clean([match[1]],context)}else{var elem=document.getElementById(match[3]);if(elem){if(elem.id!=match[3]){return jQuery().find(selector)}return jQuery(elem)}selector=[]}}else{return jQuery(context).find(selector)}}else{if(jQuery.isFunction(selector)){return jQuery(document)[jQuery.fn.ready?"ready":"load"](selector)}}return this.setArray(jQuery.makeArray(selector))},jquery:"1.2.6",size:function(){return this.length},length:0,get:function(</span>
<span class='curline'><a href='../S/238.html#L744'>prev</a>              744 src/ai/default/ca.cpp 		std::multimap&lt;map_location, map_location&gt;::const_iterator prev = j; //FIXME seems not to work</span>
<span class='curline'><a href='../S/238.html#L746'>prev</a>              746 src/ai/default/ca.cpp 			--prev;</span>
<span class='curline'><a href='../S/238.html#L750'>prev</a>              750 src/ai/default/ca.cpp 				&amp;&amp; (at_begin || prev-&gt;first != current_loc)) {</span>
<span class='curline'><a href='../S/1221.html#L1639'>prev</a>             1639 src/attack_prediction.cpp combatant::combatant(const battle_context_unit_stats&amp; u, const combatant* prev)</span>
<span class='curline'><a href='../S/1221.html#L1647'>prev</a>             1647 src/attack_prediction.cpp 	if(prev) {</span>
<span class='curline'><a href='../S/1221.html#L1648'>prev</a>             1648 src/attack_prediction.cpp 		summary[0] = prev-&gt;summary[0];</span>
<span class='curline'><a href='../S/1221.html#L1649'>prev</a>             1649 src/attack_prediction.cpp 		summary[1] = prev-&gt;summary[1];</span>
<span class='curline'><a href='../S/1221.html#L1650'>prev</a>             1650 src/attack_prediction.cpp 		hp_dist = prev-&gt;hp_dist;</span>
<span class='curline'><a href='../S/1221.html#L1651'>prev</a>             1651 src/attack_prediction.cpp 		untouched = prev-&gt;untouched;</span>
<span class='curline'><a href='../S/1221.html#L1652'>prev</a>             1652 src/attack_prediction.cpp 		poisoned = prev-&gt;poisoned;</span>
<span class='curline'><a href='../S/1221.html#L1653'>prev</a>             1653 src/attack_prediction.cpp 		slowed = prev-&gt;slowed;</span>
<span class='curline'><a href='../S/1221.html#L2211'>prev</a>             2211 src/attack_prediction.cpp 	std::vector&lt;double&gt; prev = summary[0], opp_prev = opponent.summary[0];</span>
<span class='curline'><a href='../S/1221.html#L2214'>prev</a>             2214 src/attack_prediction.cpp 	summary[0] = prev;</span>
<span class='curline'><a href='../S/983.html#L30'>prev</a>               30 src/attack_prediction.hpp 	combatant(const battle_context_unit_stats &amp;u, const combatant *prev = nullptr);</span>
<span class='curline'><a href='../S/641.html#L42'>prev</a>               42 src/gui/auxiliary/old_markup.cpp 	std::string::size_type prev = 0;</span>
<span class='curline'><a href='../S/641.html#L44'>prev</a>               44 src/gui/auxiliary/old_markup.cpp 	while((pos = label_.find('=', prev)) != std::string::npos) {</span>
<span class='curline'><a href='../S/641.html#L45'>prev</a>               45 src/gui/auxiliary/old_markup.cpp 		for(std::string::size_type i = prev; i != pos; ++i) {</span>
<span class='curline'><a href='../S/641.html#L57'>prev</a>               57 src/gui/auxiliary/old_markup.cpp 		prev = pos + 1;</span>
<span class='curline'><a href='../S/1217.html#L283'>prev</a>              283 src/lua/lparser.cpp         singlevaraux(fs-&gt;prev, n, var, 0);  /* try upper levels */</span>
<span class='curline'><a href='../S/1217.html#L523'>prev</a>              523 src/lua/lparser.cpp   FuncState *fs = ls-&gt;fs-&gt;prev;</span>
<span class='curline'><a href='../S/1217.html#L531'>prev</a>              531 src/lua/lparser.cpp   fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */</span>
<span class='curline'><a href='../S/1217.html#L571'>prev</a>              571 src/lua/lparser.cpp   ls-&gt;fs = fs-&gt;prev;</span>
<span class='curline'><a href='../S/1217.html#L1109'>prev</a>             1109 src/lua/lparser.cpp   struct LHS_assign *prev;</span>
<span class='curline'><a href='../S/1217.html#L1124'>prev</a>             1124 src/lua/lparser.cpp   for (; lh; lh = lh-&gt;prev) {  /* check all previous assignments */</span>
<span class='curline'><a href='../S/1217.html#L1153'>prev</a>             1153 src/lua/lparser.cpp     nv.prev = lh;</span>
<span class='curline'><a href='../S/1217.html#L1495'>prev</a>             1495 src/lua/lparser.cpp     v.prev = NULL;</span>
<span class='curline'><a href='../S/1217.html#L1645'>prev</a>             1645 src/lua/lparser.cpp   lua_assert(!funcstate.prev &amp;&amp; funcstate.nups == 1 &amp;&amp; !lexstate.fs);</span>
<span class='curline'><a href='../S/1174.html#L113'>prev</a>              113 src/lua/lparser.h   struct FuncState *prev;  /* enclosing function */</span>
<span class='curline'><a href='../S/848.html#L65'>prev</a>               65 src/pathfind/astarsearch.cpp 	map_location curr, prev;</span>
<span class='curline'><a href='../S/848.html#L78'>prev</a>               78 src/pathfind/astarsearch.cpp 		, prev()</span>
<span class='curline'><a href='../S/848.html#L83'>prev</a>               83 src/pathfind/astarsearch.cpp 		g(s), h(heuristic(c, dst)), t(g + h), curr(c), prev(p), in(search_counter + i)</span>
<span class='curline'><a href='../S/848.html#L229'>prev</a>              229 src/pathfind/astarsearch.cpp 		for (node curr = nodes[index(dst)]; curr.prev != map_location::null_location(); curr = nodes[index(curr.prev)]) {</span>
<span class='curline'><a href='../S/849.html#L162'>prev</a>              162 src/pathfind/pathfind.cpp 		map_location prev;</span>
<span class='curline'><a href='../S/849.html#L172'>prev</a>              172 src/pathfind/pathfind.cpp 			, prev(prev_loc)</span>
<span class='curline'><a href='../S/849.html#L178'>prev</a>              178 src/pathfind/pathfind.cpp 			, prev()</span>
<span class='curline'><a href='../S/849.html#L366'>prev</a>              366 src/pathfind/pathfind.cpp 			next.prev = cur_hex;</span>
<span class='curline'><a href='../S/849.html#L453'>prev</a>              453 src/pathfind/pathfind.cpp 					{ map_location(x,y), n.prev, n.moves_left + n.turns_left*max_moves };</span>
<span class='curline'><a href='../S/849.html#L486'>prev</a>              486 src/pathfind/pathfind.cpp 	if (!j-&gt;prev.valid()) {</span>
<span class='curline'><a href='../S/849.html#L491'>prev</a>              491 src/pathfind/pathfind.cpp 			i = find(i-&gt;prev);</span>
<span class='curline'><a href='../S/849.html#L494'>prev</a>              494 src/pathfind/pathfind.cpp 		} while (i-&gt;prev.valid());</span>
<span class='curline'><a href='../S/850.html#L87'>prev</a>               87 src/pathfind/pathfind.hpp 		map_location curr, prev;</span>
<span class='curline'><a href='../S/91.html#L99'>prev</a>               99 src/persist_context.cpp 					name_space prev = working.prev();</span>
<span class='curline'><a href='../S/91.html#L100'>prev</a>              100 src/persist_context.cpp 					active = get_node(cfg_, prev);</span>
<span class='curline'><a href='../S/91.html#L106'>prev</a>              106 src/persist_context.cpp 					working = prev;</span>
<span class='curline'><a href='../S/91.html#L145'>prev</a>              145 src/persist_context.cpp 		name_space prev = namespace_.prev();</span>
<span class='curline'><a href='../S/91.html#L146'>prev</a>              146 src/persist_context.cpp 		active = get_node(cfg_, prev);</span>
<span class='curline'><a href='../S/91.html#L155'>prev</a>              155 src/persist_context.cpp 		namespace_ = prev;</span>
<span class='curline'><a href='../S/184.html#L82'>prev</a>               82 src/scripting/lua_gui2.cpp 		scoped_dialog* prev;</span>
<span class='curline'><a href='../S/184.html#L97'>prev</a>               97 src/scripting/lua_gui2.cpp 		: L(l), prev(current), window(w), callbacks()</span>
<span class='curline'><a href='../S/184.html#L111'>prev</a>              111 src/scripting/lua_gui2.cpp 		current = prev;</span>
<span class='curline'><a href='../S/860.html#L68'>prev</a>               68 src/utils/smart_list.hpp 		node_t * prev;</span>
<span class='curline'><a href='../S/860.html#L167'>prev</a>              167 src/utils/smart_list.hpp 		void inc(bool reverse)             { ptr_ = reverse ? ptr_-&gt;prev : ptr_-&gt;next; }</span>
<span class='curline'><a href='../S/860.html#L247'>prev</a>              247 src/utils/smart_list.hpp 	reverse_iterator rbegin()              { return reverse_iterator(root_.prev); }</span>
<span class='curline'><a href='../S/860.html#L249'>prev</a>              249 src/utils/smart_list.hpp 	const_reverse_iterator rbegin() const  { return const_reverse_iterator(root_.prev); }</span>
<span class='curline'><a href='../S/860.html#L463'>prev</a>              463 src/utils/smart_list.hpp 		splice(pos.ptr_, *L.root_.next, *L.root_.prev);</span>
<span class='curline'><a href='../S/860.html#L483'>prev</a>              483 src/utils/smart_list.hpp 	splice(pos.ptr_, *(f.ptr_), *(l.ptr_-&gt;prev));</span>
<span class='curline'><a href='../S/860.html#L520'>prev</a>              520 src/utils/smart_list.hpp 	iterator prev = cur;</span>
<span class='curline'><a href='../S/860.html#L527'>prev</a>              527 src/utils/smart_list.hpp 		if ( p(*prev, *cur) )</span>
<span class='curline'><a href='../S/860.html#L532'>prev</a>              532 src/utils/smart_list.hpp 			prev = cur++;</span>
<span class='curline'><a href='../S/860.html#L562'>prev</a>              562 src/utils/smart_list.hpp 			splice(dest, *source, *(end_merge-&gt;prev));</span>
<span class='curline'><a href='../S/860.html#L573'>prev</a>              573 src/utils/smart_list.hpp 		splice(&amp;root_, *source, *(L.root_.prev));</span>
<span class='curline'><a href='../S/860.html#L667'>prev</a>              667 src/utils/smart_list.hpp 	begin_link.prev = pos-&gt;prev;</span>
<span class='curline'><a href='../S/860.html#L671'>prev</a>              671 src/utils/smart_list.hpp 	begin_link.prev-&gt;next = &amp;begin_link;</span>
<span class='curline'><a href='../S/860.html#L672'>prev</a>              672 src/utils/smart_list.hpp 	end_link.next-&gt;prev   = &amp;end_link;</span>
<span class='curline'><a href='../S/860.html#L686'>prev</a>              686 src/utils/smart_list.hpp 	begin_unlink.prev-&gt;next = end_unlink.next;</span>
<span class='curline'><a href='../S/860.html#L687'>prev</a>              687 src/utils/smart_list.hpp 	end_unlink.next-&gt;prev = begin_unlink.prev;</span>
<span class='curline'><a href='../S/860.html#L691'>prev</a>              691 src/utils/smart_list.hpp 	begin_unlink.prev = nullptr;</span>
<span class='curline'><a href='../S/860.html#L762'>prev</a>              762 src/utils/smart_list.hpp 		assert(next == nullptr  &amp;&amp;  prev == nullptr);</span>
<span class='curline'><a href='../S/672.html#L1144'>prev</a>             1144 src/widgets/menu.cpp 		const SDL_Rect&amp; prev = get_item_rect_internal(item-1);</span>
<span class='curline'><a href='../S/672.html#L1145'>prev</a>             1145 src/widgets/menu.cpp 		y = prev.y + prev.h;</span>
</pre>
</body>
</html>
