<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>tk</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/4068.html#L139'>tk</a>                139 data/tools/GUI.pyw     windowingsystem = widget.tk.call('tk', 'windowingsystem')</span>
<span class='curline'><a href='../S/4068.html#L155'>tk</a>                155 data/tools/GUI.pyw     windowingsystem = widget.tk.call('tk', 'windowingsystem')</span>
<span class='curline'><a href='../S/4068.html#L293'>tk</a>                293 data/tools/GUI.pyw         control_key = "Command" if self.tk.call('tk', 'windowingsystem') == "aqua" else "Ctrl"</span>
<span class='curline'><a href='../S/4068.html#L1647'>tk</a>               1647 data/tools/GUI.pyw     root.tk.call("wm", "iconphoto", root, "-default", ICONS["window_icon"])</span>
<span class='curline'><a href='../S/4068.html#L1650'>tk</a>               1650 data/tools/GUI.pyw     if root.tk.call('tk', 'windowingsystem') == "x11" and "clam" in style.theme_names():</span>
<span class='curline'><a href='../S/772.html#L34'>tk</a>                 34 src/formula/formula.cpp static std::string tokens_to_string(const tk::token* i1, const tk::token* i2)</span>
<span class='curline'><a href='../S/772.html#L63'>tk</a>                 63 src/formula/formula.cpp expression_ptr parse_expression(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols);</span>
<span class='curline'><a href='../S/772.html#L74'>tk</a>                 74 src/formula/formula.cpp 	std::vector&lt;tk::token&gt; tokens;</span>
<span class='curline'><a href='../S/772.html#L96'>tk</a>                 96 src/formula/formula.cpp 			tokens.push_back(tk::get_token(i1,i2));</span>
<span class='curline'><a href='../S/772.html#L98'>tk</a>                 98 src/formula/formula.cpp 			tk::TOKEN_TYPE current_type = tokens.back().type;</span>
<span class='curline'><a href='../S/772.html#L100'>tk</a>                100 src/formula/formula.cpp 			if(current_type == tk::TOKEN_WHITESPACE)  {</span>
<span class='curline'><a href='../S/772.html#L102'>tk</a>                102 src/formula/formula.cpp 			} else if(current_type == tk::TOKEN_COMMENT) {</span>
<span class='curline'><a href='../S/772.html#L115'>tk</a>                115 src/formula/formula.cpp 			} else if(current_type == tk::TOKEN_EOL) {</span>
<span class='curline'><a href='../S/772.html#L118'>tk</a>                118 src/formula/formula.cpp 			} else if((current_type == tk::TOKEN_KEYWORD) &amp;&amp; (std::string(tokens.back().begin, tokens.back().end) == "fai")) {</span>
<span class='curline'><a href='../S/772.html#L121'>tk</a>                121 src/formula/formula.cpp 			} else if((current_type == tk::TOKEN_KEYWORD) &amp;&amp; (std::string(tokens.back().begin, tokens.back().end) == "wfl")) {</span>
<span class='curline'><a href='../S/772.html#L124'>tk</a>                124 src/formula/formula.cpp 			} else if((current_type == tk::TOKEN_KEYWORD) &amp;&amp; (std::string(tokens.back().begin, tokens.back().end) == "faiend")) {</span>
<span class='curline'><a href='../S/772.html#L133'>tk</a>                133 src/formula/formula.cpp 			} else if((current_type == tk::TOKEN_KEYWORD) &amp;&amp; (std::string(tokens.back().begin, tokens.back().end) == "wflend")) {</span>
<span class='curline'><a href='../S/772.html#L143'>tk</a>                143 src/formula/formula.cpp 				if(current_type == tk::TOKEN_STRING_LITERAL) {</span>
<span class='curline'><a href='../S/772.html#L177'>tk</a>                177 src/formula/formula.cpp 		} catch(tk::token_error&amp; e) {</span>
<span class='curline'><a href='../S/772.html#L182'>tk</a>                182 src/formula/formula.cpp 				tk::token* tok_it = &amp;tokens[0] + tokens.size()-1;</span>
<span class='curline'><a href='../S/772.html#L209'>tk</a>                209 src/formula/formula.cpp formula::formula(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L1049'>tk</a>               1049 src/formula/formula.cpp static int operator_precedence(const tk::token&amp; t)</span>
<span class='curline'><a href='../S/772.html#L1081'>tk</a>               1081 src/formula/formula.cpp static void parse_function_args(const tk::token* &amp;i1, const tk::token* i2, std::vector&lt;std::string&gt;* res)</span>
<span class='curline'><a href='../S/772.html#L1083'>tk</a>               1083 src/formula/formula.cpp  	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1085'>tk</a>               1085 src/formula/formula.cpp 	if(i1-&gt;type == tk::TOKEN_LPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1091'>tk</a>               1091 src/formula/formula.cpp 	while((i1-&gt; type != tk::TOKEN_RPARENS) &amp;&amp; (i1 != i2)) {</span>
<span class='curline'><a href='../S/772.html#L1092'>tk</a>               1092 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1099'>tk</a>               1099 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA) {</span>
<span class='curline'><a href='../S/772.html#L1108'>tk</a>               1108 src/formula/formula.cpp 	if(i1-&gt;type != tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1115'>tk</a>               1115 src/formula/formula.cpp static void parse_args(const tk::token* i1, const tk::token* i2,</span>
<span class='curline'><a href='../S/772.html#L1120'>tk</a>               1120 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1122'>tk</a>               1122 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS || i1-&gt;type == tk::TOKEN_LSQUARE ) {</span>
<span class='curline'><a href='../S/772.html#L1124'>tk</a>               1124 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS || i1-&gt;type == tk::TOKEN_RSQUARE ) {</span>
<span class='curline'><a href='../S/772.html#L1126'>tk</a>               1126 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA &amp;&amp; !parens) {</span>
<span class='curline'><a href='../S/772.html#L1139'>tk</a>               1139 src/formula/formula.cpp static void parse_set_args(const tk::token* i1, const tk::token* i2,</span>
<span class='curline'><a href='../S/772.html#L1145'>tk</a>               1145 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1146'>tk</a>               1146 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1148'>tk</a>               1148 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS || i1-&gt;type == tk::TOKEN_LSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1150'>tk</a>               1150 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS || i1-&gt;type == tk::TOKEN_RSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1152'>tk</a>               1152 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_POINTER &amp;&amp; !parens ) {</span>
<span class='curline'><a href='../S/772.html#L1160'>tk</a>               1160 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_COMMA &amp;&amp; !parens ) {</span>
<span class='curline'><a href='../S/772.html#L1178'>tk</a>               1178 src/formula/formula.cpp static void parse_where_clauses(const tk::token* i1, const tk::token* i2, expr_table_ptr res, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L1181'>tk</a>               1181 src/formula/formula.cpp 	const tk::token* original_i1_cached = i1;</span>
<span class='curline'><a href='../S/772.html#L1182'>tk</a>               1182 src/formula/formula.cpp 	const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1183'>tk</a>               1183 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1187'>tk</a>               1187 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1189'>tk</a>               1189 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1192'>tk</a>               1192 src/formula/formula.cpp 			if(i1-&gt;type == tk::TOKEN_COMMA) {</span>
<span class='curline'><a href='../S/772.html#L1201'>tk</a>               1201 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_OPERATOR) {</span>
<span class='curline'><a href='../S/772.html#L1205'>tk</a>               1205 src/formula/formula.cpp 					if(beg-&gt;type != tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1239'>tk</a>               1239 src/formula/formula.cpp expression_ptr parse_expression(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols)</span>
<span class='curline'><a href='../S/772.html#L1251'>tk</a>               1251 src/formula/formula.cpp 	const tk::token* begin = i1, *end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1253'>tk</a>               1253 src/formula/formula.cpp 	if(i1-&gt;type == tk::TOKEN_KEYWORD &amp;&amp; (i1 + 1)-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1261'>tk</a>               1261 src/formula/formula.cpp 			const tk::token* beg = i1;</span>
<span class='curline'><a href='../S/772.html#L1262'>tk</a>               1262 src/formula/formula.cpp 			while((i1 != i2) &amp;&amp; (i1-&gt;type != tk::TOKEN_SEMICOLON)) {</span>
<span class='curline'><a href='../S/772.html#L1289'>tk</a>               1289 src/formula/formula.cpp 	const tk::token* op = nullptr;</span>
<span class='curline'><a href='../S/772.html#L1292'>tk</a>               1292 src/formula/formula.cpp 	for(const tk::token* i = i1; i != i2; ++i) {</span>
<span class='curline'><a href='../S/772.html#L1293'>tk</a>               1293 src/formula/formula.cpp 		if(i-&gt;type == tk::TOKEN_LPARENS || i-&gt;type == tk::TOKEN_LSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1295'>tk</a>               1295 src/formula/formula.cpp 		} else if(i-&gt;type == tk::TOKEN_RPARENS || i-&gt;type == tk::TOKEN_RSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1297'>tk</a>               1297 src/formula/formula.cpp 		} else if(parens == 0 &amp;&amp; i-&gt;type == tk::TOKEN_OPERATOR) {</span>
<span class='curline'><a href='../S/772.html#L1311'>tk</a>               1311 src/formula/formula.cpp 		if(i1-&gt;type == tk::TOKEN_LPARENS &amp;&amp; (i2-1)-&gt;type == tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1313'>tk</a>               1313 src/formula/formula.cpp 		} else if((i2-1)-&gt;type == tk::TOKEN_RSQUARE) { //check if there is [ ] : either a list/map definition, or a operator</span>
<span class='curline'><a href='../S/772.html#L1315'>tk</a>               1315 src/formula/formula.cpp 			if(i2 - i1 == 3 &amp;&amp; i1-&gt;type == tk::TOKEN_LSQUARE &amp;&amp; (i1+1)-&gt;type == tk::TOKEN_POINTER) {</span>
<span class='curline'><a href='../S/772.html#L1319'>tk</a>               1319 src/formula/formula.cpp 			const tk::token* tok = i2-2;</span>
<span class='curline'><a href='../S/772.html#L1322'>tk</a>               1322 src/formula/formula.cpp 			while ((tok-&gt;type != tk::TOKEN_LSQUARE || square_parens) &amp;&amp; tok != i1) {</span>
<span class='curline'><a href='../S/772.html#L1323'>tk</a>               1323 src/formula/formula.cpp 				if(tok-&gt;type == tk::TOKEN_RSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1325'>tk</a>               1325 src/formula/formula.cpp 				} else if(tok-&gt;type == tk::TOKEN_LSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1327'>tk</a>               1327 src/formula/formula.cpp 				} else if((tok-&gt;type == tk::TOKEN_POINTER) &amp;&amp; !square_parens ) {</span>
<span class='curline'><a href='../S/772.html#L1333'>tk</a>               1333 src/formula/formula.cpp 			if(tok-&gt;type == tk::TOKEN_LSQUARE) {</span>
<span class='curline'><a href='../S/772.html#L1360'>tk</a>               1360 src/formula/formula.cpp 			if(i1-&gt;type == tk::TOKEN_KEYWORD) {</span>
<span class='curline'><a href='../S/772.html#L1364'>tk</a>               1364 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_IDENTIFIER) {</span>
<span class='curline'><a href='../S/772.html#L1366'>tk</a>               1366 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_INTEGER) {</span>
<span class='curline'><a href='../S/772.html#L1369'>tk</a>               1369 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_DECIMAL) {</span>
<span class='curline'><a href='../S/772.html#L1370'>tk</a>               1370 src/formula/formula.cpp 				tk::iterator dot = i1-&gt;begin;</span>
<span class='curline'><a href='../S/772.html#L1377'>tk</a>               1377 src/formula/formula.cpp 				tk::iterator literal_end = i1-&gt;end;</span>
<span class='curline'><a href='../S/772.html#L1395'>tk</a>               1395 src/formula/formula.cpp 			} else if(i1-&gt;type == tk::TOKEN_STRING_LITERAL) {</span>
<span class='curline'><a href='../S/772.html#L1398'>tk</a>               1398 src/formula/formula.cpp 		} else if(i1-&gt;type == tk::TOKEN_IDENTIFIER &amp;&amp;</span>
<span class='curline'><a href='../S/772.html#L1399'>tk</a>               1399 src/formula/formula.cpp 		          (i1+1)-&gt;type == tk::TOKEN_LPARENS &amp;&amp;</span>
<span class='curline'><a href='../S/772.html#L1400'>tk</a>               1400 src/formula/formula.cpp 				  (i2-1)-&gt;type == tk::TOKEN_RPARENS)</span>
<span class='curline'><a href='../S/772.html#L1402'>tk</a>               1402 src/formula/formula.cpp 			const tk::token* function_call_begin = i1, *function_call_end = i2;	// These are used for error reporting</span>
<span class='curline'><a href='../S/772.html#L1404'>tk</a>               1404 src/formula/formula.cpp 			for(const tk::token* i = i1; i != i2; ++i) {</span>
<span class='curline'><a href='../S/772.html#L1405'>tk</a>               1405 src/formula/formula.cpp 				if(i-&gt;type == tk::TOKEN_LPARENS) {</span>
<span class='curline'><a href='../S/772.html#L1407'>tk</a>               1407 src/formula/formula.cpp 				} else if(i-&gt;type == tk::TOKEN_RPARENS) {</span>
<span class='curline'><a href='../S/784.html#L37'>tk</a>                 37 src/formula/formula.hpp 	formula(const tk::token* i1, const tk::token* i2, function_symbol_table* symbols = nullptr);</span>
</pre>
</body>
</html>
