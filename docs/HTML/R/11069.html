<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>ptr</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/898.html#L358'>ptr</a>               358 src/actions/undo.cpp 	if (undo_action* undoable_action = dynamic_cast&lt;undo_action*&gt;(action.ptr()))</span>
<span class='curline'><a href='../S/268.html#L85'>ptr</a>                85 src/ai/composite/property_handler.hpp 			typename ptr_vector::iterator i = std::find_if(values_.begin(),values_.end(),path_element_matches&lt;ptr&gt;(child));</span>
<span class='curline'><a href='../S/268.html#L113'>ptr</a>               113 src/ai/composite/property_handler.hpp 			typename ptr_vector::iterator i = std::find_if(values_.begin(),values_.end(),path_element_matches&lt;ptr&gt;(child));</span>
<span class='curline'><a href='../S/268.html#L125'>ptr</a>               125 src/ai/composite/property_handler.hpp 		typename ptr_vector::iterator i = std::find_if(values_.begin(),values_.end(),path_element_matches&lt;ptr&gt;(child));</span>
<span class='curline'><a href='../S/268.html#L137'>ptr</a>               137 src/ai/composite/property_handler.hpp 		for (ptr v : values_) {</span>
<span class='curline'><a href='../S/268.html#L157'>ptr</a>               157 src/ai/composite/property_handler.hpp 		for (ptr b : values ) {</span>
<span class='curline'><a href='../S/268.html#L174'>ptr</a>               174 src/ai/composite/property_handler.hpp 	typedef typename vector_property_handler&lt;T&gt;::ptr ptr;</span>
<span class='curline'><a href='../S/268.html#L178'>ptr</a>               178 src/ai/composite/property_handler.hpp 	facets_property_handler(const std::string &amp;property, ptr_vector &amp;values, ptr&amp; def, std::function&lt;void(ptr_vector&amp;, const config&amp;)&gt; &amp;construction_factory)</span>
<span class='curline'><a href='../S/268.html#L213'>ptr</a>               213 src/ai/composite/property_handler.hpp 	ptr&amp; default_;</span>
<span class='curline'><a href='../S/268.html#L222'>ptr</a>               222 src/ai/composite/property_handler.hpp 	typedef std::map&lt; std::string, ptr &gt; aspect_map;</span>
<span class='curline'><a href='../S/828.html#L63'>ptr</a>                63 src/events.cpp void context::add_handler(sdl_handler* ptr)</span>
<span class='curline'><a href='../S/828.html#L69'>ptr</a>                69 src/events.cpp 	staging_handlers.push_back(ptr);</span>
<span class='curline'><a href='../S/828.html#L72'>ptr</a>                72 src/events.cpp bool context::remove_handler(sdl_handler* ptr)</span>
<span class='curline'><a href='../S/828.html#L79'>ptr</a>                79 src/events.cpp 	if(!handlers.empty() &amp;&amp; handlers.back() == ptr) {</span>
<span class='curline'><a href='../S/828.html#L80'>ptr</a>                80 src/events.cpp 		if(focused_handler != handlers.end() &amp;&amp; *focused_handler == ptr) {</span>
<span class='curline'><a href='../S/828.html#L86'>ptr</a>                86 src/events.cpp 		const handler_list::iterator i = std::find(handlers.begin(), handlers.end(), ptr);</span>
<span class='curline'><a href='../S/828.html#L92'>ptr</a>                92 src/events.cpp 			auto j = std::find(staging_handlers.begin(), staging_handlers.end(), ptr);</span>
<span class='curline'><a href='../S/828.html#L152'>ptr</a>               152 src/events.cpp void context::set_focus(const sdl_handler* ptr)</span>
<span class='curline'><a href='../S/828.html#L154'>ptr</a>               154 src/events.cpp 	const handler_list::iterator i = std::find(handlers.begin(), handlers.end(), ptr);</span>
<span class='curline'><a href='../S/828.html#L329'>ptr</a>               329 src/events.cpp void focus_handler(const sdl_handler* ptr)</span>
<span class='curline'><a href='../S/828.html#L332'>ptr</a>               332 src/events.cpp 		event_contexts.back().set_focus(ptr);</span>
<span class='curline'><a href='../S/1022.html#L53'>ptr</a>                53 src/events.hpp 	void add_handler(sdl_handler* ptr);</span>
<span class='curline'><a href='../S/1022.html#L54'>ptr</a>                54 src/events.hpp 	bool remove_handler(sdl_handler* ptr);</span>
<span class='curline'><a href='../S/1022.html#L56'>ptr</a>                56 src/events.hpp 	void set_focus(const sdl_handler* ptr);</span>
<span class='curline'><a href='../S/1022.html#L111'>ptr</a>               111 src/events.hpp void focus_handler(const sdl_handler* ptr);</span>
<span class='curline'><a href='../S/1022.html#L113'>ptr</a>               113 src/events.hpp bool has_focus(const sdl_handler* ptr, const SDL_Event* event);</span>
<span class='curline'><a href='../S/935.html#L29'>ptr</a>                29 src/fake_unit_ptr.cpp fake_unit_ptr::fake_unit_ptr(const fake_unit_ptr &amp; ptr) : unit_(ptr.unit_), my_manager_(nullptr) {}</span>
<span class='curline'><a href='../S/935.html#L84'>ptr</a>                84 src/fake_unit_ptr.cpp void fake_unit_ptr::reset(const internal_ptr &amp; ptr)</span>
<span class='curline'><a href='../S/935.html#L86'>ptr</a>                86 src/fake_unit_ptr.cpp 	if (unit_.get() != ptr.get()) {</span>
<span class='curline'><a href='../S/935.html#L90'>ptr</a>                90 src/fake_unit_ptr.cpp 		unit_ = ptr;</span>
<span class='curline'><a href='../S/735.html#L39'>ptr</a>                39 src/fake_unit_ptr.hpp 	fake_unit_ptr(const fake_unit_ptr &amp; ptr); //!&lt; Copy construct a fake unit pointer. Does not reallocate the underlying unit.</span>
<span class='curline'><a href='../S/735.html#L46'>ptr</a>                46 src/fake_unit_ptr.hpp 	void reset(const internal_ptr &amp; ptr); //!&lt; Reset the internal unit pointer and point to a new unit. The old unit is deregistered, and the new unit is registered with the old manager, if there was one.</span>
<span class='curline'><a href='../S/1045.html#L27'>ptr</a>                27 src/filesystem_sdl.cpp static size_t SDLCALL ifs_read(struct SDL_RWops *context, void *ptr, size_t size, size_t maxnum);</span>
<span class='curline'><a href='../S/1045.html#L28'>ptr</a>                28 src/filesystem_sdl.cpp static size_t SDLCALL ifs_write(struct SDL_RWops *context, const void *ptr, size_t size, size_t num);</span>
<span class='curline'><a href='../S/1045.html#L103'>ptr</a>               103 src/filesystem_sdl.cpp static size_t SDLCALL ifs_read(struct SDL_RWops *context, void *ptr, size_t size, size_t maxnum) {</span>
<span class='curline'><a href='../S/1045.html#L107'>ptr</a>               107 src/filesystem_sdl.cpp 	ifs-&gt;read(static_cast&lt;char*&gt;(ptr), maxnum * size);</span>
<span class='curline'><a href='../S/781.html#L59'>ptr</a>                59 src/formula/variant_value.hpp static std::shared_ptr&lt;T&gt; value_cast(value_base_ptr ptr)</span>
<span class='curline'><a href='../S/781.html#L61'>ptr</a>                61 src/formula/variant_value.hpp 	std::shared_ptr&lt;T&gt; res = std::dynamic_pointer_cast&lt;T&gt;(ptr);</span>
<span class='curline'><a href='../S/781.html#L71'>ptr</a>                71 src/formula/variant_value.hpp static T&amp; value_ref_cast(variant_value_base&amp; ptr)</span>
<span class='curline'><a href='../S/781.html#L74'>ptr</a>                74 src/formula/variant_value.hpp 		return dynamic_cast&lt;T&amp;&gt;(ptr);</span>
<span class='curline'><a href='../S/1071.html#L74'>ptr</a>                74 src/game_events/manager.hpp 		handler_vec::size_type ptr_index(const handler_ptr&amp; ptr) const</span>
<span class='curline'><a href='../S/1071.html#L76'>ptr</a>                76 src/game_events/manager.hpp 			return !bool(ptr) ? end_ : std::min(ptr-&gt;index(), end_);</span>
<span class='curline'><a href='../S/1068.html#L332'>ptr</a>               332 src/game_events/menu_item.cpp 		resources::game_events-&gt;execute_on_events(event_name_, [&amp;](game_events::manager&amp; man, handler_ptr&amp; ptr) {</span>
<span class='curline'><a href='../S/1068.html#L333'>ptr</a>               333 src/game_events/menu_item.cpp 			if(ptr-&gt;is_menu_item()) {</span>
<span class='curline'><a href='../S/1062.html#L580'>ptr</a>               580 src/game_events/pump.cpp 			impl_-&gt;my_manager-&gt;execute_on_events(event_name, [&amp;](game_events::manager&amp;, handler_ptr&amp; ptr) {</span>
<span class='curline'><a href='../S/1062.html#L581'>ptr</a>               581 src/game_events/pump.cpp 				DBG_EH &lt;&lt; "processing event " &lt;&lt; event_name &lt;&lt; " with id=" &lt;&lt; ptr-&gt;get_config()["id"] &lt;&lt; "\n";</span>
<span class='curline'><a href='../S/1062.html#L584'>ptr</a>               584 src/game_events/pump.cpp 				process_event(ptr, ev);</span>
<span class='curline'><a href='../S/522.html#L86'>ptr</a>                86 src/gui/core/widget_definition.hpp const T&amp; cast(resolution_definition_const_ptr ptr)</span>
<span class='curline'><a href='../S/522.html#L88'>ptr</a>                88 src/gui/core/widget_definition.hpp 	std::shared_ptr&lt;const T&gt; conf = std::make_shared&lt;const T&gt;(ptr);</span>
<span class='curline'><a href='../S/456.html#L54'>ptr</a>                54 src/gui/dialogs/message.cpp 		button_status.ptr = find_widget&lt;button&gt;(&amp;window, id, false, true);</span>
<span class='curline'><a href='../S/456.html#L55'>ptr</a>                55 src/gui/dialogs/message.cpp 		button_status.ptr-&gt;set_visible(button_status.visible);</span>
<span class='curline'><a href='../S/456.html#L58'>ptr</a>                58 src/gui/dialogs/message.cpp 			button_status.ptr-&gt;set_label(button_status.caption);</span>
<span class='curline'><a href='../S/456.html#L62'>ptr</a>                62 src/gui/dialogs/message.cpp 			button_status.ptr-&gt;set_retval(button_status.retval);</span>
<span class='curline'><a href='../S/456.html#L110'>ptr</a>               110 src/gui/dialogs/message.cpp 		button_status.ptr = nullptr;</span>
<span class='curline'><a href='../S/456.html#L118'>ptr</a>               118 src/gui/dialogs/message.cpp 	if(buttons_[button].ptr) {</span>
<span class='curline'><a href='../S/456.html#L119'>ptr</a>               119 src/gui/dialogs/message.cpp 		buttons_[button].ptr-&gt;set_label(caption);</span>
<span class='curline'><a href='../S/456.html#L127'>ptr</a>               127 src/gui/dialogs/message.cpp 	if(buttons_[button].ptr) {</span>
<span class='curline'><a href='../S/456.html#L128'>ptr</a>               128 src/gui/dialogs/message.cpp 		buttons_[button].ptr-&gt;set_visible(visible);</span>
<span class='curline'><a href='../S/456.html#L135'>ptr</a>               135 src/gui/dialogs/message.cpp 	if(buttons_[button].ptr) {</span>
<span class='curline'><a href='../S/456.html#L136'>ptr</a>               136 src/gui/dialogs/message.cpp 		buttons_[button].ptr-&gt;set_retval(retval);</span>
<span class='curline'><a href='../S/456.html#L141'>ptr</a>               141 src/gui/dialogs/message.cpp 	: ptr(nullptr)</span>
<span class='curline'><a href='../S/499.html#L149'>ptr</a>               149 src/gui/dialogs/message.hpp 		button* ptr;</span>
<span class='curline'><a href='../S/546.html#L595'>ptr</a>               595 src/gui/widgets/settings.cpp 	return get_best_resolution(resolutions, [&amp;](const resolution_definition_ptr&amp; ptr){return point { static_cast&lt;int&gt;(ptr-&gt;window_width), static_cast&lt;int&gt;(ptr-&gt;window_height)}; } );</span>
<span class='curline'><a href='../S/1184.html#L1000'>ptr</a>              1000 src/lua/lauxlib.cpp static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {</span>
<span class='curline'><a href='../S/1184.html#L1003'>ptr</a>              1003 src/lua/lauxlib.cpp     free(ptr);</span>
<span class='curline'><a href='../S/1184.html#L1007'>ptr</a>              1007 src/lua/lauxlib.cpp     return realloc(ptr, nsize);</span>
<span class='curline'><a href='../S/1215.html#L124'>ptr</a>               124 src/lua/lua.h  typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);</span>
<span class='curline'><a href='../S/1047.html#L31'>ptr</a>                31 src/recall_list_manager.cpp 		[&amp;unit_id](const unit_ptr &amp; ptr) { return ptr-&gt;id() == unit_id; });</span>
<span class='curline'><a href='../S/1047.html#L45'>ptr</a>                45 src/recall_list_manager.cpp 		[&amp;unit_id](const unit_ptr &amp; ptr) { return ptr-&gt;id() == unit_id; });</span>
<span class='curline'><a href='../S/1047.html#L59'>ptr</a>                59 src/recall_list_manager.cpp 		[&amp;unit_id](const unit_ptr &amp; ptr) { return ptr-&gt;id() == unit_id; }),</span>
<span class='curline'><a href='../S/1047.html#L63'>ptr</a>                63 src/recall_list_manager.cpp void recall_list_manager::add (const unit_ptr &amp; ptr)</span>
<span class='curline'><a href='../S/1047.html#L65'>ptr</a>                65 src/recall_list_manager.cpp 	recall_list_.push_back(ptr);</span>
<span class='curline'><a href='../S/1047.html#L71'>ptr</a>                71 src/recall_list_manager.cpp 		[&amp;unit_id](const unit_ptr &amp; ptr) { return ptr-&gt;id() == unit_id; });</span>
<span class='curline'><a href='../S/1047.html#L79'>ptr</a>                79 src/recall_list_manager.cpp 		[&amp;unit_id](const unit_ptr &amp; ptr) { return ptr-&gt;id() == unit_id; });</span>
<span class='curline'><a href='../S/1047.html#L92'>ptr</a>                92 src/recall_list_manager.cpp 		[uid](const unit_ptr &amp; ptr) { return ptr-&gt;underlying_id() == uid; });</span>
<span class='curline'><a href='../S/1047.html#L103'>ptr</a>               103 src/recall_list_manager.cpp 		[uid](const unit_ptr &amp; ptr) { return ptr-&gt;underlying_id() == uid; });</span>
<span class='curline'><a href='../S/1047.html#L114'>ptr</a>               114 src/recall_list_manager.cpp 		[uid](const unit_ptr &amp; ptr) { return ptr-&gt;underlying_id() == uid; }),</span>
<span class='curline'><a href='../S/1047.html#L121'>ptr</a>               121 src/recall_list_manager.cpp 		[uid](const unit_ptr &amp; ptr) { return ptr-&gt;underlying_id() == uid; });</span>
<span class='curline'><a href='../S/1046.html#L59'>ptr</a>                59 src/recall_list_manager.hpp 	void add(const unit_ptr &amp; ptr); //!&lt; Add a unit to the list.</span>
<span class='curline'><a href='../S/185.html#L1740'>ptr</a>              1740 src/scripting/game_lua_kernel.cpp static bool intf_find_cost_map_helper(const unit * ptr) {</span>
<span class='curline'><a href='../S/185.html#L1741'>ptr</a>              1741 src/scripting/game_lua_kernel.cpp 	return ptr-&gt;get_location().valid();</span>
<span class='curline'><a href='../S/196.html#L717'>ptr</a>               717 src/scripting/lua_common.cpp 			if (vconfig * ptr = static_cast&lt;vconfig *&gt; (luaL_testudata(L, index, vconfigKey))) {</span>
<span class='curline'><a href='../S/196.html#L718'>ptr</a>               718 src/scripting/lua_common.cpp 				cfg = ptr-&gt;get_parsed_config();</span>
<span class='curline'><a href='../S/196.html#L806'>ptr</a>               806 src/scripting/lua_common.cpp 			if (vconfig * ptr = static_cast&lt;vconfig *&gt; (luaL_testudata(L, index, vconfigKey))) {</span>
<span class='curline'><a href='../S/196.html#L807'>ptr</a>               807 src/scripting/lua_common.cpp 				vcfg = *ptr;</span>
<span class='curline'><a href='../S/190.html#L46'>ptr</a>                46 src/scripting/lua_unit.cpp 	if (ptr) return ptr.get();</span>
<span class='curline'><a href='../S/190.html#L57'>ptr</a>                57 src/scripting/lua_unit.cpp 	if (ptr) return ptr;</span>
<span class='curline'><a href='../S/190.html#L72'>ptr</a>                72 src/scripting/lua_unit.cpp 	if (ptr) {</span>
<span class='curline'><a href='../S/190.html#L73'>ptr</a>                73 src/scripting/lua_unit.cpp 		std::pair&lt;unit_map::unit_iterator, bool&gt; res = resources::gameboard-&gt;units().replace(loc, ptr);</span>
<span class='curline'><a href='../S/190.html#L75'>ptr</a>                75 src/scripting/lua_unit.cpp 			ptr.reset();</span>
<span class='curline'><a href='../S/190.html#L78'>ptr</a>                78 src/scripting/lua_unit.cpp 			ERR_LUA &lt;&lt; "Could not move unit " &lt;&lt; ptr-&gt;underlying_id() &lt;&lt; " onto map location " &lt;&lt; loc &lt;&lt; '\n';</span>
<span class='curline'><a href='../S/194.html#L82'>ptr</a>                82 src/scripting/lua_unit.hpp 	unit_ptr ptr;</span>
<span class='curline'><a href='../S/194.html#L93'>ptr</a>                93 src/scripting/lua_unit.hpp 	lua_unit(size_t u): uid(u), ptr(), side(0), c_ptr() {}</span>
<span class='curline'><a href='../S/194.html#L94'>ptr</a>                94 src/scripting/lua_unit.hpp 	lua_unit(unit_ptr u): uid(0), ptr(u), side(0), c_ptr() {}</span>
<span class='curline'><a href='../S/194.html#L95'>ptr</a>                95 src/scripting/lua_unit.hpp 	lua_unit(int s, size_t u): uid(u), ptr(), side(s), c_ptr() {}</span>
<span class='curline'><a href='../S/194.html#L96'>ptr</a>                96 src/scripting/lua_unit.hpp 	lua_unit(unit&amp; u): uid(0), ptr(), side(0), c_ptr(&amp;u) {}</span>
<span class='curline'><a href='../S/194.html#L99'>ptr</a>                99 src/scripting/lua_unit.hpp 	bool on_map() const { return !ptr &amp;&amp; side == 0; }</span>
<span class='curline'><a href='../S/194.html#L108'>ptr</a>               108 src/scripting/lua_unit.hpp 	void clear_ref() { uid = 0; ptr = unit_ptr(); side = 0; c_ptr = nullptr; }</span>
<span class='curline'><a href='../S/165.html#L807'>ptr</a>               807 src/server/simple_wml.cpp 	char* ptr = &amp;v[0];</span>
<span class='curline'><a href='../S/165.html#L808'>ptr</a>               808 src/server/simple_wml.cpp 	mutable_node.output(ptr, node::DO_NOT_MODIFY_CACHE);</span>
<span class='curline'><a href='../S/165.html#L809'>ptr</a>               809 src/server/simple_wml.cpp 	assert(ptr == &amp;v[0] + v.size());</span>
<span class='curline'><a href='../S/939.html#L185'>ptr</a>               185 src/sound.cpp  		[&amp;track](const std::shared_ptr&lt;const sound::music_track&gt;&amp; ptr) { return *ptr == track; }</span>
<span class='curline'><a href='../S/1008.html#L155'>ptr</a>               155 src/units/unit.cpp 	T* copy_or_null(const std::unique_ptr&lt;T&gt;&amp; ptr)</span>
<span class='curline'><a href='../S/1008.html#L157'>ptr</a>               157 src/units/unit.cpp 		return ptr ? new T(*ptr) : nullptr;</span>
<span class='curline'><a href='../S/860.html#L99'>ptr</a>                99 src/utils/smart_list.hpp 		explicit iterator_base(node_t * ptr) : ptr_(ptr)</span>
<span class='curline'><a href='../S/860.html#L163'>ptr</a>               163 src/utils/smart_list.hpp 		static bool derefable(node_t * ptr){ return ptr  &amp;&amp;  ptr-&gt;dat_ptr; }</span>
<span class='curline'><a href='../S/860.html#L193'>ptr</a>               193 src/utils/smart_list.hpp 		explicit iterator(node_t * ptr) : iterator_base&lt;Data, false&gt;(ptr) {}</span>
<span class='curline'><a href='../S/860.html#L203'>ptr</a>               203 src/utils/smart_list.hpp 		explicit const_iterator(node_t * ptr) : iterator_base&lt;const Data, false&gt;(ptr) {}</span>
<span class='curline'><a href='../S/860.html#L215'>ptr</a>               215 src/utils/smart_list.hpp 		explicit reverse_iterator(node_t * ptr) : iterator_base&lt;Data, true&gt;(ptr) {}</span>
<span class='curline'><a href='../S/860.html#L225'>ptr</a>               225 src/utils/smart_list.hpp 		explicit const_reverse_iterator(node_t * ptr) : iterator_base&lt;const Data, true&gt;(ptr) {}</span>
<span class='curline'><a href='../S/321.html#L168'>ptr</a>               168 src/wesnothd_connection.hpp 	wesnothd_connection_ptr(std::shared_ptr&lt;wesnothd_connection&gt;&amp;&amp; ptr)</span>
<span class='curline'><a href='../S/321.html#L169'>ptr</a>               169 src/wesnothd_connection.hpp 		: ptr_(std::move(ptr))</span>
<span class='curline'><a href='../S/1081.html#L166'>ptr</a>               166 src/xBRZ/xbrz.cpp uint32_t*       byteAdvance(      uint32_t* ptr, int bytes) {  return reinterpret_cast&lt;      uint32_t*&gt;(reinterpret_cast&lt;      char*&gt;(ptr) + bytes); }</span>
<span class='curline'><a href='../S/1081.html#L167'>ptr</a>               167 src/xBRZ/xbrz.cpp const uint32_t* byteAdvance(const uint32_t* ptr, int bytes) {  return reinterpret_cast&lt;const uint32_t*&gt;(reinterpret_cast&lt;const char*&gt;(ptr) + bytes); }</span>
</pre>
</body>
</html>
