<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>node_t</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/856.html#L53'>node_t</a>             53 src/utils/smart_list.hpp 		node_t() : dat_ptr(nullptr), ref_count(1), next(this), prev(this)</span>
<span class='curline'><a href='../S/856.html#L56'>node_t</a>             56 src/utils/smart_list.hpp 		explicit node_t(const Data &amp; d) : dat_ptr(new Data(d)), ref_count(1), next(nullptr), prev(nullptr)</span>
<span class='curline'><a href='../S/856.html#L59'>node_t</a>             59 src/utils/smart_list.hpp 		~node_t();</span>
<span class='curline'><a href='../S/856.html#L67'>node_t</a>             67 src/utils/smart_list.hpp 		node_t * next;</span>
<span class='curline'><a href='../S/856.html#L68'>node_t</a>             68 src/utils/smart_list.hpp 		node_t * prev;</span>
<span class='curline'><a href='../S/856.html#L72'>node_t</a>             72 src/utils/smart_list.hpp 		node_t &amp; operator=(const node_t &amp;);</span>
<span class='curline'><a href='../S/856.html#L74'>node_t</a>             74 src/utils/smart_list.hpp 		node_t(const node_t &amp; that);</span>
<span class='curline'><a href='../S/856.html#L85'>node_t</a>             85 src/utils/smart_list.hpp 		typedef typename smart_list&lt;Data&gt;::node_t node_t;</span>
<span class='curline'><a href='../S/856.html#L99'>node_t</a>             99 src/utils/smart_list.hpp 		explicit iterator_base(node_t * ptr) : ptr_(ptr)</span>
<span class='curline'><a href='../S/856.html#L119'>node_t</a>            119 src/utils/smart_list.hpp 			node_t * old_ptr = ptr_;</span>
<span class='curline'><a href='../S/856.html#L163'>node_t</a>            163 src/utils/smart_list.hpp 		static bool derefable(node_t * ptr){ return ptr  &amp;&amp;  ptr-&gt;dat_ptr; }</span>
<span class='curline'><a href='../S/856.html#L173'>node_t</a>            173 src/utils/smart_list.hpp 		static void unref(node_t * old_ptr);</span>
<span class='curline'><a href='../S/856.html#L176'>node_t</a>            176 src/utils/smart_list.hpp 		node_t * ptr_;</span>
<span class='curline'><a href='../S/856.html#L193'>node_t</a>            193 src/utils/smart_list.hpp 		explicit iterator(node_t * ptr) : iterator_base&lt;Data, false&gt;(ptr) {}</span>
<span class='curline'><a href='../S/856.html#L203'>node_t</a>            203 src/utils/smart_list.hpp 		explicit const_iterator(node_t * ptr) : iterator_base&lt;const Data, false&gt;(ptr) {}</span>
<span class='curline'><a href='../S/856.html#L215'>node_t</a>            215 src/utils/smart_list.hpp 		explicit reverse_iterator(node_t * ptr) : iterator_base&lt;Data, true&gt;(ptr) {}</span>
<span class='curline'><a href='../S/856.html#L225'>node_t</a>            225 src/utils/smart_list.hpp 		explicit const_reverse_iterator(node_t * ptr) : iterator_base&lt;const Data, true&gt;(ptr) {}</span>
<span class='curline'><a href='../S/856.html#L246'>node_t</a>            246 src/utils/smart_list.hpp 	const_iterator end() const             { return const_iterator(const_cast&lt;node_t *&gt;(&amp;root_)); }</span>
<span class='curline'><a href='../S/856.html#L250'>node_t</a>            250 src/utils/smart_list.hpp 	const_reverse_iterator rend() const    { return const_reverse_iterator(const_cast&lt;node_t *&gt;(&amp;root_)); }</span>
<span class='curline'><a href='../S/856.html#L307'>node_t</a>            307 src/utils/smart_list.hpp 	static bool flagged(const node_t &amp; node)  { return node.ref_count % 2 == 0; }</span>
<span class='curline'><a href='../S/856.html#L309'>node_t</a>            309 src/utils/smart_list.hpp 	static void flag(const node_t &amp; node)     { node.ref_count &amp;= ~size_t(1); }</span>
<span class='curline'><a href='../S/856.html#L313'>node_t</a>            313 src/utils/smart_list.hpp 	static node_t * insert(node_t * const pos, const value_type &amp; d);</span>
<span class='curline'><a href='../S/856.html#L314'>node_t</a>            314 src/utils/smart_list.hpp 	static node_t * check_erase(node_t * const pos);</span>
<span class='curline'><a href='../S/856.html#L315'>node_t</a>            315 src/utils/smart_list.hpp 	static void link(node_t * const pos, node_t &amp; begin_link, node_t &amp; end_link);</span>
<span class='curline'><a href='../S/856.html#L316'>node_t</a>            316 src/utils/smart_list.hpp 	static void unlink(node_t &amp; begin_unlink, node_t &amp; end_unlink);</span>
<span class='curline'><a href='../S/856.html#L317'>node_t</a>            317 src/utils/smart_list.hpp 	static void splice(node_t * const pos, node_t &amp; f, node_t &amp; l);</span>
<span class='curline'><a href='../S/856.html#L322'>node_t</a>            322 src/utils/smart_list.hpp 	node_t root_;</span>
<span class='curline'><a href='../S/856.html#L422'>node_t</a>            422 src/utils/smart_list.hpp 	node_t * node_ptr = start.ptr_;</span>
<span class='curline'><a href='../S/856.html#L549'>node_t</a>            549 src/utils/smart_list.hpp 	node_t * dest = root_.next;</span>
<span class='curline'><a href='../S/856.html#L550'>node_t</a>            550 src/utils/smart_list.hpp 	node_t * source = L.root_.next;</span>
<span class='curline'><a href='../S/856.html#L557'>node_t</a>            557 src/utils/smart_list.hpp 			node_t * end_merge = source-&gt;next;</span>
<span class='curline'><a href='../S/856.html#L590'>node_t</a>            590 src/utils/smart_list.hpp 	for ( node_t * node_ptr = root_.next; iterator::derefable(node_ptr); node_ptr = node_ptr-&gt;next )</span>
<span class='curline'><a href='../S/856.html#L619'>node_t</a>            619 src/utils/smart_list.hpp inline typename smart_list&lt;Data&gt;::node_t * smart_list&lt;Data&gt;::insert</span>
<span class='curline'><a href='../S/856.html#L620'>node_t</a>            620 src/utils/smart_list.hpp 	(node_t * const pos, const value_type &amp; d)</span>
<span class='curline'><a href='../S/856.html#L622'>node_t</a>            622 src/utils/smart_list.hpp 	node_t * new_node = new node_t(d);</span>
<span class='curline'><a href='../S/856.html#L635'>node_t</a>            635 src/utils/smart_list.hpp inline typename smart_list&lt;Data&gt;::node_t * smart_list&lt;Data&gt;::check_erase</span>
<span class='curline'><a href='../S/856.html#L636'>node_t</a>            636 src/utils/smart_list.hpp 	(node_t * const pos)</span>
<span class='curline'><a href='../S/856.html#L643'>node_t</a>            643 src/utils/smart_list.hpp 	node_t * ret_val = pos-&gt;next;</span>
<span class='curline'><a href='../S/856.html#L664'>node_t</a>            664 src/utils/smart_list.hpp inline void smart_list&lt;Data&gt;::link(node_t * const pos, node_t &amp; begin_link, node_t &amp; end_link)</span>
<span class='curline'><a href='../S/856.html#L683'>node_t</a>            683 src/utils/smart_list.hpp inline void smart_list&lt;Data&gt;::unlink(node_t &amp; begin_unlink, node_t &amp; end_unlink)</span>
<span class='curline'><a href='../S/856.html#L699'>node_t</a>            699 src/utils/smart_list.hpp inline void smart_list&lt;Data&gt;::splice(node_t * const pos, node_t &amp; b, node_t &amp; e)</span>
<span class='curline'><a href='../S/856.html#L754'>node_t</a>            754 src/utils/smart_list.hpp inline smart_list&lt;Data&gt;::node_t::~node_t()</span>
<span class='curline'><a href='../S/856.html#L783'>node_t</a>            783 src/utils/smart_list.hpp 	node_t * old_ptr = ptr_;</span>
<span class='curline'><a href='../S/856.html#L820'>node_t</a>            820 src/utils/smart_list.hpp inline void smart_list&lt;Data&gt;::iterator_base&lt;Value, Reversed&gt;::unref(node_t * old_ptr)</span>
</pre>
</body>
</html>
