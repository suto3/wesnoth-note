<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>turn_end</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.6' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/707.html#L97'>turn_end</a>           97 src/tests/test_whiteboard_side_actions.cpp 	BOOST_REQUIRE(3+sac.turn_begin(1) == sac.turn_end(1));</span>
<span class='curline'><a href='../S/1234.html#L988'>turn_end</a>          988 src/whiteboard/manager.cpp 	while (sa-&gt;turn_begin(0) != sa-&gt;turn_end(0))</span>
<span class='curline'><a href='../S/1245.html#L103'>turn_end</a>          103 src/whiteboard/mapbuilder.cpp 				side_actions::iterator it = actions.turn_begin(turn), next = it, end = actions.turn_end(turn);</span>
<span class='curline'><a href='../S/1230.html#L57'>turn_end</a>           57 src/whiteboard/side_actions.cpp 		for(wb::side_actions::const_iterator it = side_actions.turn_begin(turn); it != side_actions.turn_end(turn); ++it) {</span>
<span class='curline'><a href='../S/1230.html#L166'>turn_end</a>          166 src/whiteboard/side_actions.cpp 	std::pair&lt;iterator,bool&gt; res = actions_.insert(turn_end(turn_num), action);</span>
<span class='curline'><a href='../S/1230.html#L230'>turn_end</a>          230 src/whiteboard/side_actions.cpp 				*beginning = turn_end(0); // Otherwise, we are emptying the current turn.</span>
<span class='curline'><a href='../S/1230.html#L321'>turn_end</a>          321 src/whiteboard/side_actions.cpp 	assert(position &lt; turn_end(0)); //can't execute actions from future turns</span>
<span class='curline'><a href='../S/1230.html#L891'>turn_end</a>          891 src/whiteboard/side_actions.cpp 	for(iterator act=turn_begin(0), end=turn_end(0); act!=end; ++act) {</span>
<span class='curline'><a href='../S/1230.html#L896'>turn_end</a>          896 src/whiteboard/side_actions.cpp 	actions_.erase(turn_begin(0), turn_end(0));</span>
<span class='curline'><a href='../S/1228.html#L232'>turn_end</a>          232 src/whiteboard/side_actions.hpp 	reverse_iterator turn_rbegin(size_t turn_num){ return reverse_iterator(turn_end(turn_num)); }</span>
<span class='curline'><a href='../S/1228.html#L233'>turn_end</a>          233 src/whiteboard/side_actions.hpp 	const_reverse_iterator turn_rbegin(size_t turn_num) const { return reverse_iterator(turn_end(turn_num)); }</span>
<span class='curline'><a href='../S/1228.html#L246'>turn_end</a>          246 src/whiteboard/side_actions.hpp 	range_t iter_turn(size_t turn_num){ return range_t(turn_begin(turn_num),turn_end(turn_num)); }</span>
<span class='curline'><a href='../S/1228.html#L248'>turn_end</a>          248 src/whiteboard/side_actions.hpp 	crange_t iter_turn(size_t turn_num) const { return crange_t(turn_begin(turn_num),turn_end(turn_num)); }</span>
<span class='curline'><a href='../S/1228.html#L252'>turn_end</a>          252 src/whiteboard/side_actions.hpp 	size_t turn_size(size_t turn_num) const { return turn_end(turn_num) - turn_begin(turn_num); }</span>
<span class='curline'><a href='../S/1228.html#L422'>turn_end</a>          422 src/whiteboard/side_actions.hpp 	iterator turn_end(size_t turn_num){ return actions_.turn_end(turn_num); }</span>
<span class='curline'><a href='../S/1228.html#L426'>turn_end</a>          426 src/whiteboard/side_actions.hpp 	const_iterator turn_end(size_t turn_num) const { return actions_.turn_end(turn_num); }</span>
<span class='curline'><a href='../S/1235.html#L177'>turn_end</a>          177 src/whiteboard/utility.cpp 				for(auto iter = actions.turn_begin(turn); iter != actions.turn_end(turn); ++iter) {</span>
</pre>
</body>
</html>
